<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>C# &#43; Revit API: Lesson 12 - FilteredElementCollector | Blog</title>
<meta name="keywords" content="C#, Revit, Tutorial">
<meta name="description" content="Goal

In most Revit add-ins, your first step will be to collect elements from the model.
The go-to tool for this is the FilteredElementCollector, which lets you gather elements and then refine your selection using a variety of filtering techniques in C#.

To explore everything there is to know about:
FilteredElementCollector

The FilteredElementCollector is a special Revit API class that works much like running a database query, with your Revit document acting as the database.
It allows you to start with a broad set of elements and then refine your results using various filtering methods to target exactly what you need.

Declaring a Collector

To create a collector for the entire document:



1


var collector = new FilteredElementCollector(doc);



If you only want elements visible in a specific view, pass the view’s Id:



1


var collector = new FilteredElementCollector(doc, view.Id);


Revit API
FilteredElementCollector Constructors
The FilteredElementCollector provides multiple constructor overloads, allowing you to start your collection from different scopes depending on your needs.">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/posts/lesson-12/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.6d585472a409a8f504e6bf969a2864fd1288e629997cd2926dd96376ae22831b.css" integrity="sha256-bVhUcqQJqPUE5r&#43;Wmihk/RKI5imZfNKSbdljdq4igxs=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/lesson-12/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="http://localhost:1313/posts/lesson-12/">
  <meta property="og:site_name" content="Blog">
  <meta property="og:title" content="C# &#43; Revit API: Lesson 12 - FilteredElementCollector">
  <meta property="og:description" content="Goal In most Revit add-ins, your first step will be to collect elements from the model. The go-to tool for this is the FilteredElementCollector, which lets you gather elements and then refine your selection using a variety of filtering techniques in C#. To explore everything there is to know about: FilteredElementCollector The FilteredElementCollector is a special Revit API class that works much like running a database query, with your Revit document acting as the database. It allows you to start with a broad set of elements and then refine your results using various filtering methods to target exactly what you need. Declaring a Collector To create a collector for the entire document: 1 var collector = new FilteredElementCollector(doc); If you only want elements visible in a specific view, pass the view’s Id: 1 var collector = new FilteredElementCollector(doc, view.Id); Revit API FilteredElementCollector Constructors The FilteredElementCollector provides multiple constructor overloads, allowing you to start your collection from different scopes depending on your needs.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-08-15T10:37:24+03:00">
    <meta property="article:modified_time" content="2025-08-15T10:37:24+03:00">
    <meta property="article:tag" content="C#">
    <meta property="article:tag" content="Revit">
    <meta property="article:tag" content="Tutorial">
    <meta property="og:image" content="http://localhost:1313/images/Pasted%20image%2020250902210047.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:1313/images/Pasted%20image%2020250902210047.png">
<meta name="twitter:title" content="C# &#43; Revit API: Lesson 12 - FilteredElementCollector">
<meta name="twitter:description" content="Goal

In most Revit add-ins, your first step will be to collect elements from the model.
The go-to tool for this is the FilteredElementCollector, which lets you gather elements and then refine your selection using a variety of filtering techniques in C#.

To explore everything there is to know about:
FilteredElementCollector

The FilteredElementCollector is a special Revit API class that works much like running a database query, with your Revit document acting as the database.
It allows you to start with a broad set of elements and then refine your results using various filtering methods to target exactly what you need.

Declaring a Collector

To create a collector for the entire document:



1


var collector = new FilteredElementCollector(doc);



If you only want elements visible in a specific view, pass the view’s Id:



1


var collector = new FilteredElementCollector(doc, view.Id);


Revit API
FilteredElementCollector Constructors
The FilteredElementCollector provides multiple constructor overloads, allowing you to start your collection from different scopes depending on your needs.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://localhost:1313/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "C# + Revit API: Lesson 12 - FilteredElementCollector",
      "item": "http://localhost:1313/posts/lesson-12/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "C# + Revit API: Lesson 12 - FilteredElementCollector",
  "name": "C# \u002b Revit API: Lesson 12 - FilteredElementCollector",
  "description": "Goal In most Revit add-ins, your first step will be to collect elements from the model. The go-to tool for this is the FilteredElementCollector, which lets you gather elements and then refine your selection using a variety of filtering techniques in C#. To explore everything there is to know about: FilteredElementCollector The FilteredElementCollector is a special Revit API class that works much like running a database query, with your Revit document acting as the database. It allows you to start with a broad set of elements and then refine your results using various filtering methods to target exactly what you need. Declaring a Collector To create a collector for the entire document: 1 var collector = new FilteredElementCollector(doc); If you only want elements visible in a specific view, pass the view’s Id: 1 var collector = new FilteredElementCollector(doc, view.Id); Revit API FilteredElementCollector Constructors The FilteredElementCollector provides multiple constructor overloads, allowing you to start your collection from different scopes depending on your needs.\n",
  "keywords": [
    "C#", "Revit", "Tutorial"
  ],
  "articleBody": "Goal In most Revit add-ins, your first step will be to collect elements from the model. The go-to tool for this is the FilteredElementCollector, which lets you gather elements and then refine your selection using a variety of filtering techniques in C#. To explore everything there is to know about: FilteredElementCollector The FilteredElementCollector is a special Revit API class that works much like running a database query, with your Revit document acting as the database. It allows you to start with a broad set of elements and then refine your results using various filtering methods to target exactly what you need. Declaring a Collector To create a collector for the entire document: 1 var collector = new FilteredElementCollector(doc); If you only want elements visible in a specific view, pass the view’s Id: 1 var collector = new FilteredElementCollector(doc, view.Id); Revit API FilteredElementCollector Constructors The FilteredElementCollector provides multiple constructor overloads, allowing you to start your collection from different scopes depending on your needs.\n1. Constructor with Document\nThe most common constructor — collects elements from the entire document.\nFilteredElementCollector Constructor (Document): 1 2 3 public FilteredElementCollector( Document document // The document to search in. ) Example:\n1 var collector = new FilteredElementCollector(doc); 2. Constructor with Document and ElementId (View)\nCollects only elements visible in a specific view, identified by its ElementId.\nFilteredElementCollector Constructor (Document, ElementId) 1 2 3 4 public FilteredElementCollector( Document document, ElementId viewId // The view’s ID. ) Example:\n1 var collector = new FilteredElementCollector(doc, view.Id); 3. Constructor with Document and ICollection\nFilters a predefined set of elements. Useful when you’ve already gathered certain elements and want to further refine that list.\nFilteredElementCollector Constructor (Document, ICollection(ElementId)) 1 2 3 4 public FilteredElementCollector( Document document, ICollection\u003cElementId\u003e elementIds // A set of element IDs to filter. ) Example:\n1 var collector = new FilteredElementCollector(doc, myElementIds); 4. Constructor with Document, ElementId (View), and ElementId (Link)\nFilters elements within a linked Revit model, scoped to a specific view.\nFilteredElementCollector Constructor (Document, ElementId, ElementId) 1 2 3 4 5 public FilteredElementCollector( Document document, ElementId viewId, // The view ID in the host document. ElementId linkId // The Revit link instance ID in the host document. ) Example:\n1 var collector = new FilteredElementCollector(doc, view.Id, linkInstance.Id); FilteredElementCollector Methods Name Description ContainedInDesignOption Applies an ElementDesignOptionFilter to the collector. Dispose Equals Determines whether the specified object is equal to the current object. (Inherited from Object ) Excluding Applies an ExclusionFilter to the collector. FirstElement Returns the first element to pass the filter(s). FirstElementId Returns the id of the first element to pass the filter(s). GetBasicIEnumerator Returns an enumerator that iterates through a collection. GetElementCount Gets the number of elements in your current filter. GetElementIdIterator Returns an element id iterator to the elements passing the filters. GetElementIterator Returns an element iterator to the elements passing the filters. GetEnumerator Returns an enumerator that iterates through a collection. GetHashCode Serves as the default hash function. (Inherited from Object ) GetType Gets the Type of the current instance. (Inherited from Object ) IntersectWith Intersects the set of elements passing the filter in this collector with the set of elements passing the filter in another collector. IsViewValidForElementIteration Identifies if the particular element is valid for iteration of drawn elements. OfCategory Applies an ElementCategoryFilter to the collector. OfCategoryId Applies an ElementCategoryFilter to the collector. OfClass Applies an ElementClassFilter to the collector. OwnedByView Applies an ElementOwnerViewFilter to the collector. ToElementIds Returns the complete set of element ids that pass the filter(s). ToElements Returns the complete set of elements that pass the filter(s). ToString Returns a string that represents the current object. (Inherited from Object ) UnionWith Unites the set of elements passing the filter in this collector with the set of elements passing the filter in another collector. WhereElementIsCurveDriven Applies an ElementIsCurveDrivenFilter to the collector. WhereElementIsElementType Applies an ElementIsElementTypeFilter to the collector. WhereElementIsNotElementType Applies an inverted ElementIsElementTypeFilter to the collector. WhereElementIsViewIndependent Applies an ElementOwnerViewFilter to the collector. WherePasses Applies an element filter to the collector. Method Chaining in C# What is Method Chaining? Method chaining allows you to call multiple methods on an object in a single statement by linking them together with dots (.). Each method returns an object that the next method can be called on.\nThink of it like a conveyor belt in a factory - each station (method) processes the item and passes it to the next station.\nBasic Concept Instead of writing multiple separate lines:\n1 2 3 4 5 // Without chaining (multiple lines) var collector = new FilteredElementCollector(doc); collector = collector.OfClass(typeof(Wall)); collector = collector.WhereElementIsNotElementType(); var elements = collector.ToElements(); You can chain methods together:\n1 2 3 4 5 // With chaining (single statement) var elements = new FilteredElementCollector(doc) .OfClass(typeof(Wall)) .WhereElementIsNotElementType() .ToElements(); How Method Chaining Works Return Value: Each method in the chain returns an object (often the same type) Dot Notation: Use . to call the next method on the returned object Left-to-Right: Methods execute from left to right (or top to bottom when formatted) Understanding .OfClass vs .OfCategory This is crucial to understand! These two methods filter eleme=nts in completely different ways:\n.OfClass() - Filters by C# Class Type Filters based on the underlying programming class in the Revit API Examples: Wall, Floor, FamilyInstance, TextNote, etc. One class can contain multiple categories .OfCategory() - Filters by Revit Category Filters based on the visual category you see in Revit’s interface Examples: OST_Walls, OST_Doors, OST_Windows, OST_Floors, etc. More specific than class filtering Key Insight: FamilyInstance Class Many different Revit elements share the same class but have different categories:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // These are ALL FamilyInstance class, but different categories: var doors = new FilteredElementCollector(doc) .OfClass(typeof(FamilyInstance)) // Class: FamilyInstance .OfCategory(BuiltInCategory.OST_Doors) // Category: Doors .ToElements(); var windows = new FilteredElementCollector(doc) .OfClass(typeof(FamilyInstance)) // Class: FamilyInstance .OfCategory(BuiltInCategory.OST_Windows) // Category: Windows .ToElements(); var furniture = new FilteredElementCollector(doc) .OfClass(typeof(FamilyInstance)) // Class: FamilyInstance .OfCategory(BuiltInCategory.OST_Furniture) // Category: Furniture .ToElements(); When to Use Which? Use .OfClass() when:\nYou want ALL elements of a specific programming type The class directly matches what you want (like Wall, Floor) Use .OfCategory() when:\nYou want elements from a specific Revit category You’re working with FamilyInstances and need to specify which type Use BOTH when:\nYou want to be very specific and ensure you get exactly what you expect Understanding BuiltInCategory and Alternatives What is BuiltInCategory? BuiltInCategory is an enumeration (enum) provided by the Revit API that contains predefined constants for all the standard Revit categories. Think of it as a list of “official category names” that Revit recognizes.\n1 2 3 4 5 6 7 // BuiltInCategory is an enum with values like: BuiltInCategory.OST_Walls BuiltInCategory.OST_Doors BuiltInCategory.OST_Windows BuiltInCategory.OST_Floors BuiltInCategory.OST_Furniture // ... and hundreds more Why Use BuiltInCategory? (Recommended Approach) Advantages:\nType Safety: The compiler catches typos IntelliSense: Auto-complete shows you available options No Spelling Errors: Can’t misspell category names Language Independent: Works regardless of Revit’s display language Future Proof: Updates automatically with new Revit versions 1 2 3 4 5 // ✅ GOOD: Using BuiltInCategory var doors = new FilteredElementCollector(doc) .OfCategory(BuiltInCategory.OST_Doors) // IntelliSense helps, no typos possible .WhereElementIsNotElementType() .ToElements(); Alternative 1: Using Category Objects You can get Category objects and use their ElementId:\n1 2 3 4 5 6 7 8 9 10 11 12 // Find category by name var doorCategory = doc.Categories .Cast\u003cCategory\u003e() .FirstOrDefault(c =\u003e c.Name == \"Doors\"); if (doorCategory != null) { var doors = new FilteredElementCollector(doc) .OfCategoryId(doorCategory.Id) // Using ElementId .WhereElementIsNotElementType() .ToElements(); } When to use:\nWorking with custom categories created by users Dynamic category selection based on user input When you need access to Category properties Alternative 2: Using Category Names (Not Recommended) 1 2 3 4 5 6 7 8 9 10 11 12 // ❌ PROBLEMATIC: This approach has issues var allCategories = doc.Categories; foreach (Category cat in allCategories) { if (cat.Name == \"Doors\") // Depends on Revit language! { var doors = new FilteredElementCollector(doc) .OfCategoryId(cat.Id) .ToElements(); break; } } Problems with this approach:\nLanguage Dependent: “Doors” in English, “Portes” in French, “Türen” in German Typo Prone: Easy to misspell category names Performance: Requires searching through all categories Fragile: Breaks if category names change Alternative 3: Converting Between Approaches Sometimes you need to convert between different category representations:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // Convert BuiltInCategory to Category object var builtInCat = BuiltInCategory.OST_Doors; var category = Category.GetCategory(doc, builtInCat); // Convert BuiltInCategory to ElementId var elementId = new ElementId(builtInCat); // Use either approach: var doors1 = new FilteredElementCollector(doc) .OfCategory(builtInCat) // Direct BuiltInCategory .ToElements(); var doors2 = new FilteredElementCollector(doc) .OfCategoryId(elementId) // Using ElementId .ToElements(); Practical Example: User-Defined Categories When dealing with custom categories (created by users), you’ll need the Category object approach:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // Example: Get elements from a custom category public IList\u003cElement\u003e GetElementsFromCustomCategory(Document doc, string categoryName) { // Find the custom category var customCategory = doc.Categories .Cast\u003cCategory\u003e() .FirstOrDefault(c =\u003e c.Name.Equals(categoryName, StringComparison.OrdinalIgnoreCase)); if (customCategory != null) { return new FilteredElementCollector(doc) .OfCategoryId(customCategory.Id) .WhereElementIsNotElementType() .ToElements(); } return new List\u003cElement\u003e(); // Return empty list if category not found } Best Practice Summary Use BuiltInCategory for standard Revit categories (95% of cases):\n1 .OfCategory(BuiltInCategory.OST_Doors) Use Category objects for custom or dynamic scenarios:\n1 .OfCategoryId(customCategory.Id) Avoid string-based category searching unless absolutely necessary.\nCommon BuiltInCategory Values Here are some frequently used categories for reference:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // Architectural BuiltInCategory.OST_Walls BuiltInCategory.OST_Doors BuiltInCategory.OST_Windows BuiltInCategory.OST_Floors BuiltInCategory.OST_Roofs BuiltInCategory.OST_Ceilings BuiltInCategory.OST_Stairs // MEP BuiltInCategory.OST_DuctCurves BuiltInCategory.OST_PipeCurves BuiltInCategory.OST_ElectricalFixtures BuiltInCategory.OST_LightingFixtures // Structural BuiltInCategory.OST_StructuralColumns BuiltInCategory.OST_StructuralFraming BuiltInCategory.OST_StructuralFoundation // Furniture \u0026 Equipment BuiltInCategory.OST_Furniture BuiltInCategory.OST_SpecialityEquipment BuiltInCategory.OST_PlumbingFixtures FilteredElementCollector Examples Example 1: Get All Walls (Class-based) 1 2 3 4 var walls = new FilteredElementCollector(doc) .OfClass(typeof(Wall)) // Wall class = Wall category .WhereElementIsNotElementType() .ToElements(); Example 2: Get Windows (Category-based - More Common) 1 2 3 4 var windows = new FilteredElementCollector(doc) .OfCategory(BuiltInCategory.OST_Windows) // Category filtering .WhereElementIsNotElementType() .ToElements(); Example 3: Get Windows (Belt \u0026 Suspenders Approach) 1 2 3 4 5 var windows = new FilteredElementCollector(doc) .OfClass(typeof(FamilyInstance)) // Class filtering .OfCategory(BuiltInCategory.OST_Windows) // Category filtering .WhereElementIsNotElementType() .ToElements(); Example 4: Get ALL Family Instances (Any Category) 1 2 3 4 var allFamilyInstances = new FilteredElementCollector(doc) .OfClass(typeof(FamilyInstance)) // Gets doors, windows, furniture, etc. .WhereElementIsNotElementType() .ToElements(); Understanding .WhereElementIsNotElementType() This method is extremely important and addresses a fundamental concept in Revit: the difference between Element Types and Element Instances.\nElement Types vs Element Instances Element Types (Templates/Definitions):\nThese are the “recipes” or “templates” for elements Examples: “Interior Door 36”×84\"\", “Exterior Wall - Brick”, “Standard Table” You see these in the Project Browser under “Families” They define properties but aren’t physical objects in your model Element Instances (Actual Placed Elements):\nThese are the actual elements placed in your model Examples: The specific door at coordinate (10, 5), the wall from point A to B These are what you see and select in your 3D/plan views They reference a type but exist at specific locations The Methods 1 2 3 4 5 // Gets ONLY element instances (the actual placed elements) .WhereElementIsNotElementType() // Gets ONLY element types (the definitions/templates) .WhereElementIsElementType() Why This Matters When you collect elements without these filters, you get BOTH types and instances:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // WITHOUT filtering - gets both types and instances var everything = new FilteredElementCollector(doc) .OfCategory(BuiltInCategory.OST_Doors) .ToElements(); // Result: Door types AND door instances mixed together // WITH instance filtering - gets only placed doors var actualDoors = new FilteredElementCollector(doc) .OfCategory(BuiltInCategory.OST_Doors) .WhereElementIsNotElementType() // Only instances .ToElements(); // Result: Only the actual doors placed in the model // WITH type filtering - gets only door type definitions var doorTypes = new FilteredElementCollector(doc) .OfCategory(BuiltInCategory.OST_Doors) .WhereElementIsElementType() // Only types .ToElements(); // Result: Only the door type definitions Common Use Cases Most Common: Get Instances (.WhereElementIsNotElementType())\n1 2 3 4 5 6 7 8 9 10 11 // Count how many doors are actually placed in the model var doorCount = new FilteredElementCollector(doc) .OfCategory(BuiltInCategory.OST_Doors) .WhereElementIsNotElementType() .GetElementCount(); // Get all placed walls to analyze their geometry var walls = new FilteredElementCollector(doc) .OfClass(typeof(Wall)) .WhereElementIsNotElementType() .ToElements(); Sometimes Needed: Get Types (.WhereElementIsElementType())\n1 2 3 4 5 6 7 8 9 10 11 // Get all door types to list available options var doorTypes = new FilteredElementCollector(doc) .OfCategory(BuiltInCategory.OST_Doors) .WhereElementIsElementType() .ToElements(); // Get all wall types to copy to another project var wallTypes = new FilteredElementCollector(doc) .OfClass(typeof(WallType)) // WallType class .WhereElementIsElementType() // Redundant but explicit .ToElements(); Pro Tip: Some Classes Are Always Types Some classes like WallType, FloorType, FamilySymbol are always types, so .WhereElementIsElementType() is redundant (but harmless):\n1 2 3 4 5 6 7 8 9 // These are equivalent for type classes: var wallTypes1 = new FilteredElementCollector(doc) .OfClass(typeof(WallType)) .ToElements(); var wallTypes2 = new FilteredElementCollector(doc) .OfClass(typeof(WallType)) .WhereElementIsElementType() // Redundant but OK .ToElements(); Memory Aid Instance = “In-stance” = IN the model (placed/physical) Type = “Template” = NOT placed (definition only) Rule of thumb: 99% of the time you want .WhereElementIsNotElementType() because you’re working with actual placed elements!\nExample 5: To Get All Elements Visible in a Specific View 1 2 3 4 var visibleElements = new FilteredElementCollector(doc, viewId) .OfClass(typeof(FamilyInstance)) .WhereElementIsNotElementType() .ToElementIds(); Custom Filters 1 2 3 4 5 var filteredElements = new FilteredElementCollector(doc) .OfCategory(BuiltInCategory.OST_Doors) .WhereElementIsNotElementType() .WherePasses(new ElementLevelFilter(levelId)) .ToElements(); Understanding .WherePasses() and Custom Filters The .WherePasses() method allows you to apply custom filters that go beyond the basic filtering capabilities of .OfClass() and .OfCategory(). This is where you can get very specific about which elements you want, such as getting all elements whose parameter meets a certain condition. These are often complex to construct but perform faster than the alternative LINQ methods. Custom Filters are considered best-practice to build scalable applications rather than LINQ. Here is an example of 5 steps involved constructing a rule to provide to a WherePasses() filter: 1 2 3 4 5 var parameterId = new ElementId(BuiltInParameter); var provider = new ParameterValueProvider(parameterId); var rule = new FilterNumericLess(); var passesRule = new FilterDoubleRule(provider, rule, tolerance); var paramFilter = new ElementParameterFilter(passesRule); .WherePasses() Syntax 1 .WherePasses(new SomeFilter(parameters)) ElementLevelFilter Example 6 The ElementLevelFilter filters elements based on which level they belong to:\n1 2 3 4 5 6 // Get all doors on Level 1 var level1Doors = new FilteredElementCollector(doc) .OfCategory(BuiltInCategory.OST_Doors) .WhereElementIsNotElementType() .WherePasses(new ElementLevelFilter(levelId)) // Only elements on this level .ToElements(); What you need:\nlevelId - The ElementId of the specific level you want to filter by How to get a levelId:\n1 2 3 4 5 6 7 8 9 10 11 12 // Option 1: Find level by name var level1 = new FilteredElementCollector(doc) .OfClass(typeof(Level)) .Cast\u003cLevel\u003e() .FirstOrDefault(l =\u003e l.Name == \"Level 1\"); var levelId = level1?.Id; // Option 2: Get all levels and pick one var allLevels = new FilteredElementCollector(doc) .OfClass(typeof(Level)) .ToElements(); var levelId = allLevels.First().Id; Complete Working Example 7 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // Step 1: Get the level we want var targetLevel = new FilteredElementCollector(doc) .OfClass(typeof(Level)) .Cast\u003cLevel\u003e() .FirstOrDefault(l =\u003e l.Name == \"Level 1\"); if (targetLevel != null) { // Step 2: Get all doors on that level var level1Doors = new FilteredElementCollector(doc) .OfCategory(BuiltInCategory.OST_Doors) .WhereElementIsNotElementType() .WherePasses(new ElementLevelFilter(targetLevel.Id)) .ToElements(); // Now you have only doors that exist on Level 1 } Other Common Custom Filters ElementClassFilter (alternative to .OfClass()):\n1 .WherePasses(new ElementClassFilter(typeof(Wall))) ElementCategoryFilter (alternative to .OfCategory()):\n1 .WherePasses(new ElementCategoryFilter(BuiltInCategory.OST_Walls)) LogicalAndFilter (combine multiple filters with AND):\n1 2 3 4 5 6 7 8 var filter1 = new ElementLevelFilter(levelId); var filter2 = new ElementCategoryFilter(BuiltInCategory.OST_Doors); var combinedFilter = new LogicalAndFilter(filter1, filter2); var result = new FilteredElementCollector(doc) .WhereElementIsNotElementType() .WherePasses(combinedFilter) .ToElements(); LogicalOrFilter (combine multiple filters with OR):\n1 2 3 4 5 6 7 8 var doorsFilter = new ElementCategoryFilter(BuiltInCategory.OST_Doors); var windowsFilter = new ElementCategoryFilter(BuiltInCategory.OST_Windows); var doorsOrWindows = new LogicalOrFilter(doorsFilter, windowsFilter); var result = new FilteredElementCollector(doc) .WhereElementIsNotElementType() .WherePasses(doorsOrWindows) .ToElements(); When to Use .WherePasses() Use .WherePasses() when:\nBuilt-in methods (.OfClass(), .OfCategory()) aren’t specific enough You need to filter by level, view, or other specific properties You need to combine multiple filter conditions You’re working with complex filtering logic Stick with built-in methods when:\nSimple category or class filtering is sufficient You want cleaner, more readable code Performance Tip Apply the most restrictive filters first, then use .WherePasses() for fine-tuning:\n1 2 3 4 5 6 7 8 9 10 11 12 // Good: Filter by category first, then by level var efficientQuery = new FilteredElementCollector(doc) .OfCategory(BuiltInCategory.OST_Doors) // Narrow down first .WhereElementIsNotElementType() .WherePasses(new ElementLevelFilter(levelId)) // Fine-tune .ToElements(); // Less efficient: Custom filter on everything var lessEfficientQuery = new FilteredElementCollector(doc) .WherePasses(new ElementLevelFilter(levelId)) // Filter everything first .OfCategory(BuiltInCategory.OST_Doors) // Then narrow down .ToElements(); Formatting for Readability When chaining gets long, format it vertically for better readability:\n1 2 3 4 5 6 7 8 9 10 // Good formatting - easy to read var elements = new FilteredElementCollector(doc) .OfClass(typeof(Wall)) .OfCategory(BuiltInCategory.OST_Walls) .WhereElementIsNotElementType() .WherePasses(someFilter) .ToElements(); // Bad formatting - hard to read var elements = new FilteredElementCollector(doc).OfClass(typeof(Wall)).OfCategory(BuiltInCategory.OST_Walls).WhereElementIsNotElementType().WherePasses(someFilter).ToElements(); Benefits of Method Chaining Concise Code: Less lines, more readable Fluent Interface: Reads almost like natural language Performance: Can be more efficient (no intermediate variables) Less Variables: No need to store intermediate results Common Patterns Pattern 1: Filter → Refine → Collect 1 2 3 4 var result = new FilteredElementCollector(doc) .OfClass(typeof(SomeClass)) // Filter by class .WhereElementIsNotElementType() // Refine selection .ToElements(); // Collect results Pattern 2: Category → Type → Custom Filter 1 2 3 4 5 var result = new FilteredElementCollector(doc) .OfCategory(BuiltInCategory.OST_Walls) // Filter by category .WhereElementIsNotElementType() // Exclude types .WherePasses(customFilter) // Apply custom filter .ToElements(); // Collect results Pattern 3: Count Elements 1 2 3 4 var count = new FilteredElementCollector(doc) .OfClass(typeof(Wall)) .WhereElementIsNotElementType() .GetElementCount(); // Just get the count, not the elements Important Notes Order Matters: Apply the most restrictive filters first for better performance Semicolon: Don’t forget the ; at the end of the statement Line Breaks: You can break lines anywhere in the chain for readability Return Types: Make sure each method returns something the next method can work with Practice Exercise Try converting this non-chained code to use method chaining:\n1 2 3 4 5 6 7 8 // Convert this: var collector = new FilteredElementCollector(doc); collector = collector.OfCategory(BuiltInCategory.OST_Doors); collector = collector.WhereElementIsNotElementType(); var doorElements = collector.ToElements(); // To this format: var doorElements = // Your chained solution here Solution:\n1 2 3 4 var doorElements = new FilteredElementCollector(doc) .OfCategory(BuiltInCategory.OST_Doors) .WhereElementIsNotElementType() .ToElements(); Method chaining makes your Revit add-in code cleaner and more professional!\nQuick, Slow and LINQ Element Filtering Introduction When working with the Revit API, efficient element filtering is crucial for performance. Understanding the differences between quick filters, slow filters, and LINQ approaches can mean the difference between a tool that runs in milliseconds versus one that takes several seconds to minutes, if not hours. This comprehensive guide explores these filtering methods, their performance characteristics, and best practices for optimal results.\nThe Performance Hierarchy: Critical for Understanding Based on extensive benchmarking by Jeremy Tammik (The Building Coder) and other Revit API developers, there’s a clear performance hierarchy you must understand:\nThe Golden Rule: Revit’s built-in filters are at least twice as fast as LINQ-based filtering.\nPerformance Rankings from Real Benchmarks From actual performance tests on retrieving specific elements:\n1 2 3 4 Quick Filters: Baseline performance (100%) Slow Filters: ~116% of quick filter time (still very efficient) LINQ Queries: ~128-153% of quick filter time Manual .NET Iteration: ~153%+ of quick filter time Understanding Revit’s Data Architecture To grasp why these performance differences exist, you need to understand how Revit stores element data:\nElement Storage Structure Revit divides element storage into two parts:\nElement Header (Record): Contains minimal information\nElement ID Name Category ID Type ID Basic properties accessible without loading full element Element Body: Contains complete element data\nGeometry Parameters Detailed properties Relationships This architecture explains why quick filters are so fast—they operate only on the header data that’s always in memory, while slow filters may need to load the complete element information.\nWhy quick filters matter Revit stores only a small “header” for each element in memory until more details are needed. A quick filter can test an element using this header, so Revit can decide whether the element passes without loading the full element data. This makes quick filters very efficient. In contrast, slow filters need the full element, so Revit must load and “expand” each element first.\nWhen you use .NET or LINQ to filter, you force Revit to marshal each element’s data into managed memory, so every element is fully expanded before your query runs. Even if the filter is simple, this marshalling is expensive and can double the execution time. Benchmarking on the Building Coder blog showed that explicit iteration or LINQ is over a thousand times slower than built‑in collector filtering.\nEfficiency guidelines Use quick filters first. Because they operate on element headers, quick filters can discard most elements immediately .\nApply slow filters next. Use them only when necessary to narrow the set further .\nAvoid .NET/LINQ until the end. Only when no built‑in filter can express the condition should you post‑process the results using LINQ .\nBuilt‑in filter types Logical filters Logical filters let you combine other filters:\nFilter Description LogicalAndFilter Combines two or more filters; an element must pass all of them. You can also call WherePasses on the collector to add another filter or IntersectWith to intersect two independent collector results . LogicalOrFilter Combines filters so an element only needs to pass one of them. You can use UnionWith on two collectors to achieve the same result . Quick filters Quick filters use the element header and therefore have corresponding “shortcut” methods on FilteredElementCollector. Using the shortcut makes it obvious you are applying a quick filter. For example, OfClass(typeof(Wall)) calls an ElementClassFilter internally. The table below summarizes common quick filters .\nFilter class Shortcut ElementCategoryFilter OfCategoryId ElementClassFilter OfClass ElementIsElementTypeFilter WhereElementIsElementType / WhereElementIsNotElementType ElementOwnerViewFilter OwnedByView / WhereElementIsViewIndependent ElementDesignOptionFilter ContainedInDesignOption ElementIsCurveDrivenFilter WhereElementIsCurveDriven ElementStructuralTypeFilter — FamilySymbolFilter — ExclusionFilter Excluding BoundingBoxIntersectsFilter — BoundingBoxIsInsideFilter — BoundingBoxContainsPointFilter — Slow filters Slow filters have no shortcut because they need to load each element. They are still implemented in native code and therefore faster than .NET post‑processing, but you should try to reduce their use by narrowing the collector first with quick filters. Common slow filters include:\nClass Description FamilyInstanceFilter Returns instances of a specific family symbol. ElementLevelFilter Elements associated with a given level ID. ElementParameterFilter Tests whether an element has a parameter or matches a value/range. PrimaryDesignOptionMemberFilter Returns elements belonging to the primary design option. StructuralInstanceUsageFilter Filters family instances by structural usage. StructuralWallUsageFilter Filters walls by structural usage. StructuralMaterialTypeFilter Filters walls by structural usage. RoomFilter, SpaceFilter, AreaFilter, tag filters Finds rooms, spaces or areas and their tags. CurveElementFilter Filters specific curve elements (model curves, detail lines, symbolic curves, etc.). LINQ and .NET post‑processing LINQ queries or explicit loops over the FilteredElementCollector run in managed code. When you use them, Revit has already marshalled each element from its internal database into your add‑in’s memory. This marshalling costs far more than the filtering itself. In the original benchmark, Jeremy Tammik measured several ways of retrieving levels. The results showed that converting the collector results to a generic list (ToList) or using LINQ produced thousands of times more overhead than simply applying Revit filters. There was hardly any difference between writing a manual foreach loop and using a LINQ query—both were similarly slow compared with a native filter.\nHowever, LINQ makes collecting and filtering elements much easier than SlowFilters J.Tamik estimated them to be twice as slow, however, Gavin Crump rarely noticed their impact on performance. LINQ is provided through the System library and are not specific to the RevitAPI. Look at them like a quick iterations across all items in a list. Lambda Function The Lambda shorthand is crucial to understand. Lambda function acts as a throwaway function that is evaluated, then disposed of. The =\u003e symbols are used to imply a lambda function, where the left side is the variable to evaluate upon and the right side is the function to evaluate the outcome. 1 Variable =\u003e Function; FilteredELementCollector vs System LINQ\nWhen using LINQ methods with a filtered element collector, you should use all required Revit API methods before switching over to using LINQ Methods. Common pattern to follow:\nMake a FilteredElementCollector Filter by .OfClass or .OfCategory Switch to LINQ Method ToList() When dealing with a FilteredElementCollectors, generally you would finish the collector in the Revit API with a closer such as ToElement(), which would return an IList of Elements. We finish a chain of LINQ methods in most cases by using the ToList() method. Cast() When we Cast in C# - we are changing the type of an object. This is very important when dealing with the Element class, as many things may inherit from it. For example:\nif we collect all sheets in the model, they are still Element type. If we wanted to ask for a property unique to the ViewSheet class (e.g. SheetNumber), we would need to Cast those Elements to ViewSheet first. When you work with the FilteredElementCollector you are using Elements by default, if we wanted to switch over to Sheets after collecting Sheets, the FiliteredElementCollector won’t give you back objects of the Sheet Type, so you have to actually Cast the Object to the Sheet type when you are ready to deal with it as Sheets\nDistinct() If we have a list of objects where we know there may be duplicates that we don’t want, we can add this method to remove all duplicate objects. For example, maybe we want to know all values of a given parameter for a nominated class, we do not need to know every occurrence of of duplicate values, just that they have occurred, so we can make it distinct before finishing our list. Select(x =\u003e function) The select() method will evaluate a lambdafunction for all objects in the current list we are working with, Note that this may change the type of object being stored in the list, For example, if we get the parameter values of elements, we will no longer be dealing with those elements. OrderBy(x =\u003e function) Typically, elements are returned to us by collectors in the order by which they were originally added to the Revit Document (DB). If we want to reorder them, we can use a lambda function that yields a sortable outcome (typically, must be numeric or alphanumeric in nature). The original elements will be kept, but now in a sorted order. Where(x =\u003e function) This is effectively the LINQ equivalent to WherePasses(), The lambda function must evaluate to a true or false outcome, where all elements that evaluate as false will be filtered out of the available elements provided before. An example of this being used is: omitting all placeholder sheets when collecting Sheets. Equivalent to List.FiltByBoolMask Node in Dynamo.\nExample №1: Comparing Quick and Slow Methods Method Chaining for Quick + LINQ Style 1 2 3 4 5 6 var sheets = new FilteredElementCollector(doc) .OfClass(typeof(ViewSheet)) .Cast\u003cViewSheet\u003e() .Where(s=\u003es.IsPlaceholder==false) // Where the sheet is not a placeholder .OrderBy(s=\u003es.SheetNumber) // Order based on Sheet Number .ToList(); // Cast them into a list Execution: Runs mostly in .NET after elements are marshalled from Revit. Strength: Very concise and readable. Weakness: Potentially slower for large datasets since all elements come into memory first. VS.\nSlow WherePasses() Method 1 2 3 4 5 6 7 8 9 10 11 // Build a parameter rule: IsPlaceholder == 0 (false) var rule = ParameterFilterRuleFactory.CreateEqualsRule( new ElementId(BuiltInParameter.VIEWER_SHEET_IS_PLACEHOLDER), 0); var notPlaceholderFilter = new ElementParameterFilter(rule); var sheets = new FilteredElementCollector(doc) .OfClass(typeof(ViewSheet)) .WherePasses(notPlaceholderFilter) // Revit-side filter .Cast\u003cViewSheet\u003e() .OrderBy(s =\u003e s.SheetNumber) // .NET-side sort .ToList(); Execution: Filtering happens inside Revit’s engine before elements are marshalled. Strength: More scalable for large datasets, avoids bringing all elements into .NET first. Weakness: More verbose; less intuitive to read/write than LINQ. Example №2: Comparing Quick and Slow Methods Method Chaining for Quick + LINQ Style 1 2 3 4 5 6 7 8 9 10 11 12 var shortWalls = new FilteredElementCollector(doc) .OfCategory(BuiltInCategory.OST_Walls) .WhereElementIsNotElementType() .Cast\u003cWall\u003e() .Where(w =\u003e { var p = w.get_Parameter(BuiltInParameter.WALL_USER_HEIGHT_PARAM); return p != null \u0026\u0026 p.StorageType == StorageType.Double \u0026\u0026 p.AsDouble() \u003c 12.0; }) // .NET-side filter .ToList(); TaskDialog.Show(doc.Title, $\"We have {shortWalls.Count} walls \u003c 12 ft.\"); VS.\nSlow WherePasses() Method 1 2 3 4 5 6 7 8 9 10 11 var parameterId = new ElementId(BuiltInParameter.WALL_USER_HEIGHT_PARAM); var heightRule = ParameterFilterRuleFactory.CreateLessRule(parameterId, 12.0, 0.1); var heightFilter = new ElementParameterFilter(heightRule); var shortWalls = new FilteredElementCollector(doc) .OfCategory(BuiltInCategory.OST_Walls) .WhereElementIsNotElementType() .WherePasses(heightFilter) // Revit-side filter .ToElements(); TaskDialog.Show(doc.Title, $\"We have {shortWalls.Count} walls \u003c 12 ft.\"); TL;DR: use WherePasses() when filtering by parameters on big sets (faster); use LINQ for quick scripts or when the set is already small. Sorting generally happens in LINQ after you’ve done the heavy lifting with native filters.\nParameter filters vs. LINQ when filtering by property values A common case is filtering by a parameter value (e.g., family name). Developers often write a LINQ query like:\n1 2 3 4 var result = collect .OfClass(typeof(FamilyInstance)) .Where(x =\u003e x.get_Parameter(BuiltInParameter.ELEM_FAMILY_PARAM) .AsValueString() == sectionName); Although this works, the query runs in .NET, so Revit marshals every FamilyInstance into memory first. Jeremy Tammik points out that this is even slower than a slow filter. Instead, you can turn the LINQ query into a parameter filter and let Revit perform the comparison natively. Implementing a parameter filter requires creating a ParameterValueProvider, a FilterRule (e.g., FilterStringRule or using ParameterFilterRuleFactory.CreateEqualsRule) and then applying an ElementParameterFilter.\nThe 2019 article Slow, Slower Still and Faster Filtering shows how to implement this. It provides two LINQ examples and two parameter filter examples for retrieving a family symbol by name;\nThe parameter filter versions avoid marshalling and are an order of magnitude faster. The lesson is: when filtering on parameter values, always try to use ElementParameterFilter instead of LINQ. Collector optimization tips Jeremy Tammik also provides general optimization tips in his FindElement and Collector Optimisation post. Key points include:\nAvoid language‑dependent names. Wherever possible, identify elements by ID, category or type rather than name .\nUse parameter filters instead of LINQ. Replacing a LINQ query with a parameter filter often halves execution time because marshalling to .NET is eliminated .\nAvoid unnecessary conversions. A FilteredElementCollector already implements IEnumerable, so there is usually no need to convert it to IEnumerable or IList . Instantiating additional lists duplicates data and slows performance.\nUse the collector’s built‑in filters for categories and classes. For example, to find door family symbols you can chain:\n.OfCategory(BuiltInCategory.OST_Doors).OfClass(typeof(FamilySymbol)) and then iterate over the collector directly. This is shorter and faster than iterating over all family symbols and checking their category names. 1 2 3 4 5 6 7 8 9 10 // Get all Door family symbols directly FilteredElementCollector collector = new FilteredElementCollector(doc) .OfCategory(BuiltInCategory.OST_Doors) .OfClass(typeof(FamilySymbol)); foreach (FamilySymbol doorSymbol in collector) { // Do something with each door symbol TaskDialog.Show(\"Door Symbol\", doorSymbol.Name); } Why this is better Shorter: No need to fetch all family symbols first and then check their categories manually.\nFaster: Filtering happens natively inside Revit before elements are wrapped into .NET objects, so you avoid the overhead of LINQ or extra if conditions in C#.\nIf you wanted to collect instances instead of symbols, you’d just swap FamilySymbol for FamilyInstance in the loop:\n1 2 3 4 foreach (FamilyInstance doorInstance in collector) { // Work with each door instance } 1) Fast (native filters, iterate collector directly) 1 2 3 4 5 6 7 8 9 // Fast: everything done natively inside Revit before .NET sees it var symbols = new FilteredElementCollector(doc) .OfCategory(BuiltInCategory.OST_Doors) .OfClass(typeof(FamilySymbol)); foreach (FamilySymbol sym in symbols) { // use sym } 2) Fast (native + parameter filter for a specific name) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // Fast and precise: still native, avoids LINQ post-processing var doorName = \"Single-Flush\"; var byName = new FilteredElementCollector(doc) .OfCategory(BuiltInCategory.OST_Doors) .OfClass(typeof(FamilySymbol)) .WherePasses( new ElementParameterFilter( ParameterFilterRuleFactory.CreateEqualsRule( new ElementId(BuiltInParameter.SYMBOL_NAME_PARAM), doorName, /* caseSensitive */ true))); foreach (FamilySymbol sym in byName) { // use sym } 3) Slower (native filter + LINQ post-processing) 1 2 3 4 5 6 7 8 9 10 // Slower: brings elements into .NET and then filters with LINQ var withLinq = new FilteredElementCollector(doc) .OfCategory(BuiltInCategory.OST_Doors) .OfClass(typeof(FamilySymbol)) .Where(x =\u003e x.Name == \"Single-Flush\"); // LINQ post-filter foreach (FamilySymbol sym in withLinq) { // use sym } 4) Slowest (no native category filter, LINQ checks everything) 1 2 3 4 5 6 7 8 9 10 11 12 13 // Slowest: iterates all symbols, checks category/name in managed code var allSymbols = new FilteredElementCollector(doc) .OfClass(typeof(FamilySymbol)); foreach (FamilySymbol sym in allSymbols) { var cat = sym.Category; if (cat != null \u0026\u0026 cat.Id.IntegerValue == (int)BuiltInCategory.OST_Doors \u0026\u0026 sym.Name == \"Single-Flush\") { // use sym } } Why #1 and #2 win Revit filters run in native code and trim the search set before elements are marshalled into .NET. LINQ (and manual if checks) happen after marshaling—extra overhead you don’t want unless you must. Quick micro-benchmark scaffolding (optional for demos) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 using System.Diagnostics; static TimeSpan TimeIt(Action action) { var sw = Stopwatch.StartNew(); action(); sw.Stop(); return sw.Elapsed; } // Example use: var tFast = TimeIt(() =\u003e { foreach (FamilySymbol _ in new FilteredElementCollector(doc) .OfCategory(BuiltInCategory.OST_Doors) .OfClass(typeof(FamilySymbol))) { } }); var tLinq = TimeIt(() =\u003e { foreach (FamilySymbol _ in new FilteredElementCollector(doc) .OfCategory(BuiltInCategory.OST_Doors) .OfClass(typeof(FamilySymbol)) .Where(x =\u003e x.Name == \"Single-Flush\")) { } }); // Show results TaskDialog.Show(\"Timing\", $\"Native: {tFast.TotalMilliseconds:F1} ms\\nLINQ: {tLinq.TotalMilliseconds:F1} ms\"); Practical tips Prefer .WherePasses(new ElementParameterFilter(...)) to check parameter values; avoid AsValueString() for comparisons—use AsString() (for text) or typed getters (AsInteger(), etc.).\nChain quick filters first (OfCategory, OfClass, WhereElementIsNotElementType).\nAdd slow filters only when needed (e.g., ElementParameterFilter, ElementLevelFilter).\nIterate the collector directly; don’t call .ToElements() / .ToList() unless you truly need a materialized list.\nIf you’ll delete/modify elements found, capture IDs first and dispose the collector:\n1 2 3 4 var ids = new FilteredElementCollector(doc) .OfCategory(BuiltInCategory.OST_Doors) .ToElementIds(); // collector eligible for GC now; safe to delete in a loop over ids Following these guidelines will yield dramatic performance improvements when writing Revit add‑ins. Even though the original blog post dates from 2015, later posts and benchmarks confirm that using Revit’s native filtering API—quick or slow—always beats LINQ or explicit iteration in both simplicity and speed. By designing your search around built‑in filters and using parameter filters for value comparisons, you can make your tools scale to very large projects.\nCollector methods and Extensions When developing common collectors that you will use in many commands or just generally, you should develop methods that can be called-on versus writing the full collector each time. Given collectors always begin from a Document, is also makes sense to develop these methods as Extension Methods for the Document class versus containing them in a static class. Overloading Methods (Polymorphism) We can also provide multiple argument structures for methods with the same name: 1 2 doc.Ext_Collector(); // Which provides FilteredElementCollector() doc.Ext_Collector(view); // Which provides another collector that we built Can co-exist side-by-side as extension methods. Homework №1 Create a basic wall collector Create a WherePasses() condition Test your code Solution Project Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Solution |-\u003e guRoo |-\u003e Dependencies |-\u003e Commands |-\u003e General |-\u003e Cmds_PushButton.cs # Rename \u0026 Update |-\u003e Cmds_PullDown.cs |-\u003e Cmds_Stack1.cs |-\u003e Cmds_Stack2.cs |-\u003e Cmds_Stack3.cs |-\u003e Forms |-\u003e General |-\u003e Extensions |-\u003e Resources |-\u003e Utilities |-\u003e Application.cs |-\u003e guRoo.addin Cmds_PushButton.cs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 // Autodesk using Autodesk.Revit.Attributes; using Autodesk.Revit.UI; // Associate with PushButton Commands namespace guRoo.Cmds_PushButton { /// ///\tExample Command /// [Transaction(TransactionMode.Manual)] public class Cmd_Test : IExternalCommand { public Result Execute(ExternalCommandData CommandData, ref string message, ElementSet elements) { // Collect the Document and Application objects from the CommandData var uiApp = CommandData.Application; var uiDoc = uiApp.ActiveUIDocument; var doc = uiDoc.Document; // Collect all walls var walls = new FilteredElementCollector(doc) .OfClass(typeof(Wall)) .WhereElementIsNotElementType() .ToElements(); // Show the message dialog with the document title TaskDialog.Show( doc.Title, $\"We have {walls.Count} walls in the model\"); // Collect all walls lower than 12 feet // First: Construct a filter for .WherePasses() Method var parameterId = new ElementId(BuiltInParameter.WALL_USER_HEIGHT_PARAM); var provider = new ParameterValueProvider(parameterId); var rule = new FilterNumericLess(); var passesRule = new FilterDoubleRule(provider, rule, 12, 0.1); var paramFilter = new ElementParameterFilter(passesRule); // Then: Apply the filter to the FilteredElementCollector var wallsFiltered = new FilteredElementCollector(doc) .OfCategory(BuiltInCategory.OST_Walls) .WhereElementIsNotElementType() .WherePasses(paramFilter) .ToElements(); // Show the message dialog with the document title TaskDialog.Show(doc.Title, $\"We have {wallsFiltered.Count} walls less than 12 feet in the model\"); // Final return here: return Result.Succeeded; } } } Homework №2 Create a Document extension class Create basic collector method Create a sheet collector Cerate a revision collector Solution Project Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 Solution |-\u003e guRoo |-\u003e Dependencies |-\u003e Commands |-\u003e General |-\u003e Cmds_PushButton.cs # Update to implement new ext .cs |-\u003e Forms |-\u003e General |-\u003e Extensions |-\u003e Document_Ext.cs # Create a new extension class |-\u003e Resources |-\u003e Utilities |-\u003e Application.cs |-\u003e guRoo.addin Document_Ext.cs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace guRoo.Extensions { public static class Document_Ext { /// /// /// /// /// public static FilteredElementCollector Ext_Collector(this Document doc) { return new FilteredElementCollector(doc); } /// /// Construct a new FilteredElementCollector /// /// The document (extended) /// The view to collect elements from /// public static FilteredElementCollector Ext_Collector(this Document doc, View view) { return new FilteredElementCollector(doc, view.Id); } /// /// Collecting sheets /// /// /// /// /// public static List\u003cViewSheet\u003e Ext_GetSheets(this Document doc, bool sorted true, bool includePlaceholder = false) { // Collect our sheets var sheets = doc.Ext_Collector() .OfClass(typeof(ViewSheet)) .Cast\u003cViewSheet\u003e() .ToList(); // Fileter out placeholders if desired if (!includePlaceholders) { sheets = sheets .Where(s =\u003e !s.IsPlaceholder) // is the sheet is placeholder, reverse it (if the sheet is not a placeholder, the lambda would return \"true\". and non-placeholder sheets would \"continue\" forward) .ToList(); } // Return elements, optional sorting if (sorted) { return sheets .OrderBy(s =\u003e s.SheetNumber) .ToList(); } else { return sheets; } } /// /// Collecting revisions /// /// /// /// /// public static List\u003cRevisions\u003e Ext_GetRevisions(this Document doc, bool sorted true) { // Collect our revisions var revisions = doc.Ext_Collector() .OfClass(typeof(Revision)) .Cast\u003cRevision\u003e() .ToList(); // Return elements, optional sorting if (sorted) { return revisions .OrderBy(r =\u003e r.SequenceNumber) // this is an element property that's accessible through Casting only, if we didn't Cast earlier we wouldn't have access to Revision propeties. .ToList(); } else { return revisions; } } } } Cmds_Button.cs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 // Autodesk using Autodesk.Revit.Attributes; using Autodesk.Revit.UI; // Associate with PushButton Commands namespace guRoo.Commands.General { /// ///\tExample Command /// [Transaction(TransactionMode.Manual)] public class Cmd_Test : IExternalCommand { public Result Execute(ExternalCommandData CommandData, ref string message, ElementSet elements) { // Collect the Document and Application objects from the CommandData var uiApp = CommandData.Application; var uiDoc = uiApp.ActiveUIDocument; var doc = uiDoc.Document; // Collect all walls var walls = new FilteredElementCollector(doc) .OfClass(typeof(Wall)) .WhereElementIsNotElementType() .ToElements(); // Show the message dialog with the document title TaskDialog.Show( doc.Title, $\"We have {walls.Count} walls in the model\"); // Collect all walls lower than 12 feet // First: Construct a filter for .WherePasses() Method var parameterId = new ElementId(BuiltInParameter.WALL_USER_HEIGHT_PARAM); var provider = new ParameterValueProvider(parameterId); var rule = new FilterNumericLess(); var passesRule = new FilterDoubleRule(provider, rule, 12, 0.1); var paramFilter = new ElementParameterFilter(passesRule); // Then: Apply the filter to the FilteredElementCollector var wallsFiltered = new FilteredElementCollector(doc) .OfCategory(BuiltInCategory.OST_Walls) .WhereElementIsNotElementType() .WherePasses(paramFilter) .ToElements(); // Show the message dialog with the document title TaskDialog.Show(doc.Title, $\"We have {wallsFiltered.Count} walls less than 12 ft in the model\"); // Collect all sheets var sheets = doc.Ext_GetSheets(); // declare an argument if you need \"(includePlaceholders: true)\" var revisions = doc.Ext_GetRevisions(); TaskDialog,Show(doc.Title, $\"We have {sheets.Count} sheets in the model\");) TaskDialog,Show(doc.Title, $\"We have {revisions.Count} revisions in the model\");) // Final return here: return Result.Succeeded; } } } These tutorials were inspired by the work of Aussie BIM Guru. If you’re looking for a deeper dive into the topics, check out his channel for detailed explanations.\n",
  "wordCount" : "6902",
  "inLanguage": "en",
  "image":"http://localhost:1313/images/Pasted%20image%2020250902210047.png","datePublished": "2025-08-15T10:37:24+03:00",
  "dateModified": "2025-08-15T10:37:24+03:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/posts/lesson-12/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Blog (Alt + H)">Blog</a>
        </div>

        
        <div class="logo main-logo">
            <a href="https://aydrafting.com" target="_blank">
                <img src="/LogoAYD.png" alt="Blog" height="40">
            </a>
        </div>

        
        <div class="logo-switches">
            <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                    fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                    stroke-linejoin="round">
                    <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                </svg>
                <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                    fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                    stroke-linejoin="round">
                    <circle cx="12" cy="12" r="5"></circle>
                    <line x1="12" y1="1" x2="12" y2="3"></line>
                    <line x1="12" y1="21" x2="12" y2="23"></line>
                    <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                    <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                    <line x1="1" y1="12" x2="3" y2="12"></line>
                    <line x1="21" y1="12" x2="23" y2="12"></line>
                    <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                    <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                </svg>
            </button>
        </div>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      C# &#43; Revit API: Lesson 12 - FilteredElementCollector
      <span class="entry-hint" title="Draft">
        <svg xmlns="http://www.w3.org/2000/svg" height="35" viewBox="0 -960 960 960" fill="currentColor">
          <path
            d="M160-410v-60h300v60H160Zm0-165v-60h470v60H160Zm0-165v-60h470v60H160Zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22q0 11-4.5 22.5T862.09-380L643-160H520Zm300-263-37-37 37 37ZM580-220h38l121-122-18-19-19-18-122 121v38Zm141-141-19-18 37 37-18-19Z" />
        </svg>
      </span>
    </h1>
    <div class="post-meta"><span title='2025-08-15 10:37:24 +0300 MSK'>August 15, 2025</span>&nbsp;·&nbsp;33 min&nbsp;|&nbsp;<a href="mailto:%20aydimir@aydrafting.com" rel="noopener noreferrer edit" target="_blank">Suggest Changes</a>

</div>
  </header> 
<figure class="entry-cover">
        <img loading="eager" src="http://localhost:1313/images/Pasted%20image%2020250902210047.png" alt="Create a Pulldown Button">
        
</figure><div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#goal" aria-label="Goal">Goal</a><ul>
                        
                <li>
                    <a href="#to-explore-everything-there-is-to-know-about" aria-label="To explore everything there is to know about:">To explore everything there is to know about:</a></li>
                <li>
                    <a href="#filteredelementcollector" aria-label="FilteredElementCollector">FilteredElementCollector</a><ul>
                        
                <li>
                    <a href="#declaring-a-collector" aria-label="Declaring a Collector">Declaring a Collector</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#revit-api" aria-label="Revit API">Revit API</a><ul>
                        <ul>
                        
                <li>
                    <a href="#filteredelementcollector-constructors" aria-label="FilteredElementCollector Constructors">FilteredElementCollector Constructors</a></li>
                <li>
                    <a href="#filteredelementcollector-methods" aria-label="FilteredElementCollector Methods">FilteredElementCollector Methods</a></li></ul>
                    </ul>
                </li>
                <li>
                    <a href="#method-chaining-in-c" aria-label="Method Chaining in C#">Method Chaining in C#</a><ul>
                        
                <li>
                    <a href="#what-is-method-chaining" aria-label="What is Method Chaining?">What is Method Chaining?</a></li>
                <li>
                    <a href="#basic-concept" aria-label="Basic Concept">Basic Concept</a></li>
                <li>
                    <a href="#how-method-chaining-works" aria-label="How Method Chaining Works">How Method Chaining Works</a></li>
                <li>
                    <a href="#understanding-ofclass-vs-ofcategory" aria-label="Understanding .OfClass vs .OfCategory">Understanding .OfClass vs .OfCategory</a><ul>
                        
                <li>
                    <a href="#ofclass---filters-by-c-class-type" aria-label=".OfClass() - Filters by C# Class Type">.OfClass() - Filters by C# Class Type</a></li>
                <li>
                    <a href="#ofcategory---filters-by-revit-category" aria-label=".OfCategory() - Filters by Revit Category">.OfCategory() - Filters by Revit Category</a></li>
                <li>
                    <a href="#key-insight-familyinstance-class" aria-label="Key Insight: FamilyInstance Class">Key Insight: FamilyInstance Class</a></li>
                <li>
                    <a href="#when-to-use-which" aria-label="When to Use Which?">When to Use Which?</a></li></ul>
                </li>
                <li>
                    <a href="#understanding-builtincategory-and-alternatives" aria-label="Understanding BuiltInCategory and Alternatives">Understanding BuiltInCategory and Alternatives</a><ul>
                        
                <li>
                    <a href="#what-is-builtincategory" aria-label="What is BuiltInCategory?">What is BuiltInCategory?</a></li>
                <li>
                    <a href="#why-use-builtincategory-recommended-approach" aria-label="Why Use BuiltInCategory? (Recommended Approach)">Why Use BuiltInCategory? (Recommended Approach)</a></li>
                <li>
                    <a href="#alternative-1-using-category-objects" aria-label="Alternative 1: Using Category Objects">Alternative 1: Using Category Objects</a></li>
                <li>
                    <a href="#alternative-2-using-category-names-not-recommended" aria-label="Alternative 2: Using Category Names (Not Recommended)">Alternative 2: Using Category Names (Not Recommended)</a></li>
                <li>
                    <a href="#alternative-3-converting-between-approaches" aria-label="Alternative 3: Converting Between Approaches">Alternative 3: Converting Between Approaches</a></li>
                <li>
                    <a href="#practical-example-user-defined-categories" aria-label="Practical Example: User-Defined Categories">Practical Example: User-Defined Categories</a></li>
                <li>
                    <a href="#best-practice-summary" aria-label="Best Practice Summary">Best Practice Summary</a></li>
                <li>
                    <a href="#common-builtincategory-values" aria-label="Common BuiltInCategory Values">Common BuiltInCategory Values</a></li></ul>
                </li>
                <li>
                    <a href="#filteredelementcollector-examples" aria-label="FilteredElementCollector Examples">FilteredElementCollector Examples</a><ul>
                        
                <li>
                    <a href="#example-1-get-all-walls-class-based" aria-label="Example 1: Get All Walls (Class-based)">Example 1: Get All Walls (Class-based)</a></li>
                <li>
                    <a href="#example-2-get-windows-category-based---more-common" aria-label="Example 2: Get Windows (Category-based - More Common)">Example 2: Get Windows (Category-based - More Common)</a></li>
                <li>
                    <a href="#example-3-get-windows-belt--suspenders-approach" aria-label="Example 3: Get Windows (Belt &amp; Suspenders Approach)">Example 3: Get Windows (Belt &amp; Suspenders Approach)</a></li>
                <li>
                    <a href="#example-4-get-all-family-instances-any-category" aria-label="Example 4: Get ALL Family Instances (Any Category)">Example 4: Get ALL Family Instances (Any Category)</a></li></ul>
                </li>
                <li>
                    <a href="#understanding-whereelementisnotelementtype" aria-label="Understanding .WhereElementIsNotElementType()">Understanding .WhereElementIsNotElementType()</a><ul>
                        
                <li>
                    <a href="#element-types-vs-element-instances" aria-label="Element Types vs Element Instances">Element Types vs Element Instances</a></li>
                <li>
                    <a href="#the-methods" aria-label="The Methods">The Methods</a></li>
                <li>
                    <a href="#why-this-matters" aria-label="Why This Matters">Why This Matters</a></li>
                <li>
                    <a href="#common-use-cases" aria-label="Common Use Cases">Common Use Cases</a></li>
                <li>
                    <a href="#pro-tip-some-classes-are-always-types" aria-label="Pro Tip: Some Classes Are Always Types">Pro Tip: Some Classes Are Always Types</a></li>
                <li>
                    <a href="#memory-aid" aria-label="Memory Aid">Memory Aid</a></li>
                <li>
                    <a href="#example-5-to-get-all-elements-visible-in-a-specific-view" aria-label="Example 5: To Get All Elements Visible in a Specific View">Example 5: To Get All Elements Visible in a Specific View</a></li></ul>
                </li>
                <li>
                    <a href="#custom-filters" aria-label="Custom Filters">Custom Filters</a><ul>
                        
                <li>
                    <a href="#understanding-wherepasses-and-custom-filters" aria-label="Understanding .WherePasses() and Custom Filters">Understanding .WherePasses() and Custom Filters</a></li>
                <li>
                    <a href="#wherepasses-syntax" aria-label=".WherePasses() Syntax">.WherePasses() Syntax</a></li>
                <li>
                    <a href="#elementlevelfilter-example-6" aria-label="ElementLevelFilter Example 6">ElementLevelFilter Example 6</a></li>
                <li>
                    <a href="#complete-working-example-7" aria-label="Complete Working Example 7">Complete Working Example 7</a></li>
                <li>
                    <a href="#other-common-custom-filters" aria-label="Other Common Custom Filters">Other Common Custom Filters</a></li>
                <li>
                    <a href="#when-to-use-wherepasses" aria-label="When to Use .WherePasses()">When to Use .WherePasses()</a></li>
                <li>
                    <a href="#performance-tip" aria-label="Performance Tip">Performance Tip</a></li></ul>
                </li>
                <li>
                    <a href="#formatting-for-readability" aria-label="Formatting for Readability">Formatting for Readability</a></li>
                <li>
                    <a href="#benefits-of-method-chaining" aria-label="Benefits of Method Chaining">Benefits of Method Chaining</a></li>
                <li>
                    <a href="#common-patterns" aria-label="Common Patterns">Common Patterns</a><ul>
                        
                <li>
                    <a href="#pattern-1-filter--refine--collect" aria-label="Pattern 1: Filter → Refine → Collect">Pattern 1: Filter → Refine → Collect</a></li>
                <li>
                    <a href="#pattern-2-category--type--custom-filter" aria-label="Pattern 2: Category → Type → Custom Filter">Pattern 2: Category → Type → Custom Filter</a></li>
                <li>
                    <a href="#pattern-3-count-elements" aria-label="Pattern 3: Count Elements">Pattern 3: Count Elements</a></li></ul>
                </li>
                <li>
                    <a href="#important-notes" aria-label="Important Notes">Important Notes</a></li>
                <li>
                    <a href="#practice-exercise" aria-label="Practice Exercise">Practice Exercise</a></li></ul>
                </li>
                <li>
                    <a href="#quick-slow-and-linq-element-filtering" aria-label="Quick, Slow and LINQ Element Filtering">Quick, Slow and LINQ Element Filtering</a><ul>
                        
                <li>
                    <a href="#introduction" aria-label="Introduction">Introduction</a></li>
                <li>
                    <a href="#the-performance-hierarchy-critical-for-understanding" aria-label="The Performance Hierarchy: Critical for Understanding">The Performance Hierarchy: Critical for Understanding</a><ul>
                        
                <li>
                    <a href="#performance-rankings-from-real-benchmarks" aria-label="Performance Rankings from Real Benchmarks">Performance Rankings from Real Benchmarks</a></li></ul>
                </li>
                <li>
                    <a href="#understanding-revits-data-architecture" aria-label="Understanding Revit&rsquo;s Data Architecture">Understanding Revit&rsquo;s Data Architecture</a><ul>
                        
                <li>
                    <a href="#element-storage-structure" aria-label="Element Storage Structure">Element Storage Structure</a></li></ul>
                </li>
                <li>
                    <a href="#why-quick-filters-matter" aria-label="Why quick filters matter">Why quick filters matter</a><ul>
                        
                <li>
                    <a href="#efficiency-guidelines" aria-label="Efficiency guidelines">Efficiency guidelines</a></li></ul>
                </li>
                <li>
                    <a href="#builtin-filter-types" aria-label="Built‑in filter types">Built‑in filter types</a><ul>
                        
                <li>
                    <a href="#logical-filters" aria-label="Logical filters">Logical filters</a></li>
                <li>
                    <a href="#quick-filters" aria-label="Quick filters">Quick filters</a></li>
                <li>
                    <a href="#slow-filters" aria-label="Slow filters">Slow filters</a></li></ul>
                </li>
                <li>
                    <a href="#linq" aria-label="LINQ and .NET post‑processing">LINQ and .NET post‑processing</a><ul>
                        
                <li>
                    <a href="#however-linq-makes-collecting-and-filtering-elements-much-easier-than-slowfilters" aria-label="However, LINQ makes collecting and filtering elements much easier than SlowFilters">However, LINQ makes collecting and filtering elements much easier than SlowFilters</a></li></ul>
                </li>
                <li>
                    <a href="#lambda-function" aria-label="Lambda Function">Lambda Function</a><ul>
                        
                <li>
                    <a href="#tolist" aria-label="ToList()">ToList()</a></li>
                <li>
                    <a href="#casttype" aria-label="Cast&lt;type&gt;()">Cast&lt;type&gt;()</a></li>
                <li>
                    <a href="#distinct" aria-label="Distinct()">Distinct()</a></li>
                <li>
                    <a href="#selectx--function" aria-label="Select(x =&gt; function)">Select(x =&gt; function)</a></li>
                <li>
                    <a href="#orderbyx--function" aria-label="OrderBy(x =&gt; function)">OrderBy(x =&gt; function)</a></li>
                <li>
                    <a href="#wherex--function" aria-label="Where(x =&gt; function)">Where(x =&gt; function)</a></li></ul>
                </li>
                <li>
                    <a href="#example-1-comparing-quick-and-slow-methods" aria-label="Example №1: Comparing Quick and Slow Methods">Example №1: Comparing Quick and Slow Methods</a><ul>
                        
                <li>
                    <a href="#method-chaining-for-quick--linq-style" aria-label="Method Chaining for Quick &#43; LINQ Style">Method Chaining for Quick + LINQ Style</a></li>
                <li>
                    <a href="#slow-wherepasses-method" aria-label="Slow WherePasses() Method">Slow WherePasses() Method</a></li></ul>
                </li>
                <li>
                    <a href="#example-2-comparing-quick-and-slow-methods" aria-label="Example №2: Comparing Quick and Slow Methods">Example №2: Comparing Quick and Slow Methods</a><ul>
                        
                <li>
                    <a href="#method-chaining-for-quick--linq-style-1" aria-label="Method Chaining for Quick &#43; LINQ Style">Method Chaining for Quick + LINQ Style</a></li>
                <li>
                    <a href="#slow-wherepasses-method-1" aria-label="Slow WherePasses() Method">Slow WherePasses() Method</a></li></ul>
                </li>
                <li>
                    <a href="#parameter-filters-vs-linq-when-filtering-by-property-values" aria-label="Parameter filters vs. LINQ when filtering by property values">Parameter filters vs. LINQ when filtering by property values</a></li>
                <li>
                    <a href="#collector-optimization-tips" aria-label="Collector optimization tips">Collector optimization tips</a><ul>
                        
                <li>
                    <a href="#why-this-is-better" aria-label="Why this is better">Why this is better</a></li>
                <li>
                    <a href="#1-fast-native-filters-iterate-collector-directly" aria-label="1) Fast (native filters, iterate collector directly)">1) Fast (native filters, iterate collector directly)</a></li>
                <li>
                    <a href="#2-fast-native--parameter-filter-for-a-specific-name" aria-label="2) Fast (native &#43; parameter filter for a specific name)">2) Fast (native + parameter filter for a specific name)</a></li>
                <li>
                    <a href="#3-slower-native-filter--linq-post-processing" aria-label="3) Slower (native filter &#43; LINQ post-processing)">3) Slower (native filter + LINQ post-processing)</a></li>
                <li>
                    <a href="#4-slowest-no-native-category-filter-linq-checks-everything" aria-label="4) Slowest (no native category filter, LINQ checks everything)">4) Slowest (no native category filter, LINQ checks everything)</a></li></ul>
                </li>
                <li>
                    <a href="#why-1-and-2-win" aria-label="Why #1 and #2 win">Why #1 and #2 win</a></li>
                <li>
                    <a href="#quick-micro-benchmark-scaffolding-optional-for-demos" aria-label="Quick micro-benchmark scaffolding (optional for demos)">Quick micro-benchmark scaffolding (optional for demos)</a></li>
                <li>
                    <a href="#practical-tips" aria-label="Practical tips">Practical tips</a></li></ul>
                </li>
                <li>
                    <a href="#collector-methods-and-extensions" aria-label="Collector methods and Extensions">Collector methods and Extensions</a></li>
                <li>
                    <a href="#overloading-methods-polymorphism" aria-label="Overloading Methods (Polymorphism)">Overloading Methods (Polymorphism)</a></li>
                <li>
                    <a href="#homework-1" aria-label="Homework №1">Homework №1</a></li>
                <li>
                    <a href="#solution" aria-label="Solution">Solution</a><ul>
                        
                <li>
                    <a href="#project-solution" aria-label="Project Solution">Project Solution</a></li>
                <li>
                    <a href="#cmds_pushbuttoncs" aria-label="Cmds_PushButton.cs">Cmds_PushButton.cs</a></li></ul>
                </li>
                <li>
                    <a href="#homework-2" aria-label="Homework №2">Homework №2</a></li>
                <li>
                    <a href="#solution-1" aria-label="Solution">Solution</a><ul>
                        
                <li>
                    <a href="#project-solution-1" aria-label="Project Solution">Project Solution</a></li>
                <li>
                    <a href="#document_extcs" aria-label="Document_Ext.cs">Document_Ext.cs</a></li>
                <li>
                    <a href="#cmds_buttoncs" aria-label="Cmds_Button.cs">Cmds_Button.cs</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="goal">Goal<a hidden class="anchor" aria-hidden="true" href="#goal">#</a></h1>
<ul>
<li>In most Revit add-ins, your first step will be to <strong>collect elements from the model</strong>.</li>
<li>The go-to tool for this is the <code>FilteredElementCollector</code>, which lets you gather elements and then refine your selection using a variety of filtering techniques in C#.</li>
</ul>
<h2 id="to-explore-everything-there-is-to-know-about">To explore everything there is to know about:<a hidden class="anchor" aria-hidden="true" href="#to-explore-everything-there-is-to-know-about">#</a></h2>
<h2 id="filteredelementcollector"><code>FilteredElementCollector</code><a hidden class="anchor" aria-hidden="true" href="#filteredelementcollector">#</a></h2>
<ul>
<li>The <code>FilteredElementCollector</code> is a special Revit API class that works much like running a <strong>database query</strong>, with your Revit document acting as the database.</li>
<li>It allows you to start with a broad set of elements and then refine your results using various filtering methods to target exactly what you need.</li>
</ul>
<h3 id="declaring-a-collector"><strong>Declaring a Collector</strong><a hidden class="anchor" aria-hidden="true" href="#declaring-a-collector">#</a></h3>
<ul>
<li>To create a collector for the entire document:</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">collector</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>If you only want elements visible in a specific view, pass the view’s Id:</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">collector</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="n">view</span><span class="p">.</span><span class="n">Id</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="revit-api">Revit API<a hidden class="anchor" aria-hidden="true" href="#revit-api">#</a></h1>
<h3 id="filteredelementcollector-constructors"><code>FilteredElementCollector</code> Constructors<a hidden class="anchor" aria-hidden="true" href="#filteredelementcollector-constructors">#</a></h3>
<p>The <code>FilteredElementCollector</code> provides multiple constructor overloads, allowing you to start your collection from different scopes depending on your needs.</p>
<br>
<p><strong>1. Constructor with Document</strong></p>
<p>The most common constructor — collects elements from the entire document.</p>
<ul>
<li><code>FilteredElementCollector</code> Constructor (<code>Document</code>):</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="kd">public</span> <span class="n">FilteredElementCollector</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">	    <span class="n">Document</span> <span class="n">document</span> <span class="c1">// The document to search in.</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>Example:</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">collector</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><br>
<br>
<p><strong>2. Constructor with Document and ElementId (View)</strong></p>
<p>Collects only elements <strong>visible in a specific view</strong>, identified by its ElementId.</p>
<ul>
<li><code>FilteredElementCollector</code> Constructor (<code>Document</code>, <code>ElementId</code>)</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="kd">public</span> <span class="n">FilteredElementCollector</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">	    <span class="n">Document</span> <span class="n">document</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	    <span class="n">ElementId</span> <span class="n">viewId</span> <span class="c1">// The view’s ID.</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>Example:</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">collector</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="n">view</span><span class="p">.</span><span class="n">Id</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><br>
<br>
<p><strong>3. Constructor with <code>Document</code> and <code>ICollection&lt;ElementId&gt;</code></strong></p>
<p>Filters a <strong>predefined set of elements</strong>. Useful when you’ve already gathered certain elements and want to further refine that list.</p>
<ul>
<li><code>FilteredElementCollector</code> Constructor (<code>Document</code>, <code>ICollection(ElementId)</code>)</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="kd">public</span> <span class="n">FilteredElementCollector</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">	    <span class="n">Document</span> <span class="n">document</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	    <span class="n">ICollection</span><span class="p">&lt;</span><span class="n">ElementId</span><span class="p">&gt;</span> <span class="n">elementIds</span> <span class="c1">// A set of element IDs to filter.</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>Example:</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">collector</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="n">myElementIds</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><br>
<br>
<p><strong>4. Constructor with <code>Document</code>, <code>ElementId (View)</code>, and <code>ElementId (Link)</code></strong></p>
<p>Filters elements within a <strong>linked Revit model</strong>, scoped to a specific view.</p>
<ul>
<li><code>FilteredElementCollector</code> Constructor (<code>Document</code>, <code>ElementId</code>, <code>ElementId</code>)</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="kd">public</span> <span class="n">FilteredElementCollector</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">	    <span class="n">Document</span> <span class="n">document</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	    <span class="n">ElementId</span> <span class="n">viewId</span><span class="p">,</span>  <span class="c1">// The view ID in the host document.</span>
</span></span><span class="line"><span class="cl">	    <span class="n">ElementId</span> <span class="n">linkId</span>   <span class="c1">// The Revit link instance ID in the host document.</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>Example:</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">collector</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="n">view</span><span class="p">.</span><span class="n">Id</span><span class="p">,</span> <span class="n">linkInstance</span><span class="p">.</span><span class="n">Id</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><hr>
<h3 id="filteredelementcollector-methods"><code>FilteredElementCollector</code> Methods<a hidden class="anchor" aria-hidden="true" href="#filteredelementcollector-methods">#</a></h3>
<table>
  <thead>
      <tr>
          <th>Name</th>
          <th>Description</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><a href="https://www.revitapidocs.com/2025/92a2be0f-f632-2337-5bdd-ae3e832f3c33.htm">ContainedInDesignOption</a></td>
          <td>Applies an ElementDesignOptionFilter to the collector.</td>
      </tr>
      <tr>
          <td><a href="https://www.revitapidocs.com/2025/c23c8781-f645-c059-7db5-d0cfd732dda1.htm">Dispose</a></td>
          <td></td>
      </tr>
      <tr>
          <td><a href="https://learn.microsoft.com/dotnet/api/system.object.equals#system-object-equals(system-object)">Equals</a></td>
          <td>Determines whether the specified object is equal to the current object.   <br>(Inherited from <a href="https://learn.microsoft.com/dotnet/api/system.object">Object</a> )</td>
      </tr>
      <tr>
          <td><a href="https://www.revitapidocs.com/2025/80e23fdc-c005-163b-5643-38d84411a73d.htm">Excluding</a></td>
          <td>Applies an ExclusionFilter to the collector.</td>
      </tr>
      <tr>
          <td><a href="https://www.revitapidocs.com/2025/c8c1cae0-4ac8-a309-e915-6d491137d47e.htm">FirstElement</a></td>
          <td>Returns the first element to pass the filter(s).</td>
      </tr>
      <tr>
          <td><a href="https://www.revitapidocs.com/2025/b1b42ac5-e816-983a-f44d-5cf441ca1ad9.htm">FirstElementId</a></td>
          <td>Returns the id of the first element to pass the filter(s).</td>
      </tr>
      <tr>
          <td><a href="https://www.revitapidocs.com/2025/07236f22-1721-1f6e-0fb6-f03709923430.htm">GetBasicIEnumerator</a></td>
          <td>Returns an enumerator that iterates through a collection.</td>
      </tr>
      <tr>
          <td><a href="https://www.revitapidocs.com/2025/886aabfd-ea87-e54c-d108-37d09a44d612.htm">GetElementCount</a></td>
          <td>Gets the number of elements in your current filter.</td>
      </tr>
      <tr>
          <td><a href="https://www.revitapidocs.com/2025/0b1cdbeb-21ce-a4c5-6cae-253595818085.htm">GetElementIdIterator</a></td>
          <td>Returns an element id iterator to the elements passing the filters.</td>
      </tr>
      <tr>
          <td><a href="https://www.revitapidocs.com/2025/7113e21c-90f8-8f58-3b00-407fc1cd56e0.htm">GetElementIterator</a></td>
          <td>Returns an element iterator to the elements passing the filters.</td>
      </tr>
      <tr>
          <td><a href="https://www.revitapidocs.com/2025/746ac65b-35c2-d0db-53d7-4fe0fd61ab1f.htm">GetEnumerator</a></td>
          <td>Returns an enumerator that iterates through a collection.</td>
      </tr>
      <tr>
          <td><a href="https://learn.microsoft.com/dotnet/api/system.object.gethashcode#system-object-gethashcode">GetHashCode</a></td>
          <td>Serves as the default hash function.   <br>(Inherited from <a href="https://learn.microsoft.com/dotnet/api/system.object">Object</a> )</td>
      </tr>
      <tr>
          <td><a href="https://learn.microsoft.com/dotnet/api/system.object.gettype#system-object-gettype">GetType</a></td>
          <td>Gets the <a href="https://learn.microsoft.com/dotnet/api/system.type">Type</a> of the current instance.   <br>(Inherited from <a href="https://learn.microsoft.com/dotnet/api/system.object">Object</a> )</td>
      </tr>
      <tr>
          <td><a href="https://www.revitapidocs.com/2025/5b204fc8-7702-cf7e-346a-3a4c1767924b.htm">IntersectWith</a></td>
          <td>Intersects the set of elements passing the filter in this collector with the set of elements passing the filter in another collector.</td>
      </tr>
      <tr>
          <td><a href="https://www.revitapidocs.com/2025/9c7f3f9c-aa8a-8077-9235-ff1058c8b20b.htm">IsViewValidForElementIteration</a></td>
          <td>Identifies if the particular element is valid for iteration of drawn elements.</td>
      </tr>
      <tr>
          <td><a href="https://www.revitapidocs.com/2025/c3523c35-4a07-9723-3c28-de3cc47b2ad0.htm">OfCategory</a></td>
          <td>Applies an ElementCategoryFilter to the collector.</td>
      </tr>
      <tr>
          <td><a href="https://www.revitapidocs.com/2025/63304108-73f8-844e-82fc-5b8fad9839b0.htm">OfCategoryId</a></td>
          <td>Applies an ElementCategoryFilter to the collector.</td>
      </tr>
      <tr>
          <td><a href="https://www.revitapidocs.com/2025/b0a5f22c-6951-c3af-cd29-1f28f574035d.htm">OfClass</a></td>
          <td>Applies an ElementClassFilter to the collector.</td>
      </tr>
      <tr>
          <td><a href="https://www.revitapidocs.com/2025/54f2107a-bd87-41fe-dd00-385253ba5915.htm">OwnedByView</a></td>
          <td>Applies an ElementOwnerViewFilter to the collector.</td>
      </tr>
      <tr>
          <td><a href="https://www.revitapidocs.com/2025/bfb8c8a2-aa2f-b1bc-7d57-7e3f7d39fcae.htm">ToElementIds</a></td>
          <td>Returns the complete set of element ids that pass the filter(s).</td>
      </tr>
      <tr>
          <td><a href="https://www.revitapidocs.com/2025/732b4a0d-62d8-b86d-120b-8ea3d9713b34.htm">ToElements</a></td>
          <td>Returns the complete set of elements that pass the filter(s).</td>
      </tr>
      <tr>
          <td><a href="https://learn.microsoft.com/dotnet/api/system.object.tostring#system-object-tostring">ToString</a></td>
          <td>Returns a string that represents the current object.   <br>(Inherited from <a href="https://learn.microsoft.com/dotnet/api/system.object">Object</a> )</td>
      </tr>
      <tr>
          <td><a href="https://www.revitapidocs.com/2025/957cc5cb-5c7f-cac9-ec86-35afe824c432.htm">UnionWith</a></td>
          <td>Unites the set of elements passing the filter in this collector with the set of elements passing the filter in another collector.</td>
      </tr>
      <tr>
          <td><a href="https://www.revitapidocs.com/2025/3f3269fc-367c-1fec-9ddb-d0b54ecc4f0e.htm">WhereElementIsCurveDriven</a></td>
          <td>Applies an ElementIsCurveDrivenFilter to the collector.</td>
      </tr>
      <tr>
          <td><a href="https://www.revitapidocs.com/2025/77793daa-5a26-b4d6-9019-4d998a55099e.htm">WhereElementIsElementType</a></td>
          <td>Applies an ElementIsElementTypeFilter to the collector.</td>
      </tr>
      <tr>
          <td><a href="https://www.revitapidocs.com/2025/061cbbb9-26f1-a8f8-a4b2-3d7ff0105199.htm">WhereElementIsNotElementType</a></td>
          <td>Applies an inverted ElementIsElementTypeFilter to the collector.</td>
      </tr>
      <tr>
          <td><a href="https://www.revitapidocs.com/2025/38b15459-9ffe-204a-0193-47c3a1b5e6e2.htm">WhereElementIsViewIndependent</a></td>
          <td>Applies an ElementOwnerViewFilter to the collector.</td>
      </tr>
      <tr>
          <td><a href="https://www.revitapidocs.com/2025/42d4eef3-55a1-2739-0ef8-6bc1d9fc2755.htm">WherePasses</a></td>
          <td>Applies an element filter to the collector.</td>
      </tr>
  </tbody>
</table>
<hr>
<h1 id="method-chaining-in-c">Method Chaining in C#<a hidden class="anchor" aria-hidden="true" href="#method-chaining-in-c">#</a></h1>
<h2 id="what-is-method-chaining">What is Method Chaining?<a hidden class="anchor" aria-hidden="true" href="#what-is-method-chaining">#</a></h2>
<p>Method chaining allows you to call multiple methods on an object in a single statement by linking them together with dots (<code>.</code>). Each method returns an object that the next method can be called on.</p>
<p>Think of it like a conveyor belt in a factory - each station (method) processes the item and passes it to the next station.</p>
<h2 id="basic-concept">Basic Concept<a hidden class="anchor" aria-hidden="true" href="#basic-concept">#</a></h2>
<p>Instead of writing multiple separate lines:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="c1">// Without chaining (multiple lines)</span>
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">collector</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">collector</span> <span class="p">=</span> <span class="n">collector</span><span class="p">.</span><span class="n">OfClass</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">Wall</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="n">collector</span> <span class="p">=</span> <span class="n">collector</span><span class="p">.</span><span class="n">WhereElementIsNotElementType</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">elements</span> <span class="p">=</span> <span class="n">collector</span><span class="p">.</span><span class="n">ToElements</span><span class="p">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>You can chain methods together:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="c1">// With chaining (single statement)</span>
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">elements</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">OfClass</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">Wall</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">WhereElementIsNotElementType</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">ToElements</span><span class="p">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="how-method-chaining-works">How Method Chaining Works<a hidden class="anchor" aria-hidden="true" href="#how-method-chaining-works">#</a></h2>
<ol>
<li><strong>Return Value</strong>: Each method in the chain returns an object (often the same type)</li>
<li><strong>Dot Notation</strong>: Use <code>.</code> to call the next method on the returned object</li>
<li><strong>Left-to-Right</strong>: Methods execute from left to right (or top to bottom when formatted)</li>
</ol>
<h2 id="understanding-ofclass-vs-ofcategory">Understanding <code>.OfClass</code> vs <code>.OfCategory</code><a hidden class="anchor" aria-hidden="true" href="#understanding-ofclass-vs-ofcategory">#</a></h2>
<p>This is <strong>crucial</strong> to understand! These two methods filter eleme=nts in completely different ways:</p>
<h3 id="ofclass---filters-by-c-class-type"><code>.OfClass()</code> - Filters by C# Class Type<a hidden class="anchor" aria-hidden="true" href="#ofclass---filters-by-c-class-type">#</a></h3>
<ul>
<li>Filters based on the <strong>underlying programming class</strong> in the Revit API</li>
<li>Examples: <code>Wall</code>, <code>Floor</code>, <code>FamilyInstance</code>, <code>TextNote</code>, etc.</li>
<li><strong>One class can contain multiple categories</strong></li>
</ul>
<h3 id="ofcategory---filters-by-revit-category"><code>.OfCategory()</code> - Filters by Revit Category<a hidden class="anchor" aria-hidden="true" href="#ofcategory---filters-by-revit-category">#</a></h3>
<ul>
<li>Filters based on the <strong>visual category</strong> you see in Revit&rsquo;s interface</li>
<li>Examples: <code>OST_Walls</code>, <code>OST_Doors</code>, <code>OST_Windows</code>, <code>OST_Floors</code>, etc.</li>
<li><strong>More specific than class filtering</strong></li>
</ul>
<h3 id="key-insight-familyinstance-class">Key Insight: <code>FamilyInstance</code> Class<a hidden class="anchor" aria-hidden="true" href="#key-insight-familyinstance-class">#</a></h3>
<p>Many different Revit elements share the same class but have different categories:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="c1">// These are ALL FamilyInstance class, but different categories:</span>
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">doors</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">OfClass</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">FamilyInstance</span><span class="p">))</span>           <span class="c1">// Class: FamilyInstance</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">OfCategory</span><span class="p">(</span><span class="n">BuiltInCategory</span><span class="p">.</span><span class="n">OST_Doors</span><span class="p">)</span>     <span class="c1">// Category: Doors</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">ToElements</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">windows</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">OfClass</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">FamilyInstance</span><span class="p">))</span>           <span class="c1">// Class: FamilyInstance  </span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">OfCategory</span><span class="p">(</span><span class="n">BuiltInCategory</span><span class="p">.</span><span class="n">OST_Windows</span><span class="p">)</span>   <span class="c1">// Category: Windows</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">ToElements</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">furniture</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">OfClass</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">FamilyInstance</span><span class="p">))</span>           <span class="c1">// Class: FamilyInstance</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">OfCategory</span><span class="p">(</span><span class="n">BuiltInCategory</span><span class="p">.</span><span class="n">OST_Furniture</span><span class="p">)</span> <span class="c1">// Category: Furniture</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">ToElements</span><span class="p">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="when-to-use-which">When to Use Which?<a hidden class="anchor" aria-hidden="true" href="#when-to-use-which">#</a></h3>
<p><strong>Use <code>.OfClass()</code> when:</strong></p>
<ul>
<li>You want ALL elements of a specific programming type</li>
<li>The class directly matches what you want (like <code>Wall</code>, <code>Floor</code>)</li>
</ul>
<p><strong>Use <code>.OfCategory()</code> when:</strong></p>
<ul>
<li>You want elements from a specific Revit category</li>
<li>You&rsquo;re working with FamilyInstances and need to specify which type</li>
</ul>
<p><strong>Use <code>BOTH</code> when:</strong></p>
<ul>
<li>You want to be very specific and ensure you get exactly what you expect</li>
</ul>
<hr>
<h2 id="understanding-builtincategory-and-alternatives">Understanding <code>BuiltInCategory</code> and Alternatives<a hidden class="anchor" aria-hidden="true" href="#understanding-builtincategory-and-alternatives">#</a></h2>
<h3 id="what-is-builtincategory">What is BuiltInCategory?<a hidden class="anchor" aria-hidden="true" href="#what-is-builtincategory">#</a></h3>
<p><code>BuiltInCategory</code> is an <strong>enumeration</strong> (enum) provided by the Revit API that contains predefined constants for all the standard Revit categories. Think of it as a list of &ldquo;official category names&rdquo; that Revit recognizes.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="c1">// BuiltInCategory is an enum with values like:</span>
</span></span><span class="line"><span class="cl"><span class="n">BuiltInCategory</span><span class="p">.</span><span class="n">OST_Walls</span>
</span></span><span class="line"><span class="cl"><span class="n">BuiltInCategory</span><span class="p">.</span><span class="n">OST_Doors</span>  
</span></span><span class="line"><span class="cl"><span class="n">BuiltInCategory</span><span class="p">.</span><span class="n">OST_Windows</span>
</span></span><span class="line"><span class="cl"><span class="n">BuiltInCategory</span><span class="p">.</span><span class="n">OST_Floors</span>
</span></span><span class="line"><span class="cl"><span class="n">BuiltInCategory</span><span class="p">.</span><span class="n">OST_Furniture</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ... and hundreds more</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="why-use-builtincategory-recommended-approach">Why Use <a href="https://www.revitapidocs.com/2026/ba1c5b30-242f-5fdc-8ea9-ec3b61e6e722.htm"><code>BuiltInCategory</code></a>? (Recommended Approach)<a hidden class="anchor" aria-hidden="true" href="#why-use-builtincategory-recommended-approach">#</a></h3>
<p><strong>Advantages:</strong></p>
<ul>
<li><strong>Type Safety</strong>: The compiler catches typos</li>
<li><strong>IntelliSense</strong>: Auto-complete shows you available options</li>
<li><strong>No Spelling Errors</strong>: Can&rsquo;t misspell category names</li>
<li><strong>Language Independent</strong>: Works regardless of Revit&rsquo;s display language</li>
<li><strong>Future Proof</strong>: Updates automatically with new Revit versions</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="c1">// ✅ GOOD: Using BuiltInCategory</span>
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">doors</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">OfCategory</span><span class="p">(</span><span class="n">BuiltInCategory</span><span class="p">.</span><span class="n">OST_Doors</span><span class="p">)</span>  <span class="c1">// IntelliSense helps, no typos possible</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">WhereElementIsNotElementType</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">ToElements</span><span class="p">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="alternative-1-using-category-objects">Alternative 1: Using Category <code>Objects</code><a hidden class="anchor" aria-hidden="true" href="#alternative-1-using-category-objects">#</a></h3>
<p>You can get Category objects and use their ElementId:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="c1">// Find category by name</span>
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">doorCategory</span> <span class="p">=</span> <span class="n">doc</span><span class="p">.</span><span class="n">Categories</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">Cast</span><span class="p">&lt;</span><span class="n">Category</span><span class="p">&gt;()</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">FirstOrDefault</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="n">c</span><span class="p">.</span><span class="n">Name</span> <span class="p">==</span> <span class="s">&#34;Doors&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">doorCategory</span> <span class="p">!=</span> <span class="kc">null</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">var</span> <span class="n">doors</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="n">OfCategoryId</span><span class="p">(</span><span class="n">doorCategory</span><span class="p">.</span><span class="n">Id</span><span class="p">)</span>  <span class="c1">// Using ElementId</span>
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="n">WhereElementIsNotElementType</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="n">ToElements</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>When to use:</strong></p>
<ul>
<li>Working with custom categories created by users</li>
<li>Dynamic category selection based on user input</li>
<li>When you need access to Category properties</li>
</ul>
<h3 id="alternative-2-using-category-names-not-recommended">Alternative 2: Using Category <code>Names</code> (Not Recommended)<a hidden class="anchor" aria-hidden="true" href="#alternative-2-using-category-names-not-recommended">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="c1">// ❌ PROBLEMATIC: This approach has issues</span>
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">allCategories</span> <span class="p">=</span> <span class="n">doc</span><span class="p">.</span><span class="n">Categories</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">foreach</span> <span class="p">(</span><span class="n">Category</span> <span class="n">cat</span> <span class="k">in</span> <span class="n">allCategories</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">cat</span><span class="p">.</span><span class="n">Name</span> <span class="p">==</span> <span class="s">&#34;Doors&#34;</span><span class="p">)</span>  <span class="c1">// Depends on Revit language!</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">var</span> <span class="n">doors</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">.</span><span class="n">OfCategoryId</span><span class="p">(</span><span class="n">cat</span><span class="p">.</span><span class="n">Id</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">.</span><span class="n">ToElements</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>Problems with this approach:</strong></p>
<ul>
<li><strong>Language Dependent</strong>: &ldquo;Doors&rdquo; in English, &ldquo;Portes&rdquo; in French, &ldquo;Türen&rdquo; in German</li>
<li><strong>Typo Prone</strong>: Easy to misspell category names</li>
<li><strong>Performance</strong>: Requires searching through all categories</li>
<li><strong>Fragile</strong>: Breaks if category names change</li>
</ul>
<h3 id="alternative-3-converting-between-approaches">Alternative 3: Converting Between Approaches<a hidden class="anchor" aria-hidden="true" href="#alternative-3-converting-between-approaches">#</a></h3>
<p>Sometimes you need to convert between different category representations:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="c1">// Convert BuiltInCategory to Category object</span>
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">builtInCat</span> <span class="p">=</span> <span class="n">BuiltInCategory</span><span class="p">.</span><span class="n">OST_Doors</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">category</span> <span class="p">=</span> <span class="n">Category</span><span class="p">.</span><span class="n">GetCategory</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="n">builtInCat</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Convert BuiltInCategory to ElementId</span>
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">elementId</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ElementId</span><span class="p">(</span><span class="n">builtInCat</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Use either approach:</span>
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">doors1</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">OfCategory</span><span class="p">(</span><span class="n">builtInCat</span><span class="p">)</span>      <span class="c1">// Direct BuiltInCategory</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">ToElements</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">doors2</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">OfCategoryId</span><span class="p">(</span><span class="n">elementId</span><span class="p">)</span>     <span class="c1">// Using ElementId</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">ToElements</span><span class="p">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="practical-example-user-defined-categories">Practical Example: <code>User-Defined</code> Categories<a hidden class="anchor" aria-hidden="true" href="#practical-example-user-defined-categories">#</a></h3>
<p>When dealing with custom categories (created by users), you&rsquo;ll need the Category object approach:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="c1">// Example: Get elements from a custom category</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="n">IList</span><span class="p">&lt;</span><span class="n">Element</span><span class="p">&gt;</span> <span class="n">GetElementsFromCustomCategory</span><span class="p">(</span><span class="n">Document</span> <span class="n">doc</span><span class="p">,</span> <span class="kt">string</span> <span class="n">categoryName</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Find the custom category</span>
</span></span><span class="line"><span class="cl">    <span class="kt">var</span> <span class="n">customCategory</span> <span class="p">=</span> <span class="n">doc</span><span class="p">.</span><span class="n">Categories</span>
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="n">Cast</span><span class="p">&lt;</span><span class="n">Category</span><span class="p">&gt;()</span>
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="n">FirstOrDefault</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="n">c</span><span class="p">.</span><span class="n">Name</span><span class="p">.</span><span class="n">Equals</span><span class="p">(</span><span class="n">categoryName</span><span class="p">,</span> <span class="n">StringComparison</span><span class="p">.</span><span class="n">OrdinalIgnoreCase</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">customCategory</span> <span class="p">!=</span> <span class="kc">null</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">.</span><span class="n">OfCategoryId</span><span class="p">(</span><span class="n">customCategory</span><span class="p">.</span><span class="n">Id</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">.</span><span class="n">WhereElementIsNotElementType</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">            <span class="p">.</span><span class="n">ToElements</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Element</span><span class="p">&gt;();</span> <span class="c1">// Return empty list if category not found</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="best-practice-summary">Best Practice Summary<a hidden class="anchor" aria-hidden="true" href="#best-practice-summary">#</a></h3>
<p><strong>Use <code>BuiltInCategory</code> for standard Revit categories</strong> (95% of cases):</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="p">.</span><span class="n">OfCategory</span><span class="p">(</span><span class="n">BuiltInCategory</span><span class="p">.</span><span class="n">OST_Doors</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>Use <code>Category</code> objects for custom or dynamic scenarios</strong>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="p">.</span><span class="n">OfCategoryId</span><span class="p">(</span><span class="n">customCategory</span><span class="p">.</span><span class="n">Id</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>Avoid string-based category searching</strong> unless absolutely necessary.</p>
<h3 id="common-builtincategory-values">Common <code>BuiltInCategory</code> Values<a hidden class="anchor" aria-hidden="true" href="#common-builtincategory-values">#</a></h3>
<p>Here are some frequently used categories for reference:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="c1">// Architectural</span>
</span></span><span class="line"><span class="cl"><span class="n">BuiltInCategory</span><span class="p">.</span><span class="n">OST_Walls</span>
</span></span><span class="line"><span class="cl"><span class="n">BuiltInCategory</span><span class="p">.</span><span class="n">OST_Doors</span>  
</span></span><span class="line"><span class="cl"><span class="n">BuiltInCategory</span><span class="p">.</span><span class="n">OST_Windows</span>
</span></span><span class="line"><span class="cl"><span class="n">BuiltInCategory</span><span class="p">.</span><span class="n">OST_Floors</span>
</span></span><span class="line"><span class="cl"><span class="n">BuiltInCategory</span><span class="p">.</span><span class="n">OST_Roofs</span>
</span></span><span class="line"><span class="cl"><span class="n">BuiltInCategory</span><span class="p">.</span><span class="n">OST_Ceilings</span>
</span></span><span class="line"><span class="cl"><span class="n">BuiltInCategory</span><span class="p">.</span><span class="n">OST_Stairs</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// MEP</span>
</span></span><span class="line"><span class="cl"><span class="n">BuiltInCategory</span><span class="p">.</span><span class="n">OST_DuctCurves</span>
</span></span><span class="line"><span class="cl"><span class="n">BuiltInCategory</span><span class="p">.</span><span class="n">OST_PipeCurves</span>
</span></span><span class="line"><span class="cl"><span class="n">BuiltInCategory</span><span class="p">.</span><span class="n">OST_ElectricalFixtures</span>
</span></span><span class="line"><span class="cl"><span class="n">BuiltInCategory</span><span class="p">.</span><span class="n">OST_LightingFixtures</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Structural  </span>
</span></span><span class="line"><span class="cl"><span class="n">BuiltInCategory</span><span class="p">.</span><span class="n">OST_StructuralColumns</span>
</span></span><span class="line"><span class="cl"><span class="n">BuiltInCategory</span><span class="p">.</span><span class="n">OST_StructuralFraming</span>
</span></span><span class="line"><span class="cl"><span class="n">BuiltInCategory</span><span class="p">.</span><span class="n">OST_StructuralFoundation</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Furniture &amp; Equipment</span>
</span></span><span class="line"><span class="cl"><span class="n">BuiltInCategory</span><span class="p">.</span><span class="n">OST_Furniture</span>
</span></span><span class="line"><span class="cl"><span class="n">BuiltInCategory</span><span class="p">.</span><span class="n">OST_SpecialityEquipment</span>
</span></span><span class="line"><span class="cl"><span class="n">BuiltInCategory</span><span class="p">.</span><span class="n">OST_PlumbingFixtures</span>
</span></span></code></pre></td></tr></table>
</div>
</div><hr>
<h2 id="filteredelementcollector-examples"><code>FilteredElementCollector</code> Examples<a hidden class="anchor" aria-hidden="true" href="#filteredelementcollector-examples">#</a></h2>
<h3 id="example-1-get-all-walls-class-based">Example 1: Get All <code>Walls</code> (Class-based)<a hidden class="anchor" aria-hidden="true" href="#example-1-get-all-walls-class-based">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">walls</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">OfClass</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">Wall</span><span class="p">))</span>                <span class="c1">// Wall class = Wall category</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">WhereElementIsNotElementType</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">ToElements</span><span class="p">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="example-2-get-windows-category-based---more-common">Example 2: Get <code>Windows</code> (Category-based - More Common)<a hidden class="anchor" aria-hidden="true" href="#example-2-get-windows-category-based---more-common">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">windows</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">OfCategory</span><span class="p">(</span><span class="n">BuiltInCategory</span><span class="p">.</span><span class="n">OST_Windows</span><span class="p">)</span>  <span class="c1">// Category filtering</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">WhereElementIsNotElementType</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">ToElements</span><span class="p">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="example-3-get-windows-belt--suspenders-approach">Example 3: Get <code>Windows</code> (Belt &amp; Suspenders Approach)<a hidden class="anchor" aria-hidden="true" href="#example-3-get-windows-belt--suspenders-approach">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">windows</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">OfClass</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">FamilyInstance</span><span class="p">))</span>          <span class="c1">// Class filtering</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">OfCategory</span><span class="p">(</span><span class="n">BuiltInCategory</span><span class="p">.</span><span class="n">OST_Windows</span><span class="p">)</span>  <span class="c1">// Category filtering  </span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">WhereElementIsNotElementType</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">ToElements</span><span class="p">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="example-4-get-all-family-instances-any-category">Example 4: Get ALL Family Instances (Any Category)<a hidden class="anchor" aria-hidden="true" href="#example-4-get-all-family-instances-any-category">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">allFamilyInstances</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">OfClass</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">FamilyInstance</span><span class="p">))</span>     <span class="c1">// Gets doors, windows, furniture, etc.</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">WhereElementIsNotElementType</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">ToElements</span><span class="p">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="understanding-whereelementisnotelementtype">Understanding <code>.WhereElementIsNotElementType()</code><a hidden class="anchor" aria-hidden="true" href="#understanding-whereelementisnotelementtype">#</a></h2>
<p>This method is <strong>extremely important</strong> and addresses a fundamental concept in Revit: the difference between <strong><code>Element Types</code></strong> and <strong><code>Element Instances</code></strong>.</p>
<h3 id="element-types-vs-element-instances">Element Types vs Element Instances<a hidden class="anchor" aria-hidden="true" href="#element-types-vs-element-instances">#</a></h3>
<p><strong><code>Element Types</code></strong> (Templates/Definitions):</p>
<ul>
<li>These are the &ldquo;recipes&rdquo; or &ldquo;templates&rdquo; for elements</li>
<li>Examples: &ldquo;Interior Door 36&rdquo;×84&quot;&quot;, &ldquo;Exterior Wall - Brick&rdquo;, &ldquo;Standard Table&rdquo;</li>
<li>You see these in the Project Browser under &ldquo;Families&rdquo;</li>
<li>They define properties but aren&rsquo;t physical objects in your model</li>
</ul>
<p><strong><code>Element Instances</code></strong> (Actual Placed Elements):</p>
<ul>
<li>These are the actual elements placed in your model</li>
<li>Examples: The specific door at coordinate (10, 5), the wall from point A to B</li>
<li>These are what you see and select in your 3D/plan views</li>
<li>They reference a type but exist at specific locations</li>
</ul>
<h3 id="the-methods">The Methods<a hidden class="anchor" aria-hidden="true" href="#the-methods">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="c1">// Gets ONLY element instances (the actual placed elements)</span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="n">WhereElementIsNotElementType</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Gets ONLY element types (the definitions/templates)  </span>
</span></span><span class="line"><span class="cl"><span class="p">.</span><span class="n">WhereElementIsElementType</span><span class="p">()</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="why-this-matters">Why This Matters<a hidden class="anchor" aria-hidden="true" href="#why-this-matters">#</a></h3>
<p>When you collect elements without these filters, you get <strong>BOTH</strong> types and instances:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="c1">// WITHOUT filtering - gets both types and instances</span>
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">everything</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">OfCategory</span><span class="p">(</span><span class="n">BuiltInCategory</span><span class="p">.</span><span class="n">OST_Doors</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">ToElements</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Result: Door types AND door instances mixed together</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// WITH instance filtering - gets only placed doors</span>
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">actualDoors</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">OfCategory</span><span class="p">(</span><span class="n">BuiltInCategory</span><span class="p">.</span><span class="n">OST_Doors</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">WhereElementIsNotElementType</span><span class="p">()</span>    <span class="c1">// Only instances</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">ToElements</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Result: Only the actual doors placed in the model</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// WITH type filtering - gets only door type definitions</span>
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">doorTypes</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">OfCategory</span><span class="p">(</span><span class="n">BuiltInCategory</span><span class="p">.</span><span class="n">OST_Doors</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">WhereElementIsElementType</span><span class="p">()</span>       <span class="c1">// Only types</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">ToElements</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Result: Only the door type definitions</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="common-use-cases">Common Use Cases<a hidden class="anchor" aria-hidden="true" href="#common-use-cases">#</a></h3>
<p><strong>Most Common: Get Instances (<code>.WhereElementIsNotElementType()</code>)</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="c1">// Count how many doors are actually placed in the model</span>
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">doorCount</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">OfCategory</span><span class="p">(</span><span class="n">BuiltInCategory</span><span class="p">.</span><span class="n">OST_Doors</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">WhereElementIsNotElementType</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">GetElementCount</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Get all placed walls to analyze their geometry</span>
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">walls</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">OfClass</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">Wall</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">WhereElementIsNotElementType</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">ToElements</span><span class="p">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>Sometimes Needed: Get Types (<code>.WhereElementIsElementType()</code>)</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="c1">// Get all door types to list available options</span>
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">doorTypes</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">OfCategory</span><span class="p">(</span><span class="n">BuiltInCategory</span><span class="p">.</span><span class="n">OST_Doors</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">WhereElementIsElementType</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">ToElements</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Get all wall types to copy to another project</span>
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">wallTypes</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">OfClass</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">WallType</span><span class="p">))</span>           <span class="c1">// WallType class</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">WhereElementIsElementType</span><span class="p">()</span>         <span class="c1">// Redundant but explicit</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">ToElements</span><span class="p">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="pro-tip-some-classes-are-always-types">Pro Tip: Some Classes Are Always Types<a hidden class="anchor" aria-hidden="true" href="#pro-tip-some-classes-are-always-types">#</a></h3>
<p>Some classes like <code>WallType</code>, <code>FloorType</code>, <code>FamilySymbol</code> are <strong>always</strong> types, so <code>.WhereElementIsElementType()</code> is redundant (but harmless):</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="c1">// These are equivalent for type classes:</span>
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">wallTypes1</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">OfClass</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">WallType</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">ToElements</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">wallTypes2</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">OfClass</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">WallType</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">WhereElementIsElementType</span><span class="p">()</span>    <span class="c1">// Redundant but OK</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">ToElements</span><span class="p">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="memory-aid">Memory Aid<a hidden class="anchor" aria-hidden="true" href="#memory-aid">#</a></h3>
<ul>
<li><strong><code>Instance</code></strong> = &ldquo;In-stance&rdquo; = <strong>IN</strong> the model (placed/physical)</li>
<li><strong><code>Type</code></strong> = &ldquo;Template&rdquo; = <strong>NOT</strong> placed (definition only)</li>
</ul>
<p><strong>Rule of thumb</strong>: 99% of the time you want <code>.WhereElementIsNotElementType()</code> because you&rsquo;re working with actual placed elements!</p>
<h3 id="example-5-to-get-all-elements-visible-in-a-specific-view">Example 5: To Get All Elements Visible in a Specific View<a hidden class="anchor" aria-hidden="true" href="#example-5-to-get-all-elements-visible-in-a-specific-view">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">visibleElements</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="n">viewId</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">OfClass</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">FamilyInstance</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">WhereElementIsNotElementType</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">ToElementIds</span><span class="p">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><hr>
<h2 id="custom-filters">Custom Filters<a hidden class="anchor" aria-hidden="true" href="#custom-filters">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">filteredElements</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">OfCategory</span><span class="p">(</span><span class="n">BuiltInCategory</span><span class="p">.</span><span class="n">OST_Doors</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">WhereElementIsNotElementType</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">WherePasses</span><span class="p">(</span><span class="k">new</span> <span class="n">ElementLevelFilter</span><span class="p">(</span><span class="n">levelId</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">ToElements</span><span class="p">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="understanding-wherepasses-and-custom-filters">Understanding <code>.WherePasses()</code> and Custom Filters<a hidden class="anchor" aria-hidden="true" href="#understanding-wherepasses-and-custom-filters">#</a></h3>
<ul>
<li>The <code>.WherePasses()</code> method allows you to apply <strong>custom filters</strong> that go beyond the basic filtering capabilities of <code>.OfClass()</code> and <code>.OfCategory()</code>. This is where you can get very specific about which elements you want, such as getting all elements whose parameter meets a certain condition.</li>
<li>These are often complex to construct but perform faster than the alternative LINQ methods.
<ul>
<li>Custom Filters are considered best-practice to build scalable applications rather than LINQ.</li>
</ul>
</li>
<li>Here is an example of 5 steps involved constructing a rule to provide to a <code>WherePasses()</code> filter:</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">parameterId</span>  <span class="p">=</span> <span class="k">new</span> <span class="n">ElementId</span><span class="p">(</span><span class="n">BuiltInParameter</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">provider</span>     <span class="p">=</span> <span class="k">new</span> <span class="n">ParameterValueProvider</span><span class="p">(</span><span class="n">parameterId</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">rule</span>         <span class="p">=</span> <span class="k">new</span> <span class="n">FilterNumericLess</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">passesRule</span>   <span class="p">=</span> <span class="k">new</span> <span class="n">FilterDoubleRule</span><span class="p">(</span><span class="n">provider</span><span class="p">,</span> <span class="n">rule</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">paramFilter</span>  <span class="p">=</span> <span class="k">new</span> <span class="n">ElementParameterFilter</span><span class="p">(</span><span class="n">passesRule</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="wherepasses-syntax"><code>.WherePasses()</code> Syntax<a hidden class="anchor" aria-hidden="true" href="#wherepasses-syntax">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="p">.</span><span class="n">WherePasses</span><span class="p">(</span><span class="k">new</span> <span class="n">SomeFilter</span><span class="p">(</span><span class="n">parameters</span><span class="p">))</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="elementlevelfilter-example-6"><code>ElementLevelFilter</code> Example 6<a hidden class="anchor" aria-hidden="true" href="#elementlevelfilter-example-6">#</a></h3>
<p>The <code>ElementLevelFilter</code> filters elements based on which <strong>level</strong> they belong to:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="c1">// Get all doors on Level 1</span>
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">level1Doors</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">OfCategory</span><span class="p">(</span><span class="n">BuiltInCategory</span><span class="p">.</span><span class="n">OST_Doors</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">WhereElementIsNotElementType</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">WherePasses</span><span class="p">(</span><span class="k">new</span> <span class="n">ElementLevelFilter</span><span class="p">(</span><span class="n">levelId</span><span class="p">))</span>    <span class="c1">// Only elements on this level</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">ToElements</span><span class="p">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>What you need:</strong></p>
<ul>
<li><code>levelId</code> - The ElementId of the specific level you want to filter by</li>
</ul>
<p><strong>How to get a levelId:</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="c1">// Option 1: Find level by name</span>
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">level1</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">OfClass</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">Level</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">Cast</span><span class="p">&lt;</span><span class="n">Level</span><span class="p">&gt;()</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">FirstOrDefault</span><span class="p">(</span><span class="n">l</span> <span class="p">=&gt;</span> <span class="n">l</span><span class="p">.</span><span class="n">Name</span> <span class="p">==</span> <span class="s">&#34;Level 1&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">levelId</span> <span class="p">=</span> <span class="n">level1</span><span class="p">?.</span><span class="n">Id</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Option 2: Get all levels and pick one</span>
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">allLevels</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">OfClass</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">Level</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">ToElements</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">levelId</span> <span class="p">=</span> <span class="n">allLevels</span><span class="p">.</span><span class="n">First</span><span class="p">().</span><span class="n">Id</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="complete-working-example-7">Complete Working Example 7<a hidden class="anchor" aria-hidden="true" href="#complete-working-example-7">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="c1">// Step 1: Get the level we want</span>
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">targetLevel</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">OfClass</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">Level</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">Cast</span><span class="p">&lt;</span><span class="n">Level</span><span class="p">&gt;()</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">FirstOrDefault</span><span class="p">(</span><span class="n">l</span> <span class="p">=&gt;</span> <span class="n">l</span><span class="p">.</span><span class="n">Name</span> <span class="p">==</span> <span class="s">&#34;Level 1&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">targetLevel</span> <span class="p">!=</span> <span class="kc">null</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Step 2: Get all doors on that level</span>
</span></span><span class="line"><span class="cl">    <span class="kt">var</span> <span class="n">level1Doors</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="n">OfCategory</span><span class="p">(</span><span class="n">BuiltInCategory</span><span class="p">.</span><span class="n">OST_Doors</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="n">WhereElementIsNotElementType</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="n">WherePasses</span><span class="p">(</span><span class="k">new</span> <span class="n">ElementLevelFilter</span><span class="p">(</span><span class="n">targetLevel</span><span class="p">.</span><span class="n">Id</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="n">ToElements</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// Now you have only doors that exist on Level 1</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="other-common-custom-filters">Other Common Custom Filters<a hidden class="anchor" aria-hidden="true" href="#other-common-custom-filters">#</a></h3>
<p><strong><code>ElementClassFilter</code></strong> (alternative to <code>.OfClass()</code>):</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="p">.</span><span class="n">WherePasses</span><span class="p">(</span><span class="k">new</span> <span class="n">ElementClassFilter</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">Wall</span><span class="p">)))</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong><code>ElementCategoryFilter</code></strong> (alternative to .<code>OfCategory()</code>):</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="p">.</span><span class="n">WherePasses</span><span class="p">(</span><span class="k">new</span> <span class="n">ElementCategoryFilter</span><span class="p">(</span><span class="n">BuiltInCategory</span><span class="p">.</span><span class="n">OST_Walls</span><span class="p">))</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong><code>LogicalAndFilter</code></strong> (combine multiple filters with <code>AND</code>):</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">filter1</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ElementLevelFilter</span><span class="p">(</span><span class="n">levelId</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">filter2</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ElementCategoryFilter</span><span class="p">(</span><span class="n">BuiltInCategory</span><span class="p">.</span><span class="n">OST_Doors</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">combinedFilter</span> <span class="p">=</span> <span class="k">new</span> <span class="n">LogicalAndFilter</span><span class="p">(</span><span class="n">filter1</span><span class="p">,</span> <span class="n">filter2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">result</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">WhereElementIsNotElementType</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">WherePasses</span><span class="p">(</span><span class="n">combinedFilter</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">ToElements</span><span class="p">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong><code>LogicalOrFilter</code></strong> (combine multiple filters with <code>OR</code>):</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">doorsFilter</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ElementCategoryFilter</span><span class="p">(</span><span class="n">BuiltInCategory</span><span class="p">.</span><span class="n">OST_Doors</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">windowsFilter</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ElementCategoryFilter</span><span class="p">(</span><span class="n">BuiltInCategory</span><span class="p">.</span><span class="n">OST_Windows</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">doorsOrWindows</span> <span class="p">=</span> <span class="k">new</span> <span class="n">LogicalOrFilter</span><span class="p">(</span><span class="n">doorsFilter</span><span class="p">,</span> <span class="n">windowsFilter</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">result</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">WhereElementIsNotElementType</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">WherePasses</span><span class="p">(</span><span class="n">doorsOrWindows</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">ToElements</span><span class="p">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="when-to-use-wherepasses">When to Use <code>.WherePasses()</code><a hidden class="anchor" aria-hidden="true" href="#when-to-use-wherepasses">#</a></h3>
<p><strong>Use <code>.WherePasses()</code> when:</strong></p>
<ul>
<li>Built-in methods (<code>.OfClass()</code>, <code>.OfCategory()</code>) aren&rsquo;t specific enough</li>
<li>You need to filter by <code>level</code>, <code>view</code>, or other specific <code>properties</code></li>
<li>You need to combine multiple filter conditions</li>
<li>You&rsquo;re working with complex filtering logic</li>
</ul>
<p><strong>Stick with <code>built-in</code> methods when:</strong></p>
<ul>
<li>Simple category or class filtering is sufficient</li>
<li>You want cleaner, more readable code</li>
</ul>
<h3 id="performance-tip">Performance Tip<a hidden class="anchor" aria-hidden="true" href="#performance-tip">#</a></h3>
<p>Apply the most restrictive filters first, then use <code>.WherePasses()</code> for fine-tuning:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="c1">// Good: Filter by category first, then by level</span>
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">efficientQuery</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">OfCategory</span><span class="p">(</span><span class="n">BuiltInCategory</span><span class="p">.</span><span class="n">OST_Doors</span><span class="p">)</span>          <span class="c1">// Narrow down first</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">WhereElementIsNotElementType</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">WherePasses</span><span class="p">(</span><span class="k">new</span> <span class="n">ElementLevelFilter</span><span class="p">(</span><span class="n">levelId</span><span class="p">))</span>   <span class="c1">// Fine-tune</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">ToElements</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Less efficient: Custom filter on everything</span>
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">lessEfficientQuery</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">WherePasses</span><span class="p">(</span><span class="k">new</span> <span class="n">ElementLevelFilter</span><span class="p">(</span><span class="n">levelId</span><span class="p">))</span>   <span class="c1">// Filter everything first</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">OfCategory</span><span class="p">(</span><span class="n">BuiltInCategory</span><span class="p">.</span><span class="n">OST_Doors</span><span class="p">)</span>          <span class="c1">// Then narrow down</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">ToElements</span><span class="p">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><hr>
<h2 id="formatting-for-readability">Formatting for Readability<a hidden class="anchor" aria-hidden="true" href="#formatting-for-readability">#</a></h2>
<p>When chaining gets long, format it vertically for better readability:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="c1">// Good formatting - easy to read</span>
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">elements</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">OfClass</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">Wall</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">OfCategory</span><span class="p">(</span><span class="n">BuiltInCategory</span><span class="p">.</span><span class="n">OST_Walls</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">WhereElementIsNotElementType</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">WherePasses</span><span class="p">(</span><span class="n">someFilter</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">ToElements</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Bad formatting - hard to read</span>
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">elements</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">).</span><span class="n">OfClass</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">Wall</span><span class="p">)).</span><span class="n">OfCategory</span><span class="p">(</span><span class="n">BuiltInCategory</span><span class="p">.</span><span class="n">OST_Walls</span><span class="p">).</span><span class="n">WhereElementIsNotElementType</span><span class="p">().</span><span class="n">WherePasses</span><span class="p">(</span><span class="n">someFilter</span><span class="p">).</span><span class="n">ToElements</span><span class="p">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="benefits-of-method-chaining">Benefits of Method Chaining<a hidden class="anchor" aria-hidden="true" href="#benefits-of-method-chaining">#</a></h2>
<ol>
<li><strong>Concise Code</strong>: Less lines, more readable</li>
<li><strong>Fluent Interface</strong>: Reads almost like natural language</li>
<li><strong>Performance</strong>: Can be more efficient (no intermediate variables)</li>
<li><strong>Less Variables</strong>: No need to store intermediate results</li>
</ol>
<h2 id="common-patterns">Common Patterns<a hidden class="anchor" aria-hidden="true" href="#common-patterns">#</a></h2>
<h3 id="pattern-1-filter--refine--collect">Pattern 1: Filter → Refine → Collect<a hidden class="anchor" aria-hidden="true" href="#pattern-1-filter--refine--collect">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">result</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">OfClass</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">SomeClass</span><span class="p">))</span>           <span class="c1">// Filter by class</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">WhereElementIsNotElementType</span><span class="p">()</span>       <span class="c1">// Refine selection</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">ToElements</span><span class="p">();</span>                        <span class="c1">// Collect results</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="pattern-2-category--type--custom-filter">Pattern 2: Category → Type → Custom Filter<a hidden class="anchor" aria-hidden="true" href="#pattern-2-category--type--custom-filter">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">result</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">OfCategory</span><span class="p">(</span><span class="n">BuiltInCategory</span><span class="p">.</span><span class="n">OST_Walls</span><span class="p">)</span>  <span class="c1">// Filter by category</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">WhereElementIsNotElementType</span><span class="p">()</span>         <span class="c1">// Exclude types</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">WherePasses</span><span class="p">(</span><span class="n">customFilter</span><span class="p">)</span>              <span class="c1">// Apply custom filter</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">ToElements</span><span class="p">();</span>                          <span class="c1">// Collect results</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="pattern-3-count-elements">Pattern 3: Count Elements<a hidden class="anchor" aria-hidden="true" href="#pattern-3-count-elements">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">count</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">OfClass</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">Wall</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">WhereElementIsNotElementType</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">GetElementCount</span><span class="p">();</span>  <span class="c1">// Just get the count, not the elements</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="important-notes">Important Notes<a hidden class="anchor" aria-hidden="true" href="#important-notes">#</a></h2>
<ul>
<li><strong>Order Matters</strong>: Apply the most restrictive filters first for better performance</li>
<li><strong>Semicolon</strong>: Don&rsquo;t forget the <code>;</code> at the end of the statement</li>
<li><strong>Line Breaks</strong>: You can break lines anywhere in the chain for readability</li>
<li><strong>Return Types</strong>: Make sure each method returns something the next method can work with</li>
</ul>
<h2 id="practice-exercise">Practice Exercise<a hidden class="anchor" aria-hidden="true" href="#practice-exercise">#</a></h2>
<p>Try converting this non-chained code to use method chaining:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="c1">// Convert this:</span>
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">collector</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">collector</span> <span class="p">=</span> <span class="n">collector</span><span class="p">.</span><span class="n">OfCategory</span><span class="p">(</span><span class="n">BuiltInCategory</span><span class="p">.</span><span class="n">OST_Doors</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">collector</span> <span class="p">=</span> <span class="n">collector</span><span class="p">.</span><span class="n">WhereElementIsNotElementType</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">doorElements</span> <span class="p">=</span> <span class="n">collector</span><span class="p">.</span><span class="n">ToElements</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// To this format:</span>
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">doorElements</span> <span class="p">=</span> <span class="c1">// Your chained solution here</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>Solution:</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">doorElements</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">OfCategory</span><span class="p">(</span><span class="n">BuiltInCategory</span><span class="p">.</span><span class="n">OST_Doors</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">WhereElementIsNotElementType</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">ToElements</span><span class="p">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>Method chaining makes your Revit add-in code cleaner and more professional!</p></blockquote>
<hr>
<h1 id="quick-slow-and-linq-element-filtering"><a href="https://thebuildingcoder.typepad.com/blog/2015/12/quick-slow-and-linq-element-filtering.html">Quick, Slow and LINQ Element Filtering</a><a hidden class="anchor" aria-hidden="true" href="#quick-slow-and-linq-element-filtering">#</a></h1>
<h2 id="introduction">Introduction<a hidden class="anchor" aria-hidden="true" href="#introduction">#</a></h2>
<p>When working with the Revit API, efficient element filtering is crucial for performance. Understanding the differences between quick filters, slow filters, and LINQ approaches can mean the difference between a tool that runs in milliseconds versus one that takes several seconds to minutes, if not hours. This comprehensive guide explores these filtering methods, their performance characteristics, and best practices for optimal results.</p>
<h2 id="the-performance-hierarchy-critical-for-understanding">The Performance Hierarchy: Critical for Understanding<a hidden class="anchor" aria-hidden="true" href="#the-performance-hierarchy-critical-for-understanding">#</a></h2>
<p>Based on extensive benchmarking by Jeremy Tammik (The Building Coder) and other Revit API developers, there&rsquo;s a clear performance hierarchy you must understand:</p>
<p><strong>The Golden Rule:</strong> <em>Revit&rsquo;s <code>built-in</code> filters are at least twice as fast as LINQ-based filtering.</em></p>
<h3 id="performance-rankings-from-real-benchmarks">Performance Rankings from Real Benchmarks<a hidden class="anchor" aria-hidden="true" href="#performance-rankings-from-real-benchmarks">#</a></h3>
<p>From actual performance tests on retrieving specific elements:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="n">Quick</span> <span class="n">Filters</span><span class="p">:</span> <span class="n">Baseline</span> <span class="n">performance</span> <span class="p">(</span><span class="m">100</span><span class="p">%)</span>
</span></span><span class="line"><span class="cl"><span class="n">Slow</span> <span class="n">Filters</span><span class="p">:</span> <span class="p">~</span><span class="m">116</span><span class="p">%</span> <span class="n">of</span> <span class="n">quick</span> <span class="n">filter</span> <span class="n">time</span> <span class="p">(</span><span class="n">still</span> <span class="n">very</span> <span class="n">efficient</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">LINQ</span> <span class="n">Queries</span><span class="p">:</span> <span class="p">~</span><span class="m">128</span><span class="p">-</span><span class="m">153</span><span class="p">%</span> <span class="n">of</span> <span class="n">quick</span> <span class="n">filter</span> <span class="n">time</span>
</span></span><span class="line"><span class="cl"><span class="n">Manual</span> <span class="p">.</span><span class="n">NET</span> <span class="n">Iteration</span><span class="p">:</span> <span class="p">~</span><span class="m">153</span><span class="p">%+</span> <span class="n">of</span> <span class="n">quick</span> <span class="n">filter</span> <span class="n">time</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="understanding-revits-data-architecture">Understanding Revit&rsquo;s Data Architecture<a hidden class="anchor" aria-hidden="true" href="#understanding-revits-data-architecture">#</a></h2>
<p>To grasp why these performance differences exist, you need to understand how Revit stores element data:</p>
<h3 id="element-storage-structure">Element Storage Structure<a hidden class="anchor" aria-hidden="true" href="#element-storage-structure">#</a></h3>
<p>Revit divides element storage into two parts:</p>
<ol>
<li>
<p><strong>Element Header (Record)</strong>: Contains minimal information</p>
<ul>
<li><code>Element ID</code></li>
<li><code>Name</code></li>
<li><code>Category ID</code></li>
<li><code>Type ID</code></li>
<li><code>Basic properties</code> accessible without loading full element</li>
</ul>
</li>
<li>
<p><strong>Element Body</strong>: Contains complete element data</p>
<ul>
<li><code>Geometry</code></li>
<li><code>Parameters</code></li>
<li><code>Detailed properties</code></li>
<li><code>Relationships</code></li>
</ul>
</li>
</ol>
<p>This architecture explains why quick filters are so fast—they operate only on the <code>header data</code> that&rsquo;s always in memory, while slow filters may need to load the complete element information.</p>
<h2 id="why-quick-filters-matter"><strong>Why quick filters matter</strong><a hidden class="anchor" aria-hidden="true" href="#why-quick-filters-matter">#</a></h2>
<p>Revit stores only a small “header” for each element in memory until more details are needed.  A <strong>quick filter</strong> can test an element using this header, so Revit can decide whether the element passes without loading the full element data.  This makes quick filters very efficient.  In contrast, <strong>slow filters</strong> need the full element, so Revit must load and “expand” each element first.</p>
<p>When you use .NET or LINQ to filter, you force Revit to marshal each element’s data into managed memory, so every element is fully expanded before your query runs.  Even if the filter is simple, this marshalling is expensive and can double the execution time.  Benchmarking on the Building Coder blog showed that explicit iteration or LINQ is <strong>over a thousand times slower</strong> than built‑in collector filtering.</p>
<h3 id="efficiency-guidelines"><strong>Efficiency guidelines</strong><a hidden class="anchor" aria-hidden="true" href="#efficiency-guidelines">#</a></h3>
<ul>
<li>
<p><strong>Use quick filters first.</strong>  Because they operate on element headers, quick filters can discard most elements immediately .</p>
</li>
<li>
<p><strong>Apply slow filters next.</strong>  Use them only when necessary to narrow the set further .</p>
</li>
<li>
<p><strong>Avoid .NET/LINQ until the end.</strong>  Only when no built‑in filter can express the condition should you post‑process the results using LINQ .</p>
</li>
</ul>
<h2 id="builtin-filter-types"><strong>Built‑in filter types</strong><a hidden class="anchor" aria-hidden="true" href="#builtin-filter-types">#</a></h2>
<h3 id="logical-filters"><strong>Logical filters</strong><a hidden class="anchor" aria-hidden="true" href="#logical-filters">#</a></h3>
<p>Logical filters let you combine other filters:</p>
<table>
  <thead>
      <tr>
          <th><strong>Filter</strong></th>
          <th><strong>Description</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>LogicalAndFilter</strong></td>
          <td>Combines two or more filters; an element must pass all of them.  You can also call <code>WherePasses</code> on the collector to add another filter or <code>IntersectWith</code> to intersect two independent collector results .</td>
      </tr>
      <tr>
          <td><strong>LogicalOrFilter</strong></td>
          <td>Combines filters so an element only needs to pass one of them.  You can use <code>UnionWith</code> on two collectors to achieve the same result .</td>
      </tr>
  </tbody>
</table>
<h3 id="quick-filters"><strong>Quick filters</strong><a hidden class="anchor" aria-hidden="true" href="#quick-filters">#</a></h3>
<p>Quick filters use the element header and therefore have corresponding “shortcut” methods on FilteredElementCollector.  Using the shortcut makes it obvious you are applying a quick filter.  For example, OfClass(typeof(Wall)) calls an ElementClassFilter internally.  The table below summarizes common quick filters .</p>
<table>
  <thead>
      <tr>
          <th><strong>Filter class</strong></th>
          <th><strong>Shortcut</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>ElementCategoryFilter</code></td>
          <td><code>OfCategoryId</code></td>
      </tr>
      <tr>
          <td><code>ElementClassFilter</code></td>
          <td><code>OfClass</code></td>
      </tr>
      <tr>
          <td><code>ElementIsElementTypeFilter</code></td>
          <td><code>WhereElementIsElementType</code> / <code>WhereElementIsNotElementType</code></td>
      </tr>
      <tr>
          <td><code>ElementOwnerViewFilter</code></td>
          <td><code>OwnedByView</code> / <code>WhereElementIsViewIndependent</code></td>
      </tr>
      <tr>
          <td><code>ElementDesignOptionFilter</code></td>
          <td><code>ContainedInDesignOption</code></td>
      </tr>
      <tr>
          <td><code>ElementIsCurveDrivenFilter</code></td>
          <td><code>WhereElementIsCurveDriven</code></td>
      </tr>
      <tr>
          <td><code>ElementStructuralTypeFilter</code></td>
          <td>—</td>
      </tr>
      <tr>
          <td><code>FamilySymbolFilter</code></td>
          <td>—</td>
      </tr>
      <tr>
          <td><code>ExclusionFilter</code></td>
          <td><code>Excluding</code></td>
      </tr>
      <tr>
          <td><code>BoundingBoxIntersectsFilter</code></td>
          <td>—</td>
      </tr>
      <tr>
          <td><code>BoundingBoxIsInsideFilter</code></td>
          <td>—</td>
      </tr>
      <tr>
          <td><code>BoundingBoxContainsPointFilter</code></td>
          <td>—</td>
      </tr>
  </tbody>
</table>
<h3 id="slow-filters"><strong>Slow filters</strong><a hidden class="anchor" aria-hidden="true" href="#slow-filters">#</a></h3>
<p>Slow filters have no shortcut because they need to load each element.  They are still implemented in native code and therefore faster than <code>.NET</code> post‑processing, but you should try to reduce their use by narrowing the collector first with quick filters. </p>
<p>Common slow filters include:</p>
<table>
  <thead>
      <tr>
          <th>Class</th>
          <th>Description</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>FamilyInstanceFilter</code></td>
          <td>Returns instances of a specific family symbol.</td>
      </tr>
      <tr>
          <td><code>ElementLevelFilter</code></td>
          <td>Elements associated with a given level ID.</td>
      </tr>
      <tr>
          <td>ElementParameterFilter</td>
          <td>Tests whether an element has a parameter or matches a value/range.</td>
      </tr>
      <tr>
          <td>PrimaryDesignOptionMemberFilter</td>
          <td>Returns elements belonging to the primary design option.</td>
      </tr>
      <tr>
          <td>StructuralInstanceUsageFilter</td>
          <td>Filters family instances by structural usage.</td>
      </tr>
      <tr>
          <td>StructuralWallUsageFilter</td>
          <td>Filters walls by structural usage.</td>
      </tr>
      <tr>
          <td>StructuralMaterialTypeFilter</td>
          <td>Filters walls by structural usage.</td>
      </tr>
      <tr>
          <td><code>RoomFilter</code>, <br><code>SpaceFilter</code>, <br><code>AreaFilter</code>, <br><code>tag</code> filters</td>
          <td>Finds rooms, spaces or areas and their tags.</td>
      </tr>
      <tr>
          <td>CurveElementFilter</td>
          <td>Filters specific curve elements (model curves, detail lines, symbolic curves, etc.).</td>
      </tr>
  </tbody>
</table>
<h2 id="linq"><strong><code>LINQ</code> and <code>.NET</code> post‑processing</strong><a hidden class="anchor" aria-hidden="true" href="#linq">#</a></h2>
<p><code>LINQ</code> queries or explicit loops over the <code>FilteredElementCollector</code> run in managed code.  When you use them, Revit has already marshalled each element from its internal database into your add‑in’s memory.  This marshalling costs far more than the filtering itself.  In the original benchmark, Jeremy Tammik measured several ways of retrieving levels.  The results showed that converting the collector results to a generic list (<code>ToList</code>) or using <code>LINQ</code> produced <strong>thousands of times more overhead</strong> than simply applying Revit filters.  There was hardly any difference between writing a manual <code>foreach</code> loop and using a <code>LINQ</code> query—both were similarly <code>slow</code> compared with a native filter.</p>
<h3 id="however-linq-makes-collecting-and-filtering-elements-much-easier-than-slowfilters">However, <code>LINQ</code> makes collecting and filtering elements much easier than <code>SlowFilters</code><a hidden class="anchor" aria-hidden="true" href="#however-linq-makes-collecting-and-filtering-elements-much-easier-than-slowfilters">#</a></h3>
<ul>
<li>J.Tamik estimated them to be twice as slow, however, Gavin Crump rarely noticed their impact on performance.</li>
<li><code>LINQ</code> is provided through the System library and are not specific to the RevitAPI. Look at them like a quick iterations across all items in a list.</li>
</ul>
<h2 id="lambda-function"><code>Lambda</code> Function<a hidden class="anchor" aria-hidden="true" href="#lambda-function">#</a></h2>
<ul>
<li>The <code>Lambda</code> shorthand is crucial to understand.</li>
<li><code>Lambda</code> function acts as a <code>throwaway</code> function that is evaluated, then disposed of.</li>
<li>The <code>=&gt;</code> symbols are used to imply a <code>lambda</code> function, where the left side is the variable to evaluate upon and the right side is the function to evaluate the outcome.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="n">Variable</span> <span class="p">=&gt;</span> <span class="n">Function</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>FilteredELementCollector</code> vs System <code>LINQ</code></p>
<ul>
<li>When using LINQ methods with a filtered element collector, you should use all required <code>Revit API</code> methods before switching over to using LINQ Methods.</li>
</ul>
<p><strong>Common pattern to follow:</strong></p>
<ol>
<li>Make a <code>FilteredElementCollector</code></li>
<li>Filter by <code>.OfClass</code> or <code>.OfCategory</code></li>
<li>Switch to <code>LINQ</code> Method</li>
</ol>
<h3 id="tolist"><code>ToList()</code><a hidden class="anchor" aria-hidden="true" href="#tolist">#</a></h3>
<ul>
<li>When dealing with a <code>FilteredElementCollectors</code>, generally you would finish the collector in the Revit API with a closer such as <code>ToElement()</code>, which would return an <code>IList</code> of Elements.</li>
<li>We finish a chain of LINQ methods in most cases by using the <code>ToList()</code> method.</li>
</ul>
<h3 id="casttype"><code>Cast&lt;type&gt;()</code><a hidden class="anchor" aria-hidden="true" href="#casttype">#</a></h3>
<ul>
<li>When we <code>Cast</code> in C# - we are changing the <code>type</code> of an <code>object</code>.</li>
<li>This is very important when dealing with the <code>Element</code> class, as many things may <code>inherit</code> from it.</li>
</ul>
<p><strong>For example:</strong></p>
<ul>
<li>if we collect all sheets in the model, they are still <code>Element</code> type.</li>
<li>If we wanted to ask for a property unique to the <code>ViewSheet</code> class (e.g. <code>SheetNumber</code>), we would need to <code>Cast</code> those <code>Elements</code> to <code>ViewSheet</code> first.</li>
</ul>
<blockquote>
<blockquote>
<p>When you work with the <code>FilteredElementCollector</code> you are using <code>Elements</code> by default, if we wanted to switch over to <code>Sheets</code> after collecting <code>Sheets</code>, the <code>FiliteredElementCollector</code> won&rsquo;t give you back <code>objects</code> of the <code>Sheet</code> Type, so you have to actually <code>Cast</code> the <code>Object</code> to the <code>Sheet</code> type when you are ready to deal with it as <code>Sheets</code></p></blockquote></blockquote>
<h3 id="distinct"><code>Distinct()</code><a hidden class="anchor" aria-hidden="true" href="#distinct">#</a></h3>
<ul>
<li>If we have a list of objects where we know there may be duplicates that we don&rsquo;t want, we can add this method to remove all duplicate objects.</li>
<li>For example,
<ul>
<li>maybe we want to know all <code>values</code> of a given parameter for a nominated class,</li>
<li>we do not need to know every occurrence of of duplicate values, just that they have occurred,
<ul>
<li>so we can make it <code>distinct</code> before finishing our <code>list</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="selectx--function"><code>Select(x =&gt; function)</code><a hidden class="anchor" aria-hidden="true" href="#selectx--function">#</a></h3>
<ul>
<li>The <code>select()</code> method will evaluate a <code>lambda</code>function for all objects in the current list we are working with,</li>
<li>Note that this may change the type of object being stored in the list,</li>
<li>For example,
<ul>
<li>if we get the parameter values of elements,</li>
<li>we will no longer be dealing with those elements.</li>
</ul>
</li>
</ul>
<h3 id="orderbyx--function"><code>OrderBy(x =&gt; function)</code><a hidden class="anchor" aria-hidden="true" href="#orderbyx--function">#</a></h3>
<ul>
<li>Typically, elements are returned to us by collectors in the order by which they were originally added to the Revit Document (DB).</li>
<li>If we want to reorder them, we can use a lambda function that yields a sortable outcome (typically, must be numeric or alphanumeric in nature).</li>
<li>The original elements will be kept, but now in a sorted order.</li>
</ul>
<h3 id="wherex--function"><code>Where(x =&gt; function)</code><a hidden class="anchor" aria-hidden="true" href="#wherex--function">#</a></h3>
<ul>
<li>This is effectively the <code>LINQ</code> equivalent to WherePasses(),</li>
<li>The <code>lambda</code> function must evaluate to a true or false outcome,
<ul>
<li>where all elements that evaluate as false will be filtered out of the available elements provided before.</li>
</ul>
</li>
<li>An example of this being used is:
<ul>
<li>omitting all placeholder <code>sheets</code> when collecting <code>Sheets</code>.</li>
</ul>
</li>
</ul>
<blockquote>
<blockquote>
<p>Equivalent to <code>List.FiltByBoolMask</code> Node in Dynamo.</p></blockquote></blockquote>
<h2 id="example-1-comparing-quick-and-slow-methods">Example №1: Comparing <code>Quick</code> and <code>Slow</code> Methods<a hidden class="anchor" aria-hidden="true" href="#example-1-comparing-quick-and-slow-methods">#</a></h2>
<h3 id="method-chaining-for-quick--linq-style">Method Chaining for <code>Quick</code> + <code>LINQ</code> Style<a hidden class="anchor" aria-hidden="true" href="#method-chaining-for-quick--linq-style">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">sheets</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">.</span><span class="n">OfClass</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">ViewSheet</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">			<span class="p">.</span><span class="n">Cast</span><span class="p">&lt;</span><span class="n">ViewSheet</span><span class="p">&gt;()</span>
</span></span><span class="line"><span class="cl">			<span class="p">.</span><span class="n">Where</span><span class="p">(</span><span class="n">s</span><span class="p">=&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">IsPlaceholder</span><span class="p">==</span><span class="kc">false</span><span class="p">)</span> <span class="c1">// Where the sheet is not a placeholder</span>
</span></span><span class="line"><span class="cl">			<span class="p">.</span><span class="n">OrderBy</span><span class="p">(</span><span class="n">s</span><span class="p">=&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">SheetNumber</span><span class="p">)</span> <span class="c1">// Order based on Sheet Number</span>
</span></span><span class="line"><span class="cl">			<span class="p">.</span><span class="n">ToList</span><span class="p">();</span> <span class="c1">// Cast them into a list</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><strong>Execution:</strong> Runs mostly in .NET after elements are marshalled from Revit.</li>
<li><strong>Strength:</strong> Very concise and readable.</li>
<li><strong>Weakness:</strong> Potentially slower for large datasets since all elements come into memory first.</li>
</ul>
<p><strong>VS.</strong></p>
<h3 id="slow-wherepasses-method"><code>Slow</code> <code>WherePasses()</code> Method<a hidden class="anchor" aria-hidden="true" href="#slow-wherepasses-method">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="c1">// Build a parameter rule: IsPlaceholder == 0 (false)</span>
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">rule</span> <span class="p">=</span> <span class="n">ParameterFilterRuleFactory</span><span class="p">.</span><span class="n">CreateEqualsRule</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="k">new</span> <span class="n">ElementId</span><span class="p">(</span><span class="n">BuiltInParameter</span><span class="p">.</span><span class="n">VIEWER_SHEET_IS_PLACEHOLDER</span><span class="p">),</span> <span class="m">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">notPlaceholderFilter</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ElementParameterFilter</span><span class="p">(</span><span class="n">rule</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">sheets</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">OfClass</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">ViewSheet</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">WherePasses</span><span class="p">(</span><span class="n">notPlaceholderFilter</span><span class="p">)</span>         <span class="c1">// Revit-side filter</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">Cast</span><span class="p">&lt;</span><span class="n">ViewSheet</span><span class="p">&gt;()</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">OrderBy</span><span class="p">(</span><span class="n">s</span> <span class="p">=&gt;</span> <span class="n">s</span><span class="p">.</span><span class="n">SheetNumber</span><span class="p">)</span>               <span class="c1">// .NET-side sort</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">ToList</span><span class="p">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><strong>Execution:</strong> Filtering happens inside Revit’s engine before elements are marshalled.</li>
<li><strong>Strength:</strong> More scalable for large datasets, avoids bringing all elements into .NET first.</li>
<li><strong>Weakness:</strong> More verbose; less intuitive to read/write than LINQ.</li>
</ul>
<h2 id="example-2-comparing-quick-and-slow-methods">Example №2: Comparing <code>Quick</code> and <code>Slow</code> Methods<a hidden class="anchor" aria-hidden="true" href="#example-2-comparing-quick-and-slow-methods">#</a></h2>
<h3 id="method-chaining-for-quick--linq-style-1">Method Chaining for <code>Quick</code> + <code>LINQ</code> Style<a hidden class="anchor" aria-hidden="true" href="#method-chaining-for-quick--linq-style-1">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">shortWalls</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">OfCategory</span><span class="p">(</span><span class="n">BuiltInCategory</span><span class="p">.</span><span class="n">OST_Walls</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">WhereElementIsNotElementType</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">Cast</span><span class="p">&lt;</span><span class="n">Wall</span><span class="p">&gt;()</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">Where</span><span class="p">(</span><span class="n">w</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">var</span> <span class="n">p</span> <span class="p">=</span> <span class="n">w</span><span class="p">.</span><span class="n">get_Parameter</span><span class="p">(</span><span class="n">BuiltInParameter</span><span class="p">.</span><span class="n">WALL_USER_HEIGHT_PARAM</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">p</span> <span class="p">!=</span> <span class="kc">null</span> <span class="p">&amp;&amp;</span> <span class="n">p</span><span class="p">.</span><span class="n">StorageType</span> <span class="p">==</span> <span class="n">StorageType</span><span class="p">.</span><span class="n">Double</span> <span class="p">&amp;&amp;</span> <span class="n">p</span><span class="p">.</span><span class="n">AsDouble</span><span class="p">()</span> <span class="p">&lt;</span> <span class="m">12.0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">})</span>                                         <span class="c1">// .NET-side filter</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">ToList</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">TaskDialog</span><span class="p">.</span><span class="n">Show</span><span class="p">(</span><span class="n">doc</span><span class="p">.</span><span class="n">Title</span><span class="p">,</span> <span class="s">$&#34;We have {shortWalls.Count} walls &lt; 12 ft.&#34;</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>VS.</strong></p>
<h3 id="slow-wherepasses-method-1"><code>Slow</code> <code>WherePasses()</code> Method<a hidden class="anchor" aria-hidden="true" href="#slow-wherepasses-method-1">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">parameterId</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ElementId</span><span class="p">(</span><span class="n">BuiltInParameter</span><span class="p">.</span><span class="n">WALL_USER_HEIGHT_PARAM</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">heightRule</span> <span class="p">=</span> <span class="n">ParameterFilterRuleFactory</span><span class="p">.</span><span class="n">CreateLessRule</span><span class="p">(</span><span class="n">parameterId</span><span class="p">,</span> <span class="m">12.0</span><span class="p">,</span> <span class="m">0.1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">heightFilter</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ElementParameterFilter</span><span class="p">(</span><span class="n">heightRule</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">shortWalls</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">OfCategory</span><span class="p">(</span><span class="n">BuiltInCategory</span><span class="p">.</span><span class="n">OST_Walls</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">WhereElementIsNotElementType</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">WherePasses</span><span class="p">(</span><span class="n">heightFilter</span><span class="p">)</span>                 <span class="c1">// Revit-side filter</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">ToElements</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">TaskDialog</span><span class="p">.</span><span class="n">Show</span><span class="p">(</span><span class="n">doc</span><span class="p">.</span><span class="n">Title</span><span class="p">,</span> <span class="s">$&#34;We have {shortWalls.Count} walls &lt; 12 ft.&#34;</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p><strong>TL;DR:</strong> use <code>WherePasses()</code> when filtering by parameters on big sets (faster); use <code>LINQ</code> for quick scripts or when the set is already small. Sorting generally happens in <code>LINQ</code> after you’ve done the heavy lifting with native filters.</p></blockquote>
<h2 id="parameter-filters-vs-linq-when-filtering-by-property-values"><strong>Parameter filters vs. LINQ when filtering by property values</strong><a hidden class="anchor" aria-hidden="true" href="#parameter-filters-vs-linq-when-filtering-by-property-values">#</a></h2>
<p>A common case is filtering by a parameter value (e.g., family name).  Developers often write a LINQ query like:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">result</span> <span class="p">=</span> <span class="n">collect</span>
</span></span><span class="line"><span class="cl">  <span class="p">.</span><span class="n">OfClass</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">FamilyInstance</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="p">.</span><span class="n">Where</span><span class="p">(</span><span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span><span class="p">.</span><span class="n">get_Parameter</span><span class="p">(</span><span class="n">BuiltInParameter</span><span class="p">.</span><span class="n">ELEM_FAMILY_PARAM</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">               <span class="p">.</span><span class="n">AsValueString</span><span class="p">()</span> <span class="p">==</span> <span class="n">sectionName</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>Although this works, the query runs in .NET, so Revit marshals every <code>FamilyInstance</code> into memory first.  Jeremy Tammik points out that this is <strong>even slower than a slow filter</strong>.  Instead, you can turn the LINQ query into a parameter filter and let Revit perform the comparison natively.  Implementing a parameter filter requires creating a <code>ParameterValueProvider</code>, a <code>FilterRule</code> (e.g., <code>FilterStringRule</code> or using <code>ParameterFilterRuleFactory.CreateEqualsRule</code>) and then applying an <code>ElementParameterFilter</code>.</p></blockquote>
<p>The 2019 article <a href="https://thebuildingcoder.typepad.com/blog/2019/04/slow-slower-still-and-faster-filtering.html"><strong>Slow, Slower Still and Faster Filtering</strong></a> shows how to implement this.  It provides two LINQ examples and two parameter filter examples for retrieving a family symbol by name;</p>
<ul>
<li>The parameter filter versions avoid marshalling and are an order of magnitude faster. </li>
<li>The lesson is: when filtering on parameter values, <strong>always try to use <code>ElementParameterFilter</code> instead of <code>LINQ</code></strong>.</li>
</ul>
<h2 id="collector-optimization-tips"><strong>Collector optimization tips</strong><a hidden class="anchor" aria-hidden="true" href="#collector-optimization-tips">#</a></h2>
<p>Jeremy Tammik also provides general optimization tips in his <a href="https://thebuildingcoder.typepad.com/blog/2012/09/findelement-and-collector-optimisation.html">FindElement and Collector Optimisation post</a>.  Key points include:</p>
<ul>
<li>
<p><strong>Avoid language‑dependent names.</strong>  Wherever possible, identify elements by <code>ID</code>, <code>category</code> or <code>type</code> rather than name .</p>
</li>
<li>
<p><strong>Use parameter filters instead of LINQ.</strong>  Replacing a LINQ query with a <code>parameter filter</code> often <strong>halves execution time</strong> because marshalling to .NET is eliminated .</p>
</li>
<li>
<p><strong>Avoid unnecessary conversions.</strong>  A <code>FilteredElementCollector</code> already implements <code>IEnumerable&lt;Element&gt;</code>, so there is usually no need to convert it to <code>IEnumerable</code> or <code>IList&lt;Element&gt;</code> .  Instantiating additional lists duplicates data and slows performance.</p>
</li>
<li>
<p><strong>Use the collector’s built‑in filters for categories and classes.</strong>  For example, to find door family symbols you can chain:</p>
<ul>
<li><code>.OfCategory(BuiltInCategory.OST_Doors).OfClass(typeof(FamilySymbol)) </code></li>
<li>and then iterate over the collector directly. This is shorter and faster than iterating over all family symbols and checking their category names.</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="c1">// Get all Door family symbols directly</span>
</span></span><span class="line"><span class="cl"><span class="n">FilteredElementCollector</span> <span class="n">collector</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	    <span class="p">.</span><span class="n">OfCategory</span><span class="p">(</span><span class="n">BuiltInCategory</span><span class="p">.</span><span class="n">OST_Doors</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	    <span class="p">.</span><span class="n">OfClass</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">FamilySymbol</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">foreach</span> <span class="p">(</span><span class="n">FamilySymbol</span> <span class="n">doorSymbol</span> <span class="k">in</span> <span class="n">collector</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Do something with each door symbol</span>
</span></span><span class="line"><span class="cl">    <span class="n">TaskDialog</span><span class="p">.</span><span class="n">Show</span><span class="p">(</span><span class="s">&#34;Door Symbol&#34;</span><span class="p">,</span> <span class="n">doorSymbol</span><span class="p">.</span><span class="n">Name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="why-this-is-better"><strong>Why this is better</strong><a hidden class="anchor" aria-hidden="true" href="#why-this-is-better">#</a></h3>
<ul>
<li>
<p><strong>Shorter:</strong> No need to fetch all family symbols first and then check their categories manually.</p>
</li>
<li>
<p><strong>Faster:</strong> Filtering happens natively inside Revit before elements are wrapped into .NET objects, so you avoid the overhead of LINQ or extra if conditions in C#.</p>
</li>
</ul>
<p>If you wanted to collect <strong>instances</strong> instead of symbols, you’d just swap FamilySymbol for FamilyInstance in the loop:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="k">foreach</span> <span class="p">(</span><span class="n">FamilyInstance</span> <span class="n">doorInstance</span> <span class="k">in</span> <span class="n">collector</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Work with each door instance</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><hr>
<h3 id="1-fast-native-filters-iterate-collector-directly"><strong>1) Fast (native filters, iterate collector directly)</strong><a hidden class="anchor" aria-hidden="true" href="#1-fast-native-filters-iterate-collector-directly">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="c1">// Fast: everything done natively inside Revit before .NET sees it</span>
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">symbols</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">OfCategory</span><span class="p">(</span><span class="n">BuiltInCategory</span><span class="p">.</span><span class="n">OST_Doors</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">OfClass</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">FamilySymbol</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">foreach</span> <span class="p">(</span><span class="n">FamilySymbol</span> <span class="n">sym</span> <span class="k">in</span> <span class="n">symbols</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// use sym</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="2-fast-native--parameter-filter-for-a-specific-name"><strong>2) Fast (native + parameter filter for a specific name)</strong><a hidden class="anchor" aria-hidden="true" href="#2-fast-native--parameter-filter-for-a-specific-name">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="c1">// Fast and precise: still native, avoids LINQ post-processing</span>
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">doorName</span> <span class="p">=</span> <span class="s">&#34;Single-Flush&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">byName</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">OfCategory</span><span class="p">(</span><span class="n">BuiltInCategory</span><span class="p">.</span><span class="n">OST_Doors</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">OfClass</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">FamilySymbol</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">WherePasses</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="k">new</span> <span class="n">ElementParameterFilter</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">ParameterFilterRuleFactory</span><span class="p">.</span><span class="n">CreateEqualsRule</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">                <span class="k">new</span> <span class="n">ElementId</span><span class="p">(</span><span class="n">BuiltInParameter</span><span class="p">.</span><span class="n">SYMBOL_NAME_PARAM</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">                <span class="n">doorName</span><span class="p">,</span> <span class="cm">/* caseSensitive */</span> <span class="kc">true</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">foreach</span> <span class="p">(</span><span class="n">FamilySymbol</span> <span class="n">sym</span> <span class="k">in</span> <span class="n">byName</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// use sym</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="3-slower-native-filter--linq-post-processing"><strong>3) Slower (native filter + LINQ post-processing)</strong><a hidden class="anchor" aria-hidden="true" href="#3-slower-native-filter--linq-post-processing">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="c1">// Slower: brings elements into .NET and then filters with LINQ</span>
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">withLinq</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">OfCategory</span><span class="p">(</span><span class="n">BuiltInCategory</span><span class="p">.</span><span class="n">OST_Doors</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">OfClass</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">FamilySymbol</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">Where</span><span class="p">(</span><span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span><span class="p">.</span><span class="n">Name</span> <span class="p">==</span> <span class="s">&#34;Single-Flush&#34;</span><span class="p">);</span> <span class="c1">// LINQ post-filter</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">foreach</span> <span class="p">(</span><span class="n">FamilySymbol</span> <span class="n">sym</span> <span class="k">in</span> <span class="n">withLinq</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// use sym</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="4-slowest-no-native-category-filter-linq-checks-everything"><strong>4) Slowest (no native category filter, LINQ checks everything)</strong><a hidden class="anchor" aria-hidden="true" href="#4-slowest-no-native-category-filter-linq-checks-everything">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="c1">// Slowest: iterates all symbols, checks category/name in managed code</span>
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">allSymbols</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">OfClass</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">FamilySymbol</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">foreach</span> <span class="p">(</span><span class="n">FamilySymbol</span> <span class="n">sym</span> <span class="k">in</span> <span class="n">allSymbols</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">var</span> <span class="n">cat</span> <span class="p">=</span> <span class="n">sym</span><span class="p">.</span><span class="n">Category</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">cat</span> <span class="p">!=</span> <span class="kc">null</span> <span class="p">&amp;&amp;</span> <span class="n">cat</span><span class="p">.</span><span class="n">Id</span><span class="p">.</span><span class="n">IntegerValue</span> <span class="p">==</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">BuiltInCategory</span><span class="p">.</span><span class="n">OST_Doors</span>
</span></span><span class="line"><span class="cl">        <span class="p">&amp;&amp;</span> <span class="n">sym</span><span class="p">.</span><span class="n">Name</span> <span class="p">==</span> <span class="s">&#34;Single-Flush&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// use sym</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="why-1-and-2-win"><strong>Why #1 and #2 win</strong><a hidden class="anchor" aria-hidden="true" href="#why-1-and-2-win">#</a></h2>
<ul>
<li>Revit filters run in native code and trim the search set <strong>before</strong> elements are marshalled into .NET.</li>
<li>LINQ (and manual if checks) happen after marshaling—extra overhead you don’t want unless you must.</li>
</ul>
<hr>
<h2 id="quick-micro-benchmark-scaffolding-optional-for-demos"><strong>Quick micro-benchmark scaffolding (optional for demos)</strong><a hidden class="anchor" aria-hidden="true" href="#quick-micro-benchmark-scaffolding-optional-for-demos">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="k">using</span> <span class="nn">System.Diagnostics</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">static</span> <span class="n">TimeSpan</span> <span class="n">TimeIt</span><span class="p">(</span><span class="n">Action</span> <span class="n">action</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">var</span> <span class="n">sw</span> <span class="p">=</span> <span class="n">Stopwatch</span><span class="p">.</span><span class="n">StartNew</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">action</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">sw</span><span class="p">.</span><span class="n">Stop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">sw</span><span class="p">.</span><span class="n">Elapsed</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Example use:</span>
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">tFast</span> <span class="p">=</span> <span class="n">TimeIt</span><span class="p">(()</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">foreach</span> <span class="p">(</span><span class="n">FamilySymbol</span> <span class="n">_</span> <span class="k">in</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="n">OfCategory</span><span class="p">(</span><span class="n">BuiltInCategory</span><span class="p">.</span><span class="n">OST_Doors</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="n">OfClass</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">FamilySymbol</span><span class="p">)))</span> <span class="p">{</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">tLinq</span> <span class="p">=</span> <span class="n">TimeIt</span><span class="p">(()</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">foreach</span> <span class="p">(</span><span class="n">FamilySymbol</span> <span class="n">_</span> <span class="k">in</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="n">OfCategory</span><span class="p">(</span><span class="n">BuiltInCategory</span><span class="p">.</span><span class="n">OST_Doors</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="n">OfClass</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">FamilySymbol</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="n">Where</span><span class="p">(</span><span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span><span class="p">.</span><span class="n">Name</span> <span class="p">==</span> <span class="s">&#34;Single-Flush&#34;</span><span class="p">))</span> <span class="p">{</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Show results</span>
</span></span><span class="line"><span class="cl"><span class="n">TaskDialog</span><span class="p">.</span><span class="n">Show</span><span class="p">(</span><span class="s">&#34;Timing&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s">$&#34;Native: {tFast.TotalMilliseconds:F1} ms\nLINQ: {tLinq.TotalMilliseconds:F1} ms&#34;</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><hr>
<h2 id="practical-tips"><strong>Practical tips</strong><a hidden class="anchor" aria-hidden="true" href="#practical-tips">#</a></h2>
<ul>
<li>
<p>Prefer <code>.WherePasses(new ElementParameterFilter(...))</code> to check parameter values; avoid <code>AsValueString()</code> for comparisons—use <code>AsString()</code> (for text) or typed getters (<code>AsInteger()</code>, etc.).</p>
</li>
<li>
<p>Chain <strong>quick</strong> filters first (<code>OfCategory</code>, <code>OfClass</code>, <code>WhereElementIsNotElementType</code>).</p>
</li>
<li>
<p>Add <strong>slow</strong> filters only when needed (e.g., <code>ElementParameterFilter</code>, <code>ElementLevelFilter</code>).</p>
</li>
<li>
<p>Iterate the collector directly; don’t call <code>.ToElements()</code> / <code>.ToList()</code> unless you truly need a materialized list.</p>
</li>
<li>
<p>If you’ll delete/modify elements found, capture <code>IDs</code> first and dispose the collector:</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="kt">var</span> <span class="n">ids</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">OfCategory</span><span class="p">(</span><span class="n">BuiltInCategory</span><span class="p">.</span><span class="n">OST_Doors</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">ToElementIds</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="c1">// collector eligible for GC now; safe to delete in a loop over ids</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Following these guidelines will yield dramatic performance improvements when writing Revit add‑ins.  Even though the original blog post dates from 2015, later posts and benchmarks confirm that using Revit’s native filtering API—quick or slow—always beats LINQ or explicit iteration in both simplicity and speed.  By designing your search around built‑in filters and using parameter filters for value comparisons, you can make your tools scale to very large projects.</p>
<hr>
<h1 id="collector-methods-and-extensions">Collector methods and Extensions<a hidden class="anchor" aria-hidden="true" href="#collector-methods-and-extensions">#</a></h1>
<ul>
<li>When developing common collectors that you will use in many commands or just generally, you should develop <code>methods</code> that can be called-on versus writing the full collector each time.</li>
<li>Given collectors always begin from a <code>Document</code>, is also makes sense to develop these methods as <code>Extension Methods</code> for the <code>Document</code> class versus containing them in a <code>static</code> class.</li>
</ul>
<hr>
<h1 id="overloading-methods-polymorphism">Overloading Methods (Polymorphism)<a hidden class="anchor" aria-hidden="true" href="#overloading-methods-polymorphism">#</a></h1>
<ul>
<li>We can also provide multiple argument structures for methods with the same name:</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="n">doc</span><span class="p">.</span><span class="n">Ext_Collector</span><span class="p">();</span>     <span class="c1">// Which provides FilteredElementCollector()</span>
</span></span><span class="line"><span class="cl"><span class="n">doc</span><span class="p">.</span><span class="n">Ext_Collector</span><span class="p">(</span><span class="n">view</span><span class="p">);</span> <span class="c1">// Which provides another collector that we built</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>Can co-exist side-by-side as extension methods.</li>
</ul>
<hr>
<h1 id="homework-1">Homework №1<a hidden class="anchor" aria-hidden="true" href="#homework-1">#</a></h1>
<ul>
<li>Create a basic wall collector</li>
<li>Create a <code>WherePasses()</code> condition</li>
<li>Test your code</li>
</ul>
<h1 id="solution">Solution<a hidden class="anchor" aria-hidden="true" href="#solution">#</a></h1>
<h2 id="project-solution"><code>Project Solution</code><a hidden class="anchor" aria-hidden="true" href="#project-solution">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">Solution
</span></span><span class="line"><span class="cl"><span class="p">|</span>-&gt; guRoo
</span></span><span class="line"><span class="cl">	<span class="p">|</span>-&gt; Dependencies
</span></span><span class="line"><span class="cl">	<span class="p">|</span>-&gt; Commands
</span></span><span class="line"><span class="cl">		<span class="p">|</span>-&gt; General 
</span></span><span class="line"><span class="cl">			<span class="p">|</span>-&gt; Cmds_PushButton.cs  <span class="c1"># Rename &amp; Update</span>
</span></span><span class="line"><span class="cl">			<span class="p">|</span>-&gt; Cmds_PullDown.cs  
</span></span><span class="line"><span class="cl">			<span class="p">|</span>-&gt; Cmds_Stack1.cs 
</span></span><span class="line"><span class="cl">			<span class="p">|</span>-&gt; Cmds_Stack2.cs 
</span></span><span class="line"><span class="cl">			<span class="p">|</span>-&gt; Cmds_Stack3.cs 
</span></span><span class="line"><span class="cl">	<span class="p">|</span>-&gt; Forms
</span></span><span class="line"><span class="cl">	<span class="p">|</span>-&gt; General 
</span></span><span class="line"><span class="cl">	<span class="p">|</span>-&gt; Extensions 
</span></span><span class="line"><span class="cl">	<span class="p">|</span>-&gt; Resources
</span></span><span class="line"><span class="cl">	<span class="p">|</span>-&gt; Utilities
</span></span><span class="line"><span class="cl">	<span class="p">|</span>-&gt; Application.cs           
</span></span><span class="line"><span class="cl">	<span class="p">|</span>-&gt; guRoo.addin
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="cmds_pushbuttoncs"><code>Cmds_PushButton.cs</code><a hidden class="anchor" aria-hidden="true" href="#cmds_pushbuttoncs">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="c1">// Autodesk</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="nn">Autodesk.Revit.Attributes</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="nn">Autodesk.Revit.UI</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Associate with PushButton Commands</span>
</span></span><span class="line"><span class="cl"><span class="k">namespace</span> <span class="nn">guRoo.Cmds_PushButton</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cs">/// &lt;summary&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="cs">///		Example Command</span>
</span></span><span class="line"><span class="cl">    <span class="cs">/// &lt;/summary&gt;</span>
</span></span><span class="line"><span class="cl"><span class="na">    [Transaction(TransactionMode.Manual)]</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="k">class</span> <span class="nc">Cmd_Test</span> <span class="p">:</span> <span class="n">IExternalCommand</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kd">public</span> <span class="n">Result</span> <span class="n">Execute</span><span class="p">(</span><span class="n">ExternalCommandData</span> <span class="n">CommandData</span><span class="p">,</span> <span class="k">ref</span> <span class="kt">string</span> <span class="n">message</span><span class="p">,</span> <span class="n">ElementSet</span> <span class="n">elements</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// Collect the Document and Application objects from the CommandData</span>
</span></span><span class="line"><span class="cl">            <span class="kt">var</span> <span class="n">uiApp</span> <span class="p">=</span> <span class="n">CommandData</span><span class="p">.</span><span class="n">Application</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="kt">var</span> <span class="n">uiDoc</span> <span class="p">=</span> <span class="n">uiApp</span><span class="p">.</span><span class="n">ActiveUIDocument</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="kt">var</span> <span class="n">doc</span> <span class="p">=</span> <span class="n">uiDoc</span><span class="p">.</span><span class="n">Document</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// Collect all walls</span>
</span></span><span class="line"><span class="cl">            <span class="kt">var</span> <span class="n">walls</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">.</span><span class="n">OfClass</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">Wall</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                <span class="p">.</span><span class="n">WhereElementIsNotElementType</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">                <span class="p">.</span><span class="n">ToElements</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// Show the message dialog with the document title</span>
</span></span><span class="line"><span class="cl">            <span class="n">TaskDialog</span><span class="p">.</span><span class="n">Show</span><span class="p">(</span> <span class="n">doc</span><span class="p">.</span><span class="n">Title</span><span class="p">,</span> <span class="s">$&#34;We have {walls.Count} walls in the model&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// Collect all walls lower than 12 feet</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// First: Construct a filter for .WherePasses() Method</span>
</span></span><span class="line"><span class="cl">            <span class="kt">var</span> <span class="n">parameterId</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ElementId</span><span class="p">(</span><span class="n">BuiltInParameter</span><span class="p">.</span><span class="n">WALL_USER_HEIGHT_PARAM</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="kt">var</span> <span class="n">provider</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ParameterValueProvider</span><span class="p">(</span><span class="n">parameterId</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="kt">var</span> <span class="n">rule</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilterNumericLess</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="kt">var</span> <span class="n">passesRule</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilterDoubleRule</span><span class="p">(</span><span class="n">provider</span><span class="p">,</span> <span class="n">rule</span><span class="p">,</span> <span class="m">12</span><span class="p">,</span> <span class="m">0.1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="kt">var</span> <span class="n">paramFilter</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ElementParameterFilter</span><span class="p">(</span><span class="n">passesRule</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// Then: Apply the filter to the FilteredElementCollector</span>
</span></span><span class="line"><span class="cl">            <span class="kt">var</span> <span class="n">wallsFiltered</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">.</span><span class="n">OfCategory</span><span class="p">(</span><span class="n">BuiltInCategory</span><span class="p">.</span><span class="n">OST_Walls</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">.</span><span class="n">WhereElementIsNotElementType</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">                <span class="p">.</span><span class="n">WherePasses</span><span class="p">(</span><span class="n">paramFilter</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">.</span><span class="n">ToElements</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// Show the message dialog with the document title</span>
</span></span><span class="line"><span class="cl">            <span class="n">TaskDialog</span><span class="p">.</span><span class="n">Show</span><span class="p">(</span><span class="n">doc</span><span class="p">.</span><span class="n">Title</span><span class="p">,</span> <span class="s">$&#34;We have {wallsFiltered.Count} walls less than 12 feet in the model&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// Final return here:</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">Result</span><span class="p">.</span><span class="n">Succeeded</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="homework-2">Homework №2<a hidden class="anchor" aria-hidden="true" href="#homework-2">#</a></h1>
<ul>
<li>Create a <code>Document</code> extension class</li>
<li>Create basic <code>collector</code> method</li>
<li>Create a <code>sheet</code> collector</li>
<li>Cerate a <code>revision</code> collector</li>
</ul>
<h1 id="solution-1">Solution<a hidden class="anchor" aria-hidden="true" href="#solution-1">#</a></h1>
<h2 id="project-solution-1"><code>Project Solution</code><a hidden class="anchor" aria-hidden="true" href="#project-solution-1">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">Solution
</span></span><span class="line"><span class="cl"><span class="p">|</span>-&gt; guRoo
</span></span><span class="line"><span class="cl">	<span class="p">|</span>-&gt; Dependencies
</span></span><span class="line"><span class="cl">	<span class="p">|</span>-&gt; Commands
</span></span><span class="line"><span class="cl">		<span class="p">|</span>-&gt; General 
</span></span><span class="line"><span class="cl">			<span class="p">|</span>-&gt; Cmds_PushButton.cs  <span class="c1"># Update to implement new ext .cs </span>
</span></span><span class="line"><span class="cl">	<span class="p">|</span>-&gt; Forms
</span></span><span class="line"><span class="cl">	<span class="p">|</span>-&gt; General 
</span></span><span class="line"><span class="cl">	<span class="p">|</span>-&gt; Extensions 
</span></span><span class="line"><span class="cl">		<span class="p">|</span>-&gt; Document_Ext.cs <span class="c1"># Create a new extension class </span>
</span></span><span class="line"><span class="cl">	<span class="p">|</span>-&gt; Resources
</span></span><span class="line"><span class="cl">	<span class="p">|</span>-&gt; Utilities
</span></span><span class="line"><span class="cl">	<span class="p">|</span>-&gt; Application.cs           
</span></span><span class="line"><span class="cl">	<span class="p">|</span>-&gt; guRoo.addin
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="document_extcs"><code>Document_Ext.cs</code><a hidden class="anchor" aria-hidden="true" href="#document_extcs">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span><span class="lnt">93
</span><span class="lnt">94
</span><span class="lnt">95
</span><span class="lnt">96
</span><span class="lnt">97
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="nn">System.Collections.Generic</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="nn">System.Linq</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="nn">System.Text</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="nn">System.Threading.Tasks</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">namespace</span> <span class="nn">guRoo.Extensions</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">public</span> <span class="kd">static</span> <span class="k">class</span> <span class="nc">Document_Ext</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="cs">/// &lt;summary&gt;</span>
</span></span><span class="line"><span class="cl">		<span class="cs">/// </span>
</span></span><span class="line"><span class="cl">		<span class="cs">/// &lt;/summary&gt;</span>
</span></span><span class="line"><span class="cl">		<span class="cs">/// &lt;param name=&#34;doc&#34;&gt;&lt;/param&gt;</span>
</span></span><span class="line"><span class="cl">		<span class="cs">/// &lt;return&gt;&lt;/return&gt;</span>
</span></span><span class="line"><span class="cl">		<span class="kd">public</span> <span class="kd">static</span> <span class="n">FilteredElementCollector</span> <span class="n">Ext_Collector</span><span class="p">(</span><span class="k">this</span> <span class="n">Document</span> <span class="n">doc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="cs">/// &lt;summary&gt;</span>
</span></span><span class="line"><span class="cl">		<span class="cs">/// Construct a new FilteredElementCollector</span>
</span></span><span class="line"><span class="cl">		<span class="cs">/// &lt;/summary&gt;</span>
</span></span><span class="line"><span class="cl">		<span class="cs">/// &lt;param name=&#34;doc&#34;&gt;The document (extended)&lt;/param&gt;</span>
</span></span><span class="line"><span class="cl">		<span class="cs">/// &lt;param name=&#34;view&#34;&gt;The view to collect elements from&lt;/param&gt;</span>
</span></span><span class="line"><span class="cl">		<span class="cs">/// &lt;return&gt;&lt;/return&gt;</span>
</span></span><span class="line"><span class="cl">		<span class="kd">public</span> <span class="kd">static</span> <span class="n">FilteredElementCollector</span> <span class="n">Ext_Collector</span><span class="p">(</span><span class="k">this</span> <span class="n">Document</span> <span class="n">doc</span><span class="p">,</span> <span class="n">View</span> <span class="n">view</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="n">view</span><span class="p">.</span><span class="n">Id</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="cs">/// &lt;summary&gt;</span>
</span></span><span class="line"><span class="cl">		<span class="cs">/// Collecting sheets</span>
</span></span><span class="line"><span class="cl">		<span class="cs">/// &lt;/summary&gt;</span>
</span></span><span class="line"><span class="cl">		<span class="cs">/// &lt;param name=&#34;doc&#34;&gt;&lt;/param&gt;</span>
</span></span><span class="line"><span class="cl">		<span class="cs">/// &lt;param name=&#34;sorted&#34;&gt;&lt;/param&gt;</span>
</span></span><span class="line"><span class="cl">		<span class="cs">/// &lt;param name=&#34;includePlaceholders&#34;&gt;&lt;/param&gt;</span>
</span></span><span class="line"><span class="cl">		<span class="cs">/// &lt;return&gt;&lt;/return&gt;</span>
</span></span><span class="line"><span class="cl">		<span class="kd">public</span> <span class="kd">static</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">ViewSheet</span><span class="p">&gt;</span> <span class="n">Ext_GetSheets</span><span class="p">(</span><span class="k">this</span> <span class="n">Document</span> <span class="n">doc</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">sorted</span> <span class="kc">true</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">includePlaceholder</span> <span class="p">=</span> <span class="kc">false</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// Collect our sheets</span>
</span></span><span class="line"><span class="cl">			<span class="kt">var</span> <span class="n">sheets</span> <span class="p">=</span> <span class="n">doc</span><span class="p">.</span><span class="n">Ext_Collector</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">				<span class="p">.</span><span class="n">OfClass</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">ViewSheet</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">				<span class="p">.</span><span class="n">Cast</span><span class="p">&lt;</span><span class="n">ViewSheet</span><span class="p">&gt;()</span>
</span></span><span class="line"><span class="cl">				<span class="p">.</span><span class="n">ToList</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">			
</span></span><span class="line"><span class="cl">			<span class="c1">// Fileter out placeholders if desired</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">(!</span><span class="n">includePlaceholders</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="n">sheets</span> <span class="p">=</span> <span class="n">sheets</span>
</span></span><span class="line"><span class="cl">					<span class="p">.</span><span class="n">Where</span><span class="p">(</span><span class="n">s</span> <span class="p">=&gt;</span> <span class="p">!</span><span class="n">s</span><span class="p">.</span><span class="n">IsPlaceholder</span><span class="p">)</span> <span class="c1">// is the sheet is placeholder, reverse it (if the sheet is not a placeholder, the lambda would return &#34;true&#34;. and non-placeholder sheets would &#34;continue&#34; forward)</span>
</span></span><span class="line"><span class="cl">					<span class="p">.</span><span class="n">ToList</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			
</span></span><span class="line"><span class="cl">			<span class="c1">// Return elements, optional sorting</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">(</span><span class="n">sorted</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">return</span> <span class="n">sheets</span>
</span></span><span class="line"><span class="cl">					<span class="p">.</span><span class="n">OrderBy</span><span class="p">(</span><span class="n">s</span> <span class="p">=&gt;</span> <span class="n">s</span><span class="p">.</span><span class="n">SheetNumber</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">					<span class="p">.</span><span class="n">ToList</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="k">else</span>
</span></span><span class="line"><span class="cl">			<span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">return</span> <span class="n">sheets</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		
</span></span><span class="line"><span class="cl">		<span class="cs">/// &lt;summary&gt;</span>
</span></span><span class="line"><span class="cl">		<span class="cs">/// Collecting revisions</span>
</span></span><span class="line"><span class="cl">		<span class="cs">/// &lt;/summary&gt;</span>
</span></span><span class="line"><span class="cl">		<span class="cs">/// &lt;param name=&#34;doc&#34;&gt;&lt;/param&gt;</span>
</span></span><span class="line"><span class="cl">		<span class="cs">/// &lt;param name=&#34;sorted&#34;&gt;&lt;/param&gt;</span>
</span></span><span class="line"><span class="cl">		<span class="cs">/// &lt;param name=&#34;includePlaceholders&#34;&gt;&lt;/param&gt;</span>
</span></span><span class="line"><span class="cl">		<span class="cs">/// &lt;return&gt;&lt;/return&gt;</span>
</span></span><span class="line"><span class="cl">		<span class="kd">public</span> <span class="kd">static</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Revisions</span><span class="p">&gt;</span> <span class="n">Ext_GetRevisions</span><span class="p">(</span><span class="k">this</span> <span class="n">Document</span> <span class="n">doc</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">sorted</span> <span class="kc">true</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// Collect our revisions</span>
</span></span><span class="line"><span class="cl">			<span class="kt">var</span> <span class="n">revisions</span> <span class="p">=</span> <span class="n">doc</span><span class="p">.</span><span class="n">Ext_Collector</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">				<span class="p">.</span><span class="n">OfClass</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">Revision</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">				<span class="p">.</span><span class="n">Cast</span><span class="p">&lt;</span><span class="n">Revision</span><span class="p">&gt;()</span>
</span></span><span class="line"><span class="cl">				<span class="p">.</span><span class="n">ToList</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">			
</span></span><span class="line"><span class="cl">			<span class="c1">// Return elements, optional sorting</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">(</span><span class="n">sorted</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">return</span> <span class="n">revisions</span>
</span></span><span class="line"><span class="cl">					<span class="p">.</span><span class="n">OrderBy</span><span class="p">(</span><span class="n">r</span> <span class="p">=&gt;</span> <span class="n">r</span><span class="p">.</span><span class="n">SequenceNumber</span><span class="p">)</span> <span class="c1">// this is an element property that&#39;s accessible through Casting only, if we didn&#39;t Cast&lt;Revision&gt; earlier we wouldn&#39;t have access to Revision propeties.</span>
</span></span><span class="line"><span class="cl">					<span class="p">.</span><span class="n">ToList</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="k">else</span>
</span></span><span class="line"><span class="cl">			<span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">return</span> <span class="n">revisions</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="cmds_buttoncs"><code>Cmds_Button.cs</code><a hidden class="anchor" aria-hidden="true" href="#cmds_buttoncs">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="c1">// Autodesk</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="nn">Autodesk.Revit.Attributes</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="nn">Autodesk.Revit.UI</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Associate with PushButton Commands</span>
</span></span><span class="line"><span class="cl"><span class="k">namespace</span> <span class="nn">guRoo.Commands.General</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cs">/// &lt;summary&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="cs">///		Example Command</span>
</span></span><span class="line"><span class="cl">    <span class="cs">/// &lt;/summary&gt;</span>
</span></span><span class="line"><span class="cl"><span class="na">    [Transaction(TransactionMode.Manual)]</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="k">class</span> <span class="nc">Cmd_Test</span> <span class="p">:</span> <span class="n">IExternalCommand</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kd">public</span> <span class="n">Result</span> <span class="n">Execute</span><span class="p">(</span><span class="n">ExternalCommandData</span> <span class="n">CommandData</span><span class="p">,</span> <span class="k">ref</span> <span class="kt">string</span> <span class="n">message</span><span class="p">,</span> <span class="n">ElementSet</span> <span class="n">elements</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// Collect the Document and Application objects from the CommandData</span>
</span></span><span class="line"><span class="cl">            <span class="kt">var</span> <span class="n">uiApp</span> <span class="p">=</span> <span class="n">CommandData</span><span class="p">.</span><span class="n">Application</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="kt">var</span> <span class="n">uiDoc</span> <span class="p">=</span> <span class="n">uiApp</span><span class="p">.</span><span class="n">ActiveUIDocument</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="kt">var</span> <span class="n">doc</span> <span class="p">=</span> <span class="n">uiDoc</span><span class="p">.</span><span class="n">Document</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// Collect all walls</span>
</span></span><span class="line"><span class="cl">            <span class="kt">var</span> <span class="n">walls</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">.</span><span class="n">OfClass</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">Wall</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                <span class="p">.</span><span class="n">WhereElementIsNotElementType</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">                <span class="p">.</span><span class="n">ToElements</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// Show the message dialog with the document title</span>
</span></span><span class="line"><span class="cl">            <span class="n">TaskDialog</span><span class="p">.</span><span class="n">Show</span><span class="p">(</span> <span class="n">doc</span><span class="p">.</span><span class="n">Title</span><span class="p">,</span> <span class="s">$&#34;We have {walls.Count} walls in the model&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// Collect all walls lower than 12 feet</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// First: Construct a filter for .WherePasses() Method</span>
</span></span><span class="line"><span class="cl">            <span class="kt">var</span> <span class="n">parameterId</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ElementId</span><span class="p">(</span><span class="n">BuiltInParameter</span><span class="p">.</span><span class="n">WALL_USER_HEIGHT_PARAM</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="kt">var</span> <span class="n">provider</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ParameterValueProvider</span><span class="p">(</span><span class="n">parameterId</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="kt">var</span> <span class="n">rule</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilterNumericLess</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="kt">var</span> <span class="n">passesRule</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilterDoubleRule</span><span class="p">(</span><span class="n">provider</span><span class="p">,</span> <span class="n">rule</span><span class="p">,</span> <span class="m">12</span><span class="p">,</span> <span class="m">0.1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="kt">var</span> <span class="n">paramFilter</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ElementParameterFilter</span><span class="p">(</span><span class="n">passesRule</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// Then: Apply the filter to the FilteredElementCollector</span>
</span></span><span class="line"><span class="cl">            <span class="kt">var</span> <span class="n">wallsFiltered</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">.</span><span class="n">OfCategory</span><span class="p">(</span><span class="n">BuiltInCategory</span><span class="p">.</span><span class="n">OST_Walls</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">.</span><span class="n">WhereElementIsNotElementType</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">                <span class="p">.</span><span class="n">WherePasses</span><span class="p">(</span><span class="n">paramFilter</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">.</span><span class="n">ToElements</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// Show the message dialog with the document title</span>
</span></span><span class="line"><span class="cl">            <span class="n">TaskDialog</span><span class="p">.</span><span class="n">Show</span><span class="p">(</span><span class="n">doc</span><span class="p">.</span><span class="n">Title</span><span class="p">,</span> <span class="s">$&#34;We have {wallsFiltered.Count} walls less than 12 ft in the model&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="c1">// Collect all sheets</span>
</span></span><span class="line"><span class="cl">			<span class="kt">var</span> <span class="n">sheets</span> <span class="p">=</span> <span class="n">doc</span><span class="p">.</span><span class="n">Ext_GetSheets</span><span class="p">();</span> 
</span></span><span class="line"><span class="cl">			<span class="c1">// declare an argument if you need &#34;(includePlaceholders: true)&#34;</span>
</span></span><span class="line"><span class="cl">			<span class="kt">var</span> <span class="n">revisions</span> <span class="p">=</span> <span class="n">doc</span><span class="p">.</span><span class="n">Ext_GetRevisions</span><span class="p">();</span> 
</span></span><span class="line"><span class="cl">			
</span></span><span class="line"><span class="cl">			<span class="n">TaskDialog</span><span class="p">,</span><span class="n">Show</span><span class="p">(</span><span class="n">doc</span><span class="p">.</span><span class="n">Title</span><span class="p">,</span> <span class="s">$&#34;We have {sheets.Count} sheets in the model&#34;</span><span class="p">);)</span>
</span></span><span class="line"><span class="cl">			
</span></span><span class="line"><span class="cl">			<span class="n">TaskDialog</span><span class="p">,</span><span class="n">Show</span><span class="p">(</span><span class="n">doc</span><span class="p">.</span><span class="n">Title</span><span class="p">,</span> <span class="s">$&#34;We have {revisions.Count} revisions in the model&#34;</span><span class="p">);)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// Final return here:</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">Result</span><span class="p">.</span><span class="n">Succeeded</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>These tutorials were inspired by the work of <a href="https://www.youtube.com/@AussieBIMGuru">Aussie BIM Guru</a>. If you’re looking for a deeper dive into the topics, check out his channel for detailed explanations.</p></blockquote>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/c%23/">C#</a></li>
      <li><a href="http://localhost:1313/tags/revit/">Revit</a></li>
      <li><a href="http://localhost:1313/tags/tutorial/">Tutorial</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/posts/lesson-13/">
    <span class="title">« Prev</span>
    <br>
    <span>C# &#43; Revit API: Lesson 13 - MessageBox Forms</span>
  </a>
  <a class="next" href="http://localhost:1313/posts/lesson-11/">
    <span class="title">Next »</span>
    <br>
    <span>C# &#43; Revit API: Lesson 11 - Stacking Buttons</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>© 2025 AYDrafting. All rights reserved.</span> · 

    <span>
        Powered by
        <a href="https://aydrafting.com/" rel="noopener noreferrer" target="_blank">AYDrafting</a> &
        <a href="https://github.com/aydimir95/" rel="noopener" target="_blank">GitHub</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
