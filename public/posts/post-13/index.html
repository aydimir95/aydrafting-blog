<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>C# &#43; Revit API: Lesson 13 - Case Study №1 [Section Automation] | Blog</title>
<meta name="keywords" content="C#, Revit, Tutorial">
<meta name="description" content="Introduction
This is the automation I made for my client and I would like to share the insights.
Plan:

Refactor the automation to properly organize the project.
Start with understanding how to organize the WPF forms better.
Seems like I have lots of functions just jumbled together in each file.
Basically, separate and refactor the code.



 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69


Based on analyzing the current &#34;Cmds_AutoDim.cs&#34; implementation and comparing it with the established codebase patterns, here are my refactoring suggestions:  
  
Key Refactoring Recommendations  

1. Namespace Inconsistency  

Current: namespace DimensionAutomation  
Suggested: namespace UKON.Commands.General  
	- Follow the established pattern from other command files in the same directory  

2. Class Naming Convention  

Current: public class DimensionAutomation  
Suggested: public class Cmd_AutoDim  
	- Match the naming pattern used throughout the codebase (e.g., Cmd_Test, Cmd_1Button)  

3. Variable Naming Consistency  

Current: UIApplication uiapp = commandData.Application;  
Suggested: var uiApp = commandData.Application;  
	- Follow the camelCase pattern used in other files (uiApp, uiDoc, not uiapp, uidoc)  

4. Comments Structure  

Current: Uses // only elements actually visible in this view  
Suggested: Add proper method-level XML documentation comments like other files:  
/// &lt;summary&gt;  
/// Auto-dimensioning command for section views  
/// &lt;/summary&gt;  

5. File Organization  

Current: Single complex class with multiple private methods  
Suggested: Consider splitting into:  
	- Main command class (Cmd_AutoDim)  
	- Separate service/helper classes for dimension logic  
	- This follows the single responsibility principle  

6. Error Handling Pattern  

Current: Generic try-catch with Russian error messages  
Suggested:  
	- Use consistent error message language (English like other files)  
	- Follow the established error handling pattern from other commands  

7. External Dependencies  

Current: References DimensionAutomation.UI namespace  
Suggested: Ensure UI classes follow the project&#39;s namespace structure (UKON.UI or similar)  

8. Transaction Naming  

Current: &#34;Создание маркеров и размерений&#34; (Russian)  
Suggested: Use English transaction names for consistency  

9. Method Extraction Opportunities  

The Execute method is quite long. Consider extracting:  
	- User input validation logic  
	- Section processing setup  
	- Error message display logic  

10. Constants Organization  

Current: MIN_CURVE_LENGTH defined in class  
Suggested: Consider a constants class or configuration file for project-wide constants  

The current implementation is functional but doesn&#39;t follow the established architectural patterns of the UKON  
project. The main issues are namespace inconsistency, naming conventions, and language mixing.


Old Code
Project Solution


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25


Solution
|-&gt; ViewOnSheets2025
	|-&gt; Dependencies
	|-&gt; Properties
	|-&gt; Commands
		|-&gt; AutoLevelMarker.cs 
		|-&gt; DimensionAutomation.cs  
		|-&gt; RevitSectionCreator.cs 
		|-&gt; SpotDimensionAutomation.cs 
		|-&gt; ViewsOnSheets.cs 
	|-&gt; Globals 
		|-&gt; ElementTypeInfo.cs
		|-&gt; ParameterUtilities.cs
		|-&gt; PointOnElement.cs
	|-&gt; Resources
		|-&gt; Icons
	|-&gt; Services
		|-&gt; ViewsOnSheetsR2025Service.cs
	|-&gt; UI
		|-&gt; AutoLevelMarker.xaml
		|-&gt; DimensionAutomationWindow.xaml
		|-&gt; RevitSectionsCreatorWindow.xaml
		|-&gt; ViewOnSheetsR2025Windown.xaml
	|-&gt; Application.cs           
	|-&gt; guRoo.addin



RevitSectionCreator.cs


  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380
381
382
383
384
385
386
387
388
389
390
391
392
393
394
395
396
397
398
399
400
401
402
403
404
405
406
407
408
409
410
411
412
413
414
415
416
417
418
419
420
421
422
423
424
425
426


using Autodesk.Revit.Attributes;
using Autodesk.Revit.DB;
using Autodesk.Revit.UI;
using RevitSectionCreator.UI;

namespace RevitSectionCreator
{
    [Transaction(TransactionMode.Manual)]
    public class Command : IExternalCommand
    {
        public Result Execute(ExternalCommandData commandData, ref string message, ElementSet elements)
        {
            UIApplication uiapp = commandData.Application;
            UIDocument uidoc = uiapp.ActiveUIDocument;
            Document doc = uidoc.Document;

            try
            {
                // STEP 1: Collect element types for section creation.
                List&lt;ElementTypeInfo&gt; elementTypes = new List&lt;ElementTypeInfo&gt;();

                // Collect FamilyInstance elements and group them by the family name.
                var familyInstances = new FilteredElementCollector(doc)
                    .OfClass(typeof(FamilyInstance))
                    .Cast&lt;FamilyInstance&gt;()
                    .ToList();

                var familyGroups = familyInstances
                    .GroupBy(fi =&gt; fi.Symbol.FamilyName)
                    .Select(g =&gt; new ElementTypeInfo
                    {
                        TypeName = g.Key,
                        Category = &#34;Семейство&#34;, // &#34;Family&#34; in Russian
                        ElementIds = g.Select(fi =&gt; fi.Id).ToList()
                    })
                    .ToList();
                elementTypes.AddRange(familyGroups);

                // Collect DirectShape elements.
                var directShapes = new FilteredElementCollector(doc)
                    .OfClass(typeof(DirectShape))
                    .Cast&lt;DirectShape&gt;()
                    .ToList();

                var directShapeGroups = directShapes
                    .GroupBy(ds =&gt; ds.Category?.Name ?? &#34;Без категории&#34;)
                    .Select(g =&gt; new ElementTypeInfo
                    {
                        TypeName = $&#34;DirectShape - {g.Key}&#34;,
                        Category = &#34;DirectShape&#34;,
                        ElementIds = g.Select(ds =&gt; ds.Id).ToList()
                    })
                    .ToList();
                elementTypes.AddRange(directShapeGroups);

                // Collect ImportInstance elements (excluding links).
                var importInstances = new FilteredElementCollector(doc)
                    .OfClass(typeof(ImportInstance))
                    .Cast&lt;ImportInstance&gt;()
                    .Where(ii =&gt; !ii.IsLinked)
                    .ToList();

                var importGroups = importInstances
                    .GroupBy(ii =&gt; ii.Category?.Name ?? &#34;Без категории импорта&#34;)
                    .Select(g =&gt; new ElementTypeInfo
                    {
                        TypeName = $&#34;Import - {g.Key}&#34;,
                        Category = &#34;Import&#34;,
                        ElementIds = g.Select(ii =&gt; ii.Id).ToList()
                    })
                    .ToList();
                elementTypes.AddRange(importGroups);

                if (elementTypes.Count == 0)
                {
                    TaskDialog.Show(&#34;Ошибка&#34;, &#34;В документе не найдено подходящих элементов.&#34;);
                    return Result.Failed;
                }

                // Sort the element types by category then by type name.
                elementTypes = elementTypes
                    .OrderBy(et =&gt; et.Category)
                    .ThenBy(et =&gt; et.TypeName)
                    .ToList();

                // STEP 2: Display the unified WPF window to get user choices.
                RevitSectionCreatorWindow sectionWindow = new RevitSectionCreatorWindow(elementTypes);
                if (sectionWindow.ShowDialog() != true)
                {
                    return Result.Cancelled;
                }

                // Retrieve selections from the combined window.
                ElementTypeInfo selectedType = sectionWindow.SelectedElementType;
                string selectedFace = sectionWindow.SelectedFace; // e.g., &#34;Левая грань&#34;
                double offsetMm = sectionWindow.OffsetValue;

                // STEP 3: Create section views.
                using (Transaction t = new Transaction(doc, $&#34;Создание разрезов для {selectedType.TypeName}&#34;))
                {
                    t.Start();

                    // Get the Section ViewFamilyType.
                    using ViewFamilyType sectionType = new FilteredElementCollector(doc)
                        .OfClass(typeof(ViewFamilyType))
                        .Cast&lt;ViewFamilyType&gt;()
                        .FirstOrDefault(vt =&gt; vt.ViewFamily == ViewFamily.Section);

                    if (sectionType == null)
                    {
                        TaskDialog.Show(&#34;Ошибка&#34;, &#34;Не найден тип семейства для разреза.&#34;);
                        return Result.Failed;
                    }

                    // Retrieve the actual elements from the selected type.
                    List&lt;Element&gt; elementsToProcess = new List&lt;Element&gt;();
                    foreach (ElementId id in selectedType.ElementIds)
                    {
                        Element elem = doc.GetElement(id);
                        if (elem != null)
                        {
                            elementsToProcess.Add(elem);
                        }
                    }

                    if (!elementsToProcess.Any())
                    {
                        TaskDialog.Show(&#34;Ошибка&#34;, $&#34;Элементы типа &#39;{selectedType.TypeName}&#39; не найдены.&#34;);
                        return Result.Failed;
                    }

                    // Determine the base direction from the selected face.
                    XYZ baseDirection = GetDirectionFromFace(selectedFace);
                    int sectionCount = 0;

                    foreach (Element element in elementsToProcess)
                    {
                        string elementMark = GetElementMark(element) ?? element.Name;
                        List&lt;ElementId&gt; partIds = new List&lt;ElementId&gt;();

                        // For FamilyInstance elements, try to get associated parts.
                        if (element is FamilyInstance familyInstance)
                        {
                            ICollection&lt;ElementId&gt; associatedParts = PartUtils.GetAssociatedParts(doc, familyInstance.Id, true, true);
                            partIds.AddRange(associatedParts);
                        }

                        // If no associated parts, use the element itself.
                        if (partIds.Count == 0)
                        {
                            partIds.Add(element.Id);
                        }

                        foreach (ElementId partId in partIds)
                        {
                            Element part = doc.GetElement(partId);
                            string partMark = GetElementMark(part) ?? part.Name;

                            // Use the base direction from the unified dialog.
                            XYZ finalDirection = baseDirection;

                            // Find the best-aligned face on the element.
                            Face chosenFace = GetLocalDirectionFace(part, finalDirection);
                            if (chosenFace == null)
                                continue;

                            // Create the section view.
                            ViewSection sectionView = CreateSectionView(doc, sectionType.Id, chosenFace, offsetMm);
                            if (sectionView != null)
                            {
                                try
                                {
                                    // Build a name for the new section view.
                                    string rawPartName = !string.IsNullOrEmpty(partMark) ? partMark : elementMark;
                                    string faceLabel = selectedFace.Replace(&#34; &#34;, &#34;&#34;); // Remove spaces for naming.
                                    string offsetStrForm = (offsetMm % 1 == 0) ? $&#34;{(int)offsetMm}мм&#34; : $&#34;{offsetMm}мм&#34;;
                                    string combinedName = $&#34;{rawPartName}_{faceLabel}_{offsetStrForm}&#34;;
                                    string uniqueName = GenerateUniqueName(doc, combinedName);
                                    sectionView.Name = uniqueName;

                                    // Apply crop region to the section view.
                                    CreateViewCrop(sectionView, chosenFace);
                                    sectionCount&#43;&#43;;
                                }
                                catch (Exception ex)
                                {
                                    TaskDialog.Show(&#34;Предупреждение&#34;, $&#34;Не удалось задать имя для вида: {ex.Message}&#34;);
                                }
                            }
                        }
                    }

                    t.Commit();
                    TaskDialog.Show(&#34;Успех&#34;, $&#34;Создано {sectionCount} разрезов для {selectedType.TypeName}.&#34;);
                }

                return Result.Succeeded;
            }
            catch (Exception ex)
            {
                message = ex.Message;
                return Result.Failed;
            }
        }

        #region Helper Methods

        // Maps Russian face names to direction vectors.
        private XYZ GetDirectionFromFace(string faceName)
        {
            var directionMap = new Dictionary&lt;string, XYZ&gt;
            {
                { &#34;Левая грань&#34;, new XYZ(-1, 0, 0) },
                { &#34;Правая грань&#34;, new XYZ(1, 0, 0) },
                { &#34;Передняя грань&#34;, new XYZ(0, 1, 0) },
                { &#34;Задняя грань&#34;, new XYZ(0, -1, 0) },
                { &#34;Верхняя грань&#34;, new XYZ(0, 0, 1) },
                { &#34;Нижняя грань&#34;, new XYZ(0, 0, -1) }
            };

            if (directionMap.TryGetValue(faceName, out XYZ direction))
            {
                return direction;
            }
            return XYZ.BasisY; // Fallback
        }

        // Retrieves the element&#39;s &#34;mark&#34; or returns its name.
        private string GetElementMark(Element element)
        {
            Parameter markParam = element.get_Parameter(BuiltInParameter.ALL_MODEL_MARK);
            if (markParam != null &amp;&amp; markParam.HasValue)
            {
                string markValue = markParam.AsString();
                if (!string.IsNullOrEmpty(markValue) &amp;&amp; markValue.Contains(&#34;Ст.&#34;))
                {
                    string numberPart = markValue.Split(new[] { &#34;Ст.&#34; }, StringSplitOptions.None)[1].Trim();
                    return $&#34;О_Р_{numberPart}&#34;;
                }
                return markValue;
            }
            return null;
        }

        // Generates a unique name for a view by appending additional characters if needed.
        private string GenerateUniqueName(Document doc, string baseName)
        {
            string testName = baseName;
            int counter = 1;
            List&lt;string&gt; existingNames = new FilteredElementCollector(doc)
                .OfClass(typeof(View))
                .Cast&lt;View&gt;()
                .Select(v =&gt; v.Name)
                .ToList();

            while (existingNames.Contains(testName))
            {
                counter&#43;&#43;;
                testName = baseName &#43; new string(&#39;*&#39;, counter);
            }
            return testName;
        }

        // Creates a crop boundary (CurveLoop) from a given face.
        private CurveLoop CreateCropBoundary(Face face)
        {
            try
            {
                BoundingBoxUV uvBbox = face.GetBoundingBox();
                List&lt;XYZ&gt; points = new List&lt;XYZ&gt;
                {
                    face.Evaluate(new UV(uvBbox.Min.U, uvBbox.Min.V)),
                    face.Evaluate(new UV(uvBbox.Max.U, uvBbox.Min.V)),
                    face.Evaluate(new UV(uvBbox.Max.U, uvBbox.Max.V)),
                    face.Evaluate(new UV(uvBbox.Min.U, uvBbox.Max.V))
                };

                List&lt;Curve&gt; curves = new List&lt;Curve&gt;();
                for (int i = 0; i &lt; 4; i&#43;&#43;)
                {
                    XYZ start = points[i];
                    XYZ end = points[(i &#43; 1) % 4];
                    curves.Add(Line.CreateBound(start, end));
                }
                return CurveLoop.Create(curves);
            }
            catch
            {
                return null;
            }
        }

        // Sets up the crop boundary on a section view.
        private bool CreateViewCrop(ViewSection view, Face face)
        {
            try
            {
                if (!view.CropBoxActive)
                    view.CropBoxActive = true;

                CurveLoop cropLoop = CreateCropBoundary(face);
                if (cropLoop != null)
                {
                    view.GetCropRegionShapeManager().SetCropShape(cropLoop);
                    return true;
                }
                return false;
            }
            catch
            {
                return false;
            }
        }

        // Determines the face on an element that best aligns with the local direction.
        private Face GetLocalDirectionFace(Element element, XYZ localDir)
        {
            Transform instTransform = Transform.Identity;
            if (element is FamilyInstance familyInstance)
                instTransform = familyInstance.GetTransform();
            else if (element is ImportInstance importInstance &amp;&amp; !importInstance.IsLinked)
                instTransform = importInstance.GetTransform();

            Transform invTransform = instTransform.Inverse;
            Face chosenFace = null;
            double bestAlignment = -999;

            Options options = new Options
            {
                ComputeReferences = true,
                DetailLevel = ViewDetailLevel.Fine
            };

            GeometryElement geoElem = element.get_Geometry(options);
            if (geoElem == null)
                return null;

            void ProcessGeometry(GeometryObject geo, Transform transform)
            {
                if (geo is Solid solid &amp;&amp; solid.Volume &gt; 0)
                {
                    foreach (Face face in solid.Faces)
                    {
                        XYZ faceNormalWorld = face.ComputeNormal(new UV(0.5, 0.5)).Normalize();
                        XYZ faceNormalLocal = invTransform.OfVector(faceNormalWorld).Normalize();
                        double alignment = faceNormalLocal.DotProduct(localDir);
                        if (alignment &gt; bestAlignment)
                        {
                            bestAlignment = alignment;
                            chosenFace = face;
                        }
                    }
                }
                else if (geo is GeometryInstance instance)
                {
                    Transform instanceTransform = instance.Transform;
                    GeometryElement instGeo = instance.GetInstanceGeometry();
                    if (instGeo != null)
                    {
                        foreach (GeometryObject obj in instGeo)
                        {
                            ProcessGeometry(obj, instanceTransform);
                        }
                    }
                }
            }

            foreach (GeometryObject geo in geoElem)
            {
                ProcessGeometry(geo, Transform.Identity);
            }
            return chosenFace;
        }

        // Creates and returns a section view based on the given face and offset.
        private ViewSection CreateSectionView(Document doc, ElementId sectionTypeId, Face face, double offsetMm)
        {
            try
            {
                // 1. Compute face center in world coords
                BoundingBoxUV uvBbox = face.GetBoundingBox();
                double midU = (uvBbox.Min.U &#43; uvBbox.Max.U) / 2.0;
                double midV = (uvBbox.Min.V &#43; uvBbox.Max.V) / 2.0;
                XYZ faceCenter = face.Evaluate(new UV(midU, midV));

                // 2. Get the outward normal, then invert it for “inward” view direction
                XYZ faceNormalOut = face.ComputeNormal(new UV(midU, midV)).Normalize();
                XYZ inwardNormal = faceNormalOut.Multiply(-1.0);

                // 3. Build the section’s coordinate system
                Transform transFace = Transform.Identity;
                transFace.Origin = faceCenter;
                transFace.BasisZ = inwardNormal; // ← view direction toward element

                // 4. Choose a reasonable X axis for the section
                XYZ basisX = inwardNormal.CrossProduct(XYZ.BasisZ);
                if (basisX.IsAlmostEqualTo(XYZ.Zero))
                    basisX = inwardNormal.CrossProduct(XYZ.BasisX);
                transFace.BasisX = basisX.Normalize();
                transFace.BasisY = transFace.BasisZ.CrossProduct(transFace.BasisX).Normalize();

                // 5. Apply offset *along* the inward normal
                //    Convert mm → ft, then move inward
                double offsetFt = offsetMm / 304.8;
                transFace.Origin = faceCenter.Add(inwardNormal.Multiply(offsetFt));

                // 6. Define the crop box in this new coordinate system
                BoundingBoxXYZ sectionBox = new BoundingBoxXYZ
                {
                    Transform = transFace,
                    Min = new XYZ(-2.5, -50, -0.1),
                    Max = new XYZ(2.5, 50, 0.25)
                };

                // 7. Create and return the section
                return ViewSection.CreateSection(doc, sectionTypeId, sectionBox);
            }
            catch
            {
                return null;
            }
        }

        #endregion
    }
}



DimensionAutomation.cs


  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197


using Autodesk.Revit.Attributes;
using Autodesk.Revit.DB;
using Autodesk.Revit.UI;
using DimensionAutomation.UI;

namespace DimensionAutomation
{
    [Transaction(TransactionMode.Manual)]
    public class DimensionAutomation : IExternalCommand
    {
        private const double MIN_CURVE_LENGTH = 0.001;

        private XYZ GetVerticalInView(XYZ viewDir)
        {
            XYZ upDir = XYZ.BasisZ;
            XYZ verticalInView = upDir - viewDir.Multiply(upDir.DotProduct(viewDir));
            if (verticalInView.GetLength() &lt; MIN_CURVE_LENGTH)
                return null;
            return verticalInView.Normalize();
        }

        public Result Execute(ExternalCommandData commandData, ref string message, ElementSet elements)
        {
            UIApplication uiapp = commandData.Application;
            UIDocument uidoc = uiapp.ActiveUIDocument;
            Document doc = uidoc.Document;

            try
            {
                // Show the WPF window to get user choices.
                var window = new DimensionAutomationWindow(doc);
                if (window.ShowDialog() != true)
                    return Result.Cancelled;

                // Gather user selections.
                var selectedSections = window.SelectedSectionViews;
                var selectedFamilyTypes = window.SelectedFamilyTypes;
                var selectedDimType = window.SelectedDimensionType;
                double offsetFeet = window.OffsetValue * 3.28084;

                // Basic checks.
                if (selectedSections == null || !selectedSections.Any())
                {
                    TaskDialog.Show(&#34;Информация&#34;, &#34;Не выбраны виды разрезов. Операция прервана.&#34;);
                    return Result.Cancelled;
                }
                if (selectedFamilyTypes == null || selectedFamilyTypes.Count &lt; 1)
                {
                    TaskDialog.Show(&#34;Информация&#34;, &#34;Пожалуйста, выберите хотя бы один тип семейства.&#34;);
                    return Result.Cancelled;
                }
                if (selectedDimType == null)
                {
                    TaskDialog.Show(&#34;Ошибка&#34;, &#34;Тип размерения не выбран.&#34;);
                    return Result.Failed;
                }

                // Process each section view.
                foreach (ViewSection section in selectedSections)
                {
                    var instancesInSection = new FilteredElementCollector(doc, section.Id)
                        // only elements actually visible in this view
                        .WherePasses(new VisibleInViewFilter(doc, section.Id))
                        .OfClass(typeof(FamilyInstance))
                        .Cast&lt;FamilyInstance&gt;()
                        .Where(fi =&gt;
                            fi.Symbol != null &amp;&amp;
                            selectedFamilyTypes.Any(fs =&gt; fs.Id == fi.Symbol.Id)
                        )
                        .ToList();

                    if (instancesInSection.Count &lt; 2)
                        continue;

                    ProcessSectionView(doc, section, selectedDimType, offsetFeet, instancesInSection);
                }

                return Result.Succeeded;
            }
            catch (Exception ex)
            {
                TaskDialog.Show(&#34;Ошибка&#34;, ex.ToString());
                return Result.Failed;
            }
        }

        private void ProcessSectionView(
            Document doc,
            ViewSection sectionView,
            DimensionType dimType,
            double offsetDist,
            List&lt;FamilyInstance&gt; instances)
        {
            XYZ viewDir = sectionView.ViewDirection.Normalize();
            XYZ verticalInView = GetVerticalInView(viewDir);
            if (verticalInView == null)
            {
                TaskDialog.Show(&#34;Предупреждение&#34;, &#34;Не удалось определить вертикальное направление в виде. Пропускаем...&#34;);
                return;
            }

            // Collect bounding-box centers.
            var centerPoints = new List&lt;XYZ&gt;();
            foreach (var fi in instances)
            {
                var bb = fi.get_BoundingBox(sectionView);
                if (bb != null)
                    centerPoints.Add((bb.Min &#43; bb.Max) * 0.5);
            }
            if (centerPoints.Count &lt; 2)
                return;

            // Sort by vertical location.
            centerPoints = centerPoints.OrderBy(p =&gt; p.DotProduct(verticalInView)).ToList();
            var dim3d = centerPoints.Last() - centerPoints.First();
            if (dim3d.GetLength() &lt; MIN_CURVE_LENGTH)
                return;

            // Project onto view plane.
            double dot = dim3d.DotProduct(viewDir);
            var dimPlane = (dim3d - viewDir.Multiply(dot)).Normalize();
            if (dimPlane.GetLength() &lt; MIN_CURVE_LENGTH)
                return;

            // Marker direction perpendicular to dimension direction.
            var refsDir = viewDir.CrossProduct(dimPlane).Normalize();

            using (var tx = new Transaction(doc, &#34;Создание маркеров и размерений&#34;))
            {
                tx.Start();
                var detailLines = CreateDetailLines(doc, sectionView, centerPoints, refsDir, viewDir);
                doc.Regenerate();
                CreateDimensionsBetweenLines(doc, sectionView, detailLines, refsDir, offsetDist, dimType);
                tx.Commit();
            }
        }

        private List&lt;DetailCurve&gt; CreateDetailLines(
            Document doc,
            ViewSection view,
            List&lt;XYZ&gt; centers,
            XYZ dir,
            XYZ viewDir)
        {
            const double markerLen = 0.01;
            double half = markerLen * 0.5;
            var lines = new List&lt;DetailCurve&gt;();

            foreach (var cp in centers)
            {
                var p1 = cp - dir.Multiply(half);
                var p2 = cp &#43; dir.Multiply(half);
                var plane = Plane.CreateByNormalAndOrigin(viewDir, cp);
                SketchPlane.Create(doc, plane);
                var line = Line.CreateBound(p1, p2);
                lines.Add(doc.Create.NewDetailCurve(view, line));
            }
            return lines;
        }

        private void CreateDimensionsBetweenLines(
            Document doc,
            ViewSection view,
            List&lt;DetailCurve&gt; lines,
            XYZ dir,
            double offset,
            DimensionType dimType)
        {
            for (int i = 0; i &lt; lines.Count - 1; i&#43;&#43;)
            {
                var a = lines[i].GeometryCurve.Reference;
                var b = lines[i &#43; 1].GeometryCurve.Reference;
                var refs = new ReferenceArray();
                refs.Append(a);
                refs.Append(b);

                var midA = lines[i].GeometryCurve.Evaluate(0.5, true);
                var midB = lines[i &#43; 1].GeometryCurve.Evaluate(0.5, true);

                var offA = midA &#43; dir.Multiply(offset);
                var offB = midB &#43; dir.Multiply(offset);

                var dimLine = Line.CreateBound(offA, offB);

                try
                {
                    var dim = doc.Create.NewDimension(view, dimLine, refs);
                    dim.ChangeTypeId(dimType.Id);
                }
                catch (Exception ex)
                {
                    TaskDialog.Show(&#34;Ошибка размерения&#34;, ex.Message);
                }
            }
        }
    }
}



SpotDimensionAutomation.cs


  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369


using Autodesk.Revit.Attributes;
using Autodesk.Revit.DB;
using Autodesk.Revit.UI;
using Autodesk.Revit.UI.Selection;

namespace SpotDimensionTest.Commands
{
    [Transaction(TransactionMode.Manual)]
    public class StartupCommand : IExternalCommand
    {
        public Result Execute(ExternalCommandData commandData, ref string message, ElementSet elements)
        {
            UIDocument uiDoc = commandData.Application.ActiveUIDocument;
            Document doc = uiDoc.Document;

            // STEP 1: Get preselected section views
            ICollection&lt;ElementId&gt; viewSelectionIds = uiDoc.Selection.GetElementIds();
            List&lt;View&gt; sectionViews = new List&lt;View&gt;();

            foreach (ElementId id in viewSelectionIds)
            {
                Element elem = doc.GetElement(id);
                if (elem is View view &amp;&amp; view.ViewType == ViewType.Section)
                {
                    sectionViews.Add(view);
                }
            }

            if (sectionViews.Count == 0)
            {
                TaskDialog.Show(&#34;Info&#34;, &#34;Please preselect section views first.&#34;);
                return Result.Succeeded;
            }

            // STEP 2: User selects family instances
            TaskDialog.Show(&#34;Selection&#34;, &#34;Now select family instances for spot elevations.&#34;);
            IList&lt;Reference&gt; familyRefs = uiDoc.Selection.PickObjects(
                ObjectType.Element,
                &#34;Select family instances for spot elevations&#34;);

            List&lt;FamilyInstance&gt; familyInstances = new List&lt;FamilyInstance&gt;();
            foreach (Reference famRef in familyRefs)
            {
                Element elem = doc.GetElement(famRef.ElementId);
                if (elem is FamilyInstance fi)
                {
                    familyInstances.Add(fi);
                }
            }

            if (familyInstances.Count == 0)
            {
                TaskDialog.Show(&#34;Info&#34;, &#34;No family instances selected.&#34;);
                return Result.Succeeded;
            }

            // STEP 3: User picks a face on one of the family instances
            Reference pickedFaceRef = uiDoc.Selection.PickObject(
                ObjectType.Face,
                &#34;Select a face for the spot elevation&#34;);

            Element templateElem = doc.GetElement(pickedFaceRef.ElementId);
            GeometryObject geoObj = templateElem.GetGeometryObjectFromReference(pickedFaceRef);
            Face templateFace = geoObj as Face;
            XYZ pickedPoint = pickedFaceRef.GlobalPoint;
            XYZ templatePoint = CalculatePointOnFace(templateElem, templateFace, pickedPoint);

            // STEP 4: Create spot elevations on all family instances in all section views
            using (TransactionGroup tg = new TransactionGroup(doc, &#34;Create Multiple Spot Elevations&#34;))
            {
                tg.Start();

                int successCount = 0;

                foreach (View sectionView in sectionViews)
                {
                    using (Transaction trans = new Transaction(doc, $&#34;Spot Elevations in {sectionView.Name}&#34;))
                    {
                        trans.Start();

                        XYZ viewDir = sectionView.ViewDirection.Normalize();
                        XYZ viewUp = sectionView.UpDirection.Normalize();
                        XYZ viewRight = viewUp.CrossProduct(viewDir).Normalize();

                        XYZ originalPickedPoint = pickedPoint;
                        bool viewHasSpotElevation = false;

                        foreach (FamilyInstance fi in familyInstances)
                        {
                            if (viewHasSpotElevation)
                                break;

                            try
                            {
                                Options options = new Options
                                {
                                    View = sectionView,
                                    ComputeReferences = true,
                                    IncludeNonVisibleObjects = false
                                };

                                GeometryElement geometry = fi.get_Geometry(options);
                                if (geometry == null || !geometry.Any())
                                    continue;

                                List&lt;Face&gt; faces = new List&lt;Face&gt;();
                                foreach (GeometryObject geomObj in geometry)
                                {
                                    ExtractFacesFromGeometry(geomObj, faces);
                                }

                                List&lt;Face&gt; sortedFaces = SortFacesByPriority(faces, viewDir);

                                foreach (Face face in sortedFaces)
                                {
                                    try
                                    {
                                        IList&lt;CurveLoop&gt; edgeLoops = face.GetEdgesAsCurveLoops();
                                        if (edgeLoops == null || edgeLoops.Count == 0)
                                            continue;

                                        XYZ elevationPoint = CalculatePointOnFace(fi, face, originalPickedPoint);

                                        try
                                        {
                                            XYZ lineStart = elevationPoint - viewRight * 0.1;
                                            XYZ lineEnd = elevationPoint &#43; viewRight * 0.1;
                                            DetailLine? detailLine = doc.Create.NewDetailCurve(
                                                sectionView,
                                                Line.CreateBound(lineStart, lineEnd)) as DetailLine;

                                            if (detailLine != null)
                                            {
                                                XYZ bendPoint = elevationPoint;
                                                XYZ endPoint = elevationPoint;
                                                Reference lineRef = new Reference(detailLine);
                                                try
                                                {
                                                    SpotDimension spotDimension = doc.Create.NewSpotElevation(
                                                        sectionView,
                                                        lineRef,
                                                        elevationPoint,
                                                        bendPoint,
                                                        endPoint,
                                                        elevationPoint,
                                                        true);

                                                    if (spotDimension != null)
                                                    {
                                                        successCount&#43;&#43;;
                                                        viewHasSpotElevation = true;
                                                        break;
                                                    }
                                                    else
                                                    {
                                                        doc.Delete(detailLine.Id);
                                                    }
                                                }
                                                catch (Exception)
                                                {
                                                    doc.Delete(detailLine.Id);
                                                }
                                            }
                                        }
                                        catch (Exception)
                                        {
                                            // Continue to next face
                                        }
                                    }
                                    catch (Exception)
                                    {
                                        // Continue to next face
                                    }

                                    if (viewHasSpotElevation)
                                        break;
                                }
                            }
                            catch (Exception)
                            {
                                // Continue to next family instance
                            }

                            if (viewHasSpotElevation)
                                break;
                        }

                        trans.Commit();
                    }
                }

                tg.Assimilate();

                TaskDialog resultsDialog = new TaskDialog(&#34;Spot Elevation Results&#34;);
                resultsDialog.MainInstruction = $&#34;Created {successCount} spot elevations&#34;;
                resultsDialog.MainContent = $&#34;Successfully created {successCount} spot elevations across {sectionViews.Count} section views.&#34;;
                resultsDialog.Show();
            }
            return Result.Succeeded;
        }

        private List&lt;Face&gt; SortFacesByPriority(List&lt;Face&gt; faces, XYZ viewDir)
        {
            List&lt;Tuple&lt;Face, double&gt;&gt; facesWithScores = new List&lt;Tuple&lt;Face, double&gt;&gt;();

            foreach (Face face in faces)
            {
                try
                {
                    BoundingBoxUV bb = face.GetBoundingBox();
                    UV centerUV = new UV((bb.Min.U &#43; bb.Max.U) * 0.5, (bb.Min.V &#43; bb.Max.V) * 0.5);
                    XYZ normal = face.ComputeNormal(centerUV);
                    double dotProduct = Math.Abs(normal.DotProduct(viewDir));
                    double score = dotProduct &lt; 0.3 ? 1.0 : (dotProduct &gt; 0.7 ? 2.0 : 3.0);
                    facesWithScores.Add(Tuple.Create(face, score));
                }
                catch
                {
                    facesWithScores.Add(Tuple.Create(face, 10.0));
                }
            }

            return facesWithScores
                .OrderBy(tuple =&gt; tuple.Item2)
                .Select(tuple =&gt; tuple.Item1)
                .ToList();
        }

        private void ExtractFacesFromGeometry(GeometryObject geomObj, List&lt;Face&gt; faces)
        {
            if (geomObj is GeometryInstance geomInstance)
            {
                GeometryElement symbolGeometry = geomInstance.GetSymbolGeometry();
                Transform instanceTransform = geomInstance.Transform;
                if (symbolGeometry != null)
                {
                    ExtractSolidsFromGeometry(symbolGeometry, instanceTransform, faces);
                }
                return;
            }

            if (!(geomObj is Solid solid) || solid.Faces.Size == 0)
            {
                return;
            }

            for (int i = 0; i &lt; solid.Faces.Size; i&#43;&#43;)
            {
                Face face = solid.Faces.get_Item(i);
                if (face != null &amp;&amp; face.Reference != null)
                {
                    faces.Add(face);
                }
            }
        }

        private void ExtractSolidsFromGeometry(GeometryElement geometry, Transform transform, List&lt;Face&gt; faces)
        {
            foreach (GeometryObject obj in geometry)
            {
                if (obj is GeometryInstance nestedInstance)
                {
                    GeometryElement nestedGeometry = nestedInstance.GetSymbolGeometry();
                    Transform combinedTransform = transform.Multiply(nestedInstance.Transform);
                    if (nestedGeometry != null)
                    {
                        ExtractSolidsFromGeometry(nestedGeometry, combinedTransform, faces);
                    }
                }
                else if (obj is Solid solid &amp;&amp; solid.Faces.Size &gt; 0)
                {
                    for (int i = 0; i &lt; solid.Faces.Size; i&#43;&#43;)
                    {
                        Face face = solid.Faces.get_Item(i);
                        if (face != null &amp;&amp; face.Reference != null)
                        {
                            faces.Add(face);
                        }
                    }
                }
            }
        }

        private XYZ CalculatePointOnFace(Element elem, Face face, XYZ pickedPoint)
        {
            if (face == null || pickedPoint == null)
                return pickedPoint;

            BoundingBoxUV faceBB = face.GetBoundingBox();
            IntersectionResult projResult = face.Project(pickedPoint);
            if (projResult == null)
                return pickedPoint;

            UV pickedUV = projResult.UVPoint;
            FamilyInstance fi = elem as FamilyInstance;
            if (fi != null)
            {
                Transform transform = fi.GetTransform();
                Transform inverseTransform = transform.Inverse;
                XYZ localPoint = inverseTransform.OfPoint(pickedPoint);
                XYZ faceNormal = face.ComputeNormal(pickedUV).Normalize();
                XYZ localNormal = inverseTransform.OfVector(faceNormal).Normalize();
                if (Math.Abs(localNormal.Z) &lt; 0.3)
                {
                    BoundingBoxXYZ bbox = fi.get_BoundingBox(null);
                    if (bbox != null)
                    {
                        double zPos = (bbox.Min.Z &#43; bbox.Max.Z) * 0.5;
                        XYZ localResult = new XYZ(localPoint.X, localPoint.Y, zPos);
                        XYZ globalResult = transform.OfPoint(localResult);
                        projResult = face.Project(globalResult);
                        if (projResult != null)
                        {
                            return face.Evaluate(projResult.UVPoint);
                        }
                    }
                }
            }

            UV adjustedUV = new UV(pickedUV.U, (faceBB.Min.V &#43; faceBB.Max.V) * 0.5);
            return face.Evaluate(adjustedUV);
        }

        private XYZ CalculateCurveLoopCentroid(CurveLoop curveLoop)
        {
            if (curveLoop == null || curveLoop.Count() == 0)
                return XYZ.Zero;

            XYZ sum = XYZ.Zero;
            int pointCount = 0;
            HashSet&lt;XYZ&gt; uniquePoints = new HashSet&lt;XYZ&gt;(new XYZEqualityComparer());
            foreach (Curve curve in curveLoop)
            {
                uniquePoints.Add(curve.GetEndPoint(0));
                uniquePoints.Add(curve.GetEndPoint(1));
            }
            foreach (XYZ point in uniquePoints)
            {
                sum &#43;= point;
                pointCount&#43;&#43;;
            }
            return pointCount &gt; 0 ? sum.Divide(pointCount) : XYZ.Zero;
        }

        private class XYZEqualityComparer : IEqualityComparer&lt;XYZ&gt;
        {
            private const double Tolerance = 0.0001;
            public bool Equals(XYZ x, XYZ y)
            {
                if (x == null &amp;&amp; y == null)
                    return true;
                if (x == null || y == null)
                    return false;
                return Math.Abs(x.X - y.X) &lt; Tolerance &amp;&amp;
                       Math.Abs(x.Y - y.Y) &lt; Tolerance &amp;&amp;
                       Math.Abs(x.Z - y.Z) &lt; Tolerance;
            }
            public int GetHashCode(XYZ obj)
            {
                if (obj == null)
                    return 0;
                double x = Math.Round(obj.X / Tolerance) * Tolerance;
                double y = Math.Round(obj.Y / Tolerance) * Tolerance;
                double z = Math.Round(obj.Z / Tolerance) * Tolerance;
                return x.GetHashCode() ^ y.GetHashCode() ^ z.GetHashCode();
            }
        }
    }
}



ViewsOnSheets.cs


  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133


using Autodesk.Revit.Attributes;
using Autodesk.Revit.DB;
using Autodesk.Revit.UI;
using ViewOnSheetsR2025.Services;
using ViewOnSheetsR2025.UI;

namespace ViewOnSheetsR2025
{
    [Transaction(TransactionMode.Manual)]
    public class ViewsOnSheets : IExternalCommand
    {
        public Result Execute(ExternalCommandData commandData, ref string message, ElementSet elements)
        {
            UIDocument uidoc = commandData.Application.ActiveUIDocument;
            Document doc = uidoc.Document;

            // 1. Collect unplaced views
            var unplacedViews = ViewsOnSheetsR2025Service.GetUnplacedViews(doc);
            if (unplacedViews.Count == 0)
            {
                TaskDialog.Show(
                    &#34;Разместить виды на листах&#34;,
                    &#34;Не найдено непомещённых, не-шаблонных видов.&#34;
                );
                return Result.Cancelled;
            }

            // 2. Collect all sheets
            var allSheets = ViewsOnSheetsR2025Service.GetAllSheets(doc);

            // 3. Collect title blocks
            var titleBlocks = new FilteredElementCollector(doc)
                .OfClass(typeof(FamilySymbol))
                .OfCategory(BuiltInCategory.OST_TitleBlocks)
                .Cast&lt;FamilySymbol&gt;()
                .ToList();

            if (titleBlocks.Count == 0)
            {
                TaskDialog.Show(
                    &#34;Разместить виды на листах&#34;,
                    &#34;В проекте не найдено штампов.&#34;
                );
                return Result.Cancelled;
            }

            // 4. Show selection window
            var window = new ViewsOnSheetsWindow(unplacedViews, allSheets, titleBlocks);
            bool? result = window.ShowDialog();
            if (result != true)
                return Result.Cancelled;

            // 5. Get selected views
            var selectedViews = window.SelectedViews;
            if (selectedViews == null || selectedViews.Count == 0)
            {
                TaskDialog.Show(
                    &#34;Разместить виды на листах&#34;,
                    &#34;Не выбраны виды.&#34;
                );
                return Result.Cancelled;
            }

            bool createNewSheets = window.CreateNewSheets;
            var selectedSheets = window.SelectedSheets;

            if (!createNewSheets)
            {
                if (selectedSheets == null || selectedSheets.Count != selectedViews.Count)
                {
                    TaskDialog.Show(
                        &#34;Разместить виды на листах&#34;,
                        &#34;Количество выбранных листов должно совпадать с количеством выбранных видов.&#34;
                    );
                    return Result.Cancelled;
                }
            }

            // 6. Ask for point
            XYZ placementPoint;
            try
            {
                placementPoint = uidoc.Selection.PickPoint(
                    &#34;Укажите точку размещения на текущем листе. &#34; &#43;
                    &#34;Эта точка будет использована как центр для всех видов.&#34;
                );
            }
            catch (Exception ex)
            {
                TaskDialog.Show(
                    &#34;Разместить виды на листах&#34;,
                    &#34;Выбор точки отменён или завершился неудачно:\n&#34; &#43; ex.Message
                );
                return Result.Cancelled;
            }

            // 7. Build the dictionary of parameter values from the window
            var paramValues = new Dictionary&lt;string, string&gt;()
            {
                { &#34;Формат А&#34;,           window.SelectedFormatA     ?? &#34;&#34; },
                { &#34;Кратность&#34;,          window.SelectedMultiplicity ?? &#34;&#34; },
                { &#34;Книжная ориентация&#34;, window.SelectedOrientation  ?? &#34;&#34; }
            };

            // 8. Retrieve the user-chosen scale from the window
            int scale = window.SelectedViewScale;

            // 9. Place views on sheets
            try
            {
                ViewsOnSheetsR2025Service.PlaceViewsOnSheets(
                    doc,
                    createNewSheets,
                    selectedViews,
                    selectedSheets,
                    placementPoint,
                    window.SelectedTitleBlockId,
                    paramValues,
                    scale
                );
                return Result.Succeeded;
            }
            catch (Exception ex)
            {
                TaskDialog.Show(
                    &#34;Разместить виды на листах&#34;,
                    &#34;Ошибка при размещении видов:\n&#34; &#43; ex.Message
                );
                return Result.Failed;
            }
        }
    }
}



AutoLevelMarker.cs


  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170


using Autodesk.Revit.Attributes;
using Autodesk.Revit.DB;
using Autodesk.Revit.UI;

namespace CreateLevelMarkers
{
    [Transaction(TransactionMode.Manual)]
    public class Command : IExternalCommand
    {
        public Result Execute(ExternalCommandData commandData, ref string message, ElementSet elements)
        {
            UIApplication uiapp = commandData.Application;
            UIDocument uidoc = uiapp.ActiveUIDocument;
            Document doc = uidoc.Document;

            try
            {
                // Create and show the main form.
                AutoLevelMarker form = new AutoLevelMarker(doc);
                bool? dialogResult = form.ShowDialog();

                if (dialogResult != true)
                    return Result.Cancelled;

                // Retrieve user selections.
                var selectedSections = form.SelectedSections;
                var selectedFamilies = form.SelectedFamilies;
                var markerType = form.SelectedMarkerType;
                var offsetMeters = form.OffsetValue * 3.28084; // Convert meters to feet

                // Retrieve optional parameter names.
                var selectedSourceParam = form.SelectedSourceParam;
                var selectedTargetParam = form.SelectedTargetParam;

                // Process each section and create markers.
                using (Transaction t = new Transaction(doc, &#34;Create Level Markers&#34;))
                {
                    t.Start();

                    if (!markerType.IsActive)
                        markerType.Activate();

                    foreach (ViewSection section in selectedSections)
                    {
                        var instances = new FilteredElementCollector(doc, section.Id)
                            .OfClass(typeof(FamilyInstance))
                            .Cast&lt;FamilyInstance&gt;()
                            .Where(i =&gt;
                            {
                                try
                                {
                                    return i.Symbol != null &amp;&amp;
                                           i.Symbol.Family != null &amp;&amp;
                                           selectedFamilies.Contains(i.Symbol.Family.Name);
                                }
                                catch { return false; }
                            })
                            .ToList();

                        TaskDialog.Show(&#34;Найдено&#34;, &#34;Найдено &#34; &#43; instances.Count &#43; &#34; экземпляров&#34;);

                        foreach (FamilyInstance inst in instances)
                        {
                            try
                            {
                                BoundingBoxXYZ bb = inst.get_BoundingBox(null);
                                if (bb != null)
                                {
                                    XYZ center = (bb.Min &#43; bb.Max) * 0.5;
                                    XYZ placementPoint = new XYZ(center.X &#43; offsetMeters, center.Y, center.Z);

                                    FamilyInstance marker = doc.Create.NewFamilyInstance(
                                        placementPoint,
                                        markerType,
                                        section
                                    );

                                    // Optional: copy parameter value if both parameter names are provided.
                                    if (!string.IsNullOrEmpty(selectedSourceParam) &amp;&amp; !string.IsNullOrEmpty(selectedTargetParam))
                                    {
                                        var allParams = ParameterUtilities.GetAllParameters(inst);
                                        Parameter? sourceParam = allParams.ContainsKey(selectedSourceParam) ?
                                            allParams[selectedSourceParam] : null;
                                        if (sourceParam == null)
                                        {
                                            TaskDialog.Show(&#34;Ошибка&#34;, &#34;Параметр не найден: &#34; &#43; selectedSourceParam);
                                            continue;
                                        }

                                        double paramValue = 0;
                                        switch (sourceParam.StorageType)
                                        {
                                            case StorageType.Double:
                                                paramValue = sourceParam.AsDouble() * 1000;
                                                break;
                                            case StorageType.Integer:
                                                paramValue = sourceParam.AsInteger() * 1000;
                                                break;
                                            case StorageType.String:
                                                string stringValue = sourceParam.AsString();
                                                double tempValue;
                                                if (!string.IsNullOrEmpty(stringValue) &amp;&amp; double.TryParse(stringValue, out tempValue))
                                                    paramValue = tempValue * 1000;
                                                else
                                                {
                                                    TaskDialog.Show(&#34;Ошибка&#34;, &#34;Параметр имеет нечисловое значение: &#34; &#43; stringValue);
                                                    continue;
                                                }
                                                break;
                                            default:
                                                TaskDialog.Show(&#34;Ошибка&#34;, &#34;Параметр имеет неподдерживаемый тип хранения&#34;);
                                                continue;
                                        }

                                        var markerParams = ParameterUtilities.GetAllParameters(marker);
                                        Parameter? targetParam = markerParams.ContainsKey(selectedTargetParam) ?
                                            markerParams[selectedTargetParam] : null;
                                        if (targetParam != null)
                                        {
                                            if (targetParam.IsReadOnly)
                                            {
                                                TaskDialog.Show(&#34;Ошибка&#34;, &#34;Невозможно изменить параметр только для чтения: &#34; &#43; selectedTargetParam);
                                            }
                                            else
                                            {
                                                switch (targetParam.StorageType)
                                                {
                                                    case StorageType.Double:
                                                        targetParam.Set((double)paramValue);
                                                        break;
                                                    case StorageType.Integer:
                                                        targetParam.Set((int)paramValue);
                                                        break;
                                                    case StorageType.String:
                                                        targetParam.Set(paramValue.ToString());
                                                        break;
                                                    default:
                                                        TaskDialog.Show(&#34;Ошибка&#34;, &#34;Целевой параметр имеет неподдерживаемый тип хранения&#34;);
                                                        break;
                                                }
                                            }
                                        }
                                        else
                                        {
                                            TaskDialog.Show(&#34;Ошибка&#34;, &#34;Параметр не найден в маркере: &#34; &#43; selectedTargetParam);
                                        }
                                    }
                                }
                            }
                            catch (Exception ex)
                            {
                                TaskDialog.Show(&#34;Ошибка&#34;, &#34;Ошибка при обработке экземпляра: &#34; &#43; ex.Message);
                            }
                        }
                    }

                    t.Commit();
                }

                //MessageBox.Show(&#34;Логика создания маркеров будет запущена.&#34;, &#34;Информация&#34;, MessageBoxButton.OK, MessageBoxImage.Information);
                return Result.Succeeded;
            }
            catch (Exception ex)
            {
                message = ex.Message;
                return Result.Failed;
            }
        }
    }
}


">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/posts/post-13/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.6d585472a409a8f504e6bf969a2864fd1288e629997cd2926dd96376ae22831b.css" integrity="sha256-bVhUcqQJqPUE5r&#43;Wmihk/RKI5imZfNKSbdljdq4igxs=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/post-13/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="http://localhost:1313/posts/post-13/">
  <meta property="og:site_name" content="Blog">
  <meta property="og:title" content="C# &#43; Revit API: Lesson 13 - Case Study №1 [Section Automation]">
  <meta property="og:description" content="Introduction This is the automation I made for my client and I would like to share the insights.
Plan: Refactor the automation to properly organize the project. Start with understanding how to organize the WPF forms better. Seems like I have lots of functions just jumbled together in each file. Basically, separate and refactor the code. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 Based on analyzing the current &#34;Cmds_AutoDim.cs&#34; implementation and comparing it with the established codebase patterns, here are my refactoring suggestions: Key Refactoring Recommendations 1. Namespace Inconsistency Current: namespace DimensionAutomation Suggested: namespace UKON.Commands.General - Follow the established pattern from other command files in the same directory 2. Class Naming Convention Current: public class DimensionAutomation Suggested: public class Cmd_AutoDim - Match the naming pattern used throughout the codebase (e.g., Cmd_Test, Cmd_1Button) 3. Variable Naming Consistency Current: UIApplication uiapp = commandData.Application; Suggested: var uiApp = commandData.Application; - Follow the camelCase pattern used in other files (uiApp, uiDoc, not uiapp, uidoc) 4. Comments Structure Current: Uses // only elements actually visible in this view Suggested: Add proper method-level XML documentation comments like other files: /// &lt;summary&gt; /// Auto-dimensioning command for section views /// &lt;/summary&gt; 5. File Organization Current: Single complex class with multiple private methods Suggested: Consider splitting into: - Main command class (Cmd_AutoDim) - Separate service/helper classes for dimension logic - This follows the single responsibility principle 6. Error Handling Pattern Current: Generic try-catch with Russian error messages Suggested: - Use consistent error message language (English like other files) - Follow the established error handling pattern from other commands 7. External Dependencies Current: References DimensionAutomation.UI namespace Suggested: Ensure UI classes follow the project&#39;s namespace structure (UKON.UI or similar) 8. Transaction Naming Current: &#34;Создание маркеров и размерений&#34; (Russian) Suggested: Use English transaction names for consistency 9. Method Extraction Opportunities The Execute method is quite long. Consider extracting: - User input validation logic - Section processing setup - Error message display logic 10. Constants Organization Current: MIN_CURVE_LENGTH defined in class Suggested: Consider a constants class or configuration file for project-wide constants The current implementation is functional but doesn&#39;t follow the established architectural patterns of the UKON project. The main issues are namespace inconsistency, naming conventions, and language mixing. Old Code Project Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 Solution |-&gt; ViewOnSheets2025 |-&gt; Dependencies |-&gt; Properties |-&gt; Commands |-&gt; AutoLevelMarker.cs |-&gt; DimensionAutomation.cs |-&gt; RevitSectionCreator.cs |-&gt; SpotDimensionAutomation.cs |-&gt; ViewsOnSheets.cs |-&gt; Globals |-&gt; ElementTypeInfo.cs |-&gt; ParameterUtilities.cs |-&gt; PointOnElement.cs |-&gt; Resources |-&gt; Icons |-&gt; Services |-&gt; ViewsOnSheetsR2025Service.cs |-&gt; UI |-&gt; AutoLevelMarker.xaml |-&gt; DimensionAutomationWindow.xaml |-&gt; RevitSectionsCreatorWindow.xaml |-&gt; ViewOnSheetsR2025Windown.xaml |-&gt; Application.cs |-&gt; guRoo.addin RevitSectionCreator.cs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 using Autodesk.Revit.Attributes; using Autodesk.Revit.DB; using Autodesk.Revit.UI; using RevitSectionCreator.UI; namespace RevitSectionCreator { [Transaction(TransactionMode.Manual)] public class Command : IExternalCommand { public Result Execute(ExternalCommandData commandData, ref string message, ElementSet elements) { UIApplication uiapp = commandData.Application; UIDocument uidoc = uiapp.ActiveUIDocument; Document doc = uidoc.Document; try { // STEP 1: Collect element types for section creation. List&lt;ElementTypeInfo&gt; elementTypes = new List&lt;ElementTypeInfo&gt;(); // Collect FamilyInstance elements and group them by the family name. var familyInstances = new FilteredElementCollector(doc) .OfClass(typeof(FamilyInstance)) .Cast&lt;FamilyInstance&gt;() .ToList(); var familyGroups = familyInstances .GroupBy(fi =&gt; fi.Symbol.FamilyName) .Select(g =&gt; new ElementTypeInfo { TypeName = g.Key, Category = &#34;Семейство&#34;, // &#34;Family&#34; in Russian ElementIds = g.Select(fi =&gt; fi.Id).ToList() }) .ToList(); elementTypes.AddRange(familyGroups); // Collect DirectShape elements. var directShapes = new FilteredElementCollector(doc) .OfClass(typeof(DirectShape)) .Cast&lt;DirectShape&gt;() .ToList(); var directShapeGroups = directShapes .GroupBy(ds =&gt; ds.Category?.Name ?? &#34;Без категории&#34;) .Select(g =&gt; new ElementTypeInfo { TypeName = $&#34;DirectShape - {g.Key}&#34;, Category = &#34;DirectShape&#34;, ElementIds = g.Select(ds =&gt; ds.Id).ToList() }) .ToList(); elementTypes.AddRange(directShapeGroups); // Collect ImportInstance elements (excluding links). var importInstances = new FilteredElementCollector(doc) .OfClass(typeof(ImportInstance)) .Cast&lt;ImportInstance&gt;() .Where(ii =&gt; !ii.IsLinked) .ToList(); var importGroups = importInstances .GroupBy(ii =&gt; ii.Category?.Name ?? &#34;Без категории импорта&#34;) .Select(g =&gt; new ElementTypeInfo { TypeName = $&#34;Import - {g.Key}&#34;, Category = &#34;Import&#34;, ElementIds = g.Select(ii =&gt; ii.Id).ToList() }) .ToList(); elementTypes.AddRange(importGroups); if (elementTypes.Count == 0) { TaskDialog.Show(&#34;Ошибка&#34;, &#34;В документе не найдено подходящих элементов.&#34;); return Result.Failed; } // Sort the element types by category then by type name. elementTypes = elementTypes .OrderBy(et =&gt; et.Category) .ThenBy(et =&gt; et.TypeName) .ToList(); // STEP 2: Display the unified WPF window to get user choices. RevitSectionCreatorWindow sectionWindow = new RevitSectionCreatorWindow(elementTypes); if (sectionWindow.ShowDialog() != true) { return Result.Cancelled; } // Retrieve selections from the combined window. ElementTypeInfo selectedType = sectionWindow.SelectedElementType; string selectedFace = sectionWindow.SelectedFace; // e.g., &#34;Левая грань&#34; double offsetMm = sectionWindow.OffsetValue; // STEP 3: Create section views. using (Transaction t = new Transaction(doc, $&#34;Создание разрезов для {selectedType.TypeName}&#34;)) { t.Start(); // Get the Section ViewFamilyType. using ViewFamilyType sectionType = new FilteredElementCollector(doc) .OfClass(typeof(ViewFamilyType)) .Cast&lt;ViewFamilyType&gt;() .FirstOrDefault(vt =&gt; vt.ViewFamily == ViewFamily.Section); if (sectionType == null) { TaskDialog.Show(&#34;Ошибка&#34;, &#34;Не найден тип семейства для разреза.&#34;); return Result.Failed; } // Retrieve the actual elements from the selected type. List&lt;Element&gt; elementsToProcess = new List&lt;Element&gt;(); foreach (ElementId id in selectedType.ElementIds) { Element elem = doc.GetElement(id); if (elem != null) { elementsToProcess.Add(elem); } } if (!elementsToProcess.Any()) { TaskDialog.Show(&#34;Ошибка&#34;, $&#34;Элементы типа &#39;{selectedType.TypeName}&#39; не найдены.&#34;); return Result.Failed; } // Determine the base direction from the selected face. XYZ baseDirection = GetDirectionFromFace(selectedFace); int sectionCount = 0; foreach (Element element in elementsToProcess) { string elementMark = GetElementMark(element) ?? element.Name; List&lt;ElementId&gt; partIds = new List&lt;ElementId&gt;(); // For FamilyInstance elements, try to get associated parts. if (element is FamilyInstance familyInstance) { ICollection&lt;ElementId&gt; associatedParts = PartUtils.GetAssociatedParts(doc, familyInstance.Id, true, true); partIds.AddRange(associatedParts); } // If no associated parts, use the element itself. if (partIds.Count == 0) { partIds.Add(element.Id); } foreach (ElementId partId in partIds) { Element part = doc.GetElement(partId); string partMark = GetElementMark(part) ?? part.Name; // Use the base direction from the unified dialog. XYZ finalDirection = baseDirection; // Find the best-aligned face on the element. Face chosenFace = GetLocalDirectionFace(part, finalDirection); if (chosenFace == null) continue; // Create the section view. ViewSection sectionView = CreateSectionView(doc, sectionType.Id, chosenFace, offsetMm); if (sectionView != null) { try { // Build a name for the new section view. string rawPartName = !string.IsNullOrEmpty(partMark) ? partMark : elementMark; string faceLabel = selectedFace.Replace(&#34; &#34;, &#34;&#34;); // Remove spaces for naming. string offsetStrForm = (offsetMm % 1 == 0) ? $&#34;{(int)offsetMm}мм&#34; : $&#34;{offsetMm}мм&#34;; string combinedName = $&#34;{rawPartName}_{faceLabel}_{offsetStrForm}&#34;; string uniqueName = GenerateUniqueName(doc, combinedName); sectionView.Name = uniqueName; // Apply crop region to the section view. CreateViewCrop(sectionView, chosenFace); sectionCount&#43;&#43;; } catch (Exception ex) { TaskDialog.Show(&#34;Предупреждение&#34;, $&#34;Не удалось задать имя для вида: {ex.Message}&#34;); } } } } t.Commit(); TaskDialog.Show(&#34;Успех&#34;, $&#34;Создано {sectionCount} разрезов для {selectedType.TypeName}.&#34;); } return Result.Succeeded; } catch (Exception ex) { message = ex.Message; return Result.Failed; } } #region Helper Methods // Maps Russian face names to direction vectors. private XYZ GetDirectionFromFace(string faceName) { var directionMap = new Dictionary&lt;string, XYZ&gt; { { &#34;Левая грань&#34;, new XYZ(-1, 0, 0) }, { &#34;Правая грань&#34;, new XYZ(1, 0, 0) }, { &#34;Передняя грань&#34;, new XYZ(0, 1, 0) }, { &#34;Задняя грань&#34;, new XYZ(0, -1, 0) }, { &#34;Верхняя грань&#34;, new XYZ(0, 0, 1) }, { &#34;Нижняя грань&#34;, new XYZ(0, 0, -1) } }; if (directionMap.TryGetValue(faceName, out XYZ direction)) { return direction; } return XYZ.BasisY; // Fallback } // Retrieves the element&#39;s &#34;mark&#34; or returns its name. private string GetElementMark(Element element) { Parameter markParam = element.get_Parameter(BuiltInParameter.ALL_MODEL_MARK); if (markParam != null &amp;&amp; markParam.HasValue) { string markValue = markParam.AsString(); if (!string.IsNullOrEmpty(markValue) &amp;&amp; markValue.Contains(&#34;Ст.&#34;)) { string numberPart = markValue.Split(new[] { &#34;Ст.&#34; }, StringSplitOptions.None)[1].Trim(); return $&#34;О_Р_{numberPart}&#34;; } return markValue; } return null; } // Generates a unique name for a view by appending additional characters if needed. private string GenerateUniqueName(Document doc, string baseName) { string testName = baseName; int counter = 1; List&lt;string&gt; existingNames = new FilteredElementCollector(doc) .OfClass(typeof(View)) .Cast&lt;View&gt;() .Select(v =&gt; v.Name) .ToList(); while (existingNames.Contains(testName)) { counter&#43;&#43;; testName = baseName &#43; new string(&#39;*&#39;, counter); } return testName; } // Creates a crop boundary (CurveLoop) from a given face. private CurveLoop CreateCropBoundary(Face face) { try { BoundingBoxUV uvBbox = face.GetBoundingBox(); List&lt;XYZ&gt; points = new List&lt;XYZ&gt; { face.Evaluate(new UV(uvBbox.Min.U, uvBbox.Min.V)), face.Evaluate(new UV(uvBbox.Max.U, uvBbox.Min.V)), face.Evaluate(new UV(uvBbox.Max.U, uvBbox.Max.V)), face.Evaluate(new UV(uvBbox.Min.U, uvBbox.Max.V)) }; List&lt;Curve&gt; curves = new List&lt;Curve&gt;(); for (int i = 0; i &lt; 4; i&#43;&#43;) { XYZ start = points[i]; XYZ end = points[(i &#43; 1) % 4]; curves.Add(Line.CreateBound(start, end)); } return CurveLoop.Create(curves); } catch { return null; } } // Sets up the crop boundary on a section view. private bool CreateViewCrop(ViewSection view, Face face) { try { if (!view.CropBoxActive) view.CropBoxActive = true; CurveLoop cropLoop = CreateCropBoundary(face); if (cropLoop != null) { view.GetCropRegionShapeManager().SetCropShape(cropLoop); return true; } return false; } catch { return false; } } // Determines the face on an element that best aligns with the local direction. private Face GetLocalDirectionFace(Element element, XYZ localDir) { Transform instTransform = Transform.Identity; if (element is FamilyInstance familyInstance) instTransform = familyInstance.GetTransform(); else if (element is ImportInstance importInstance &amp;&amp; !importInstance.IsLinked) instTransform = importInstance.GetTransform(); Transform invTransform = instTransform.Inverse; Face chosenFace = null; double bestAlignment = -999; Options options = new Options { ComputeReferences = true, DetailLevel = ViewDetailLevel.Fine }; GeometryElement geoElem = element.get_Geometry(options); if (geoElem == null) return null; void ProcessGeometry(GeometryObject geo, Transform transform) { if (geo is Solid solid &amp;&amp; solid.Volume &gt; 0) { foreach (Face face in solid.Faces) { XYZ faceNormalWorld = face.ComputeNormal(new UV(0.5, 0.5)).Normalize(); XYZ faceNormalLocal = invTransform.OfVector(faceNormalWorld).Normalize(); double alignment = faceNormalLocal.DotProduct(localDir); if (alignment &gt; bestAlignment) { bestAlignment = alignment; chosenFace = face; } } } else if (geo is GeometryInstance instance) { Transform instanceTransform = instance.Transform; GeometryElement instGeo = instance.GetInstanceGeometry(); if (instGeo != null) { foreach (GeometryObject obj in instGeo) { ProcessGeometry(obj, instanceTransform); } } } } foreach (GeometryObject geo in geoElem) { ProcessGeometry(geo, Transform.Identity); } return chosenFace; } // Creates and returns a section view based on the given face and offset. private ViewSection CreateSectionView(Document doc, ElementId sectionTypeId, Face face, double offsetMm) { try { // 1. Compute face center in world coords BoundingBoxUV uvBbox = face.GetBoundingBox(); double midU = (uvBbox.Min.U &#43; uvBbox.Max.U) / 2.0; double midV = (uvBbox.Min.V &#43; uvBbox.Max.V) / 2.0; XYZ faceCenter = face.Evaluate(new UV(midU, midV)); // 2. Get the outward normal, then invert it for “inward” view direction XYZ faceNormalOut = face.ComputeNormal(new UV(midU, midV)).Normalize(); XYZ inwardNormal = faceNormalOut.Multiply(-1.0); // 3. Build the section’s coordinate system Transform transFace = Transform.Identity; transFace.Origin = faceCenter; transFace.BasisZ = inwardNormal; // ← view direction toward element // 4. Choose a reasonable X axis for the section XYZ basisX = inwardNormal.CrossProduct(XYZ.BasisZ); if (basisX.IsAlmostEqualTo(XYZ.Zero)) basisX = inwardNormal.CrossProduct(XYZ.BasisX); transFace.BasisX = basisX.Normalize(); transFace.BasisY = transFace.BasisZ.CrossProduct(transFace.BasisX).Normalize(); // 5. Apply offset *along* the inward normal // Convert mm → ft, then move inward double offsetFt = offsetMm / 304.8; transFace.Origin = faceCenter.Add(inwardNormal.Multiply(offsetFt)); // 6. Define the crop box in this new coordinate system BoundingBoxXYZ sectionBox = new BoundingBoxXYZ { Transform = transFace, Min = new XYZ(-2.5, -50, -0.1), Max = new XYZ(2.5, 50, 0.25) }; // 7. Create and return the section return ViewSection.CreateSection(doc, sectionTypeId, sectionBox); } catch { return null; } } #endregion } } DimensionAutomation.cs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 using Autodesk.Revit.Attributes; using Autodesk.Revit.DB; using Autodesk.Revit.UI; using DimensionAutomation.UI; namespace DimensionAutomation { [Transaction(TransactionMode.Manual)] public class DimensionAutomation : IExternalCommand { private const double MIN_CURVE_LENGTH = 0.001; private XYZ GetVerticalInView(XYZ viewDir) { XYZ upDir = XYZ.BasisZ; XYZ verticalInView = upDir - viewDir.Multiply(upDir.DotProduct(viewDir)); if (verticalInView.GetLength() &lt; MIN_CURVE_LENGTH) return null; return verticalInView.Normalize(); } public Result Execute(ExternalCommandData commandData, ref string message, ElementSet elements) { UIApplication uiapp = commandData.Application; UIDocument uidoc = uiapp.ActiveUIDocument; Document doc = uidoc.Document; try { // Show the WPF window to get user choices. var window = new DimensionAutomationWindow(doc); if (window.ShowDialog() != true) return Result.Cancelled; // Gather user selections. var selectedSections = window.SelectedSectionViews; var selectedFamilyTypes = window.SelectedFamilyTypes; var selectedDimType = window.SelectedDimensionType; double offsetFeet = window.OffsetValue * 3.28084; // Basic checks. if (selectedSections == null || !selectedSections.Any()) { TaskDialog.Show(&#34;Информация&#34;, &#34;Не выбраны виды разрезов. Операция прервана.&#34;); return Result.Cancelled; } if (selectedFamilyTypes == null || selectedFamilyTypes.Count &lt; 1) { TaskDialog.Show(&#34;Информация&#34;, &#34;Пожалуйста, выберите хотя бы один тип семейства.&#34;); return Result.Cancelled; } if (selectedDimType == null) { TaskDialog.Show(&#34;Ошибка&#34;, &#34;Тип размерения не выбран.&#34;); return Result.Failed; } // Process each section view. foreach (ViewSection section in selectedSections) { var instancesInSection = new FilteredElementCollector(doc, section.Id) // only elements actually visible in this view .WherePasses(new VisibleInViewFilter(doc, section.Id)) .OfClass(typeof(FamilyInstance)) .Cast&lt;FamilyInstance&gt;() .Where(fi =&gt; fi.Symbol != null &amp;&amp; selectedFamilyTypes.Any(fs =&gt; fs.Id == fi.Symbol.Id) ) .ToList(); if (instancesInSection.Count &lt; 2) continue; ProcessSectionView(doc, section, selectedDimType, offsetFeet, instancesInSection); } return Result.Succeeded; } catch (Exception ex) { TaskDialog.Show(&#34;Ошибка&#34;, ex.ToString()); return Result.Failed; } } private void ProcessSectionView( Document doc, ViewSection sectionView, DimensionType dimType, double offsetDist, List&lt;FamilyInstance&gt; instances) { XYZ viewDir = sectionView.ViewDirection.Normalize(); XYZ verticalInView = GetVerticalInView(viewDir); if (verticalInView == null) { TaskDialog.Show(&#34;Предупреждение&#34;, &#34;Не удалось определить вертикальное направление в виде. Пропускаем...&#34;); return; } // Collect bounding-box centers. var centerPoints = new List&lt;XYZ&gt;(); foreach (var fi in instances) { var bb = fi.get_BoundingBox(sectionView); if (bb != null) centerPoints.Add((bb.Min &#43; bb.Max) * 0.5); } if (centerPoints.Count &lt; 2) return; // Sort by vertical location. centerPoints = centerPoints.OrderBy(p =&gt; p.DotProduct(verticalInView)).ToList(); var dim3d = centerPoints.Last() - centerPoints.First(); if (dim3d.GetLength() &lt; MIN_CURVE_LENGTH) return; // Project onto view plane. double dot = dim3d.DotProduct(viewDir); var dimPlane = (dim3d - viewDir.Multiply(dot)).Normalize(); if (dimPlane.GetLength() &lt; MIN_CURVE_LENGTH) return; // Marker direction perpendicular to dimension direction. var refsDir = viewDir.CrossProduct(dimPlane).Normalize(); using (var tx = new Transaction(doc, &#34;Создание маркеров и размерений&#34;)) { tx.Start(); var detailLines = CreateDetailLines(doc, sectionView, centerPoints, refsDir, viewDir); doc.Regenerate(); CreateDimensionsBetweenLines(doc, sectionView, detailLines, refsDir, offsetDist, dimType); tx.Commit(); } } private List&lt;DetailCurve&gt; CreateDetailLines( Document doc, ViewSection view, List&lt;XYZ&gt; centers, XYZ dir, XYZ viewDir) { const double markerLen = 0.01; double half = markerLen * 0.5; var lines = new List&lt;DetailCurve&gt;(); foreach (var cp in centers) { var p1 = cp - dir.Multiply(half); var p2 = cp &#43; dir.Multiply(half); var plane = Plane.CreateByNormalAndOrigin(viewDir, cp); SketchPlane.Create(doc, plane); var line = Line.CreateBound(p1, p2); lines.Add(doc.Create.NewDetailCurve(view, line)); } return lines; } private void CreateDimensionsBetweenLines( Document doc, ViewSection view, List&lt;DetailCurve&gt; lines, XYZ dir, double offset, DimensionType dimType) { for (int i = 0; i &lt; lines.Count - 1; i&#43;&#43;) { var a = lines[i].GeometryCurve.Reference; var b = lines[i &#43; 1].GeometryCurve.Reference; var refs = new ReferenceArray(); refs.Append(a); refs.Append(b); var midA = lines[i].GeometryCurve.Evaluate(0.5, true); var midB = lines[i &#43; 1].GeometryCurve.Evaluate(0.5, true); var offA = midA &#43; dir.Multiply(offset); var offB = midB &#43; dir.Multiply(offset); var dimLine = Line.CreateBound(offA, offB); try { var dim = doc.Create.NewDimension(view, dimLine, refs); dim.ChangeTypeId(dimType.Id); } catch (Exception ex) { TaskDialog.Show(&#34;Ошибка размерения&#34;, ex.Message); } } } } } SpotDimensionAutomation.cs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 using Autodesk.Revit.Attributes; using Autodesk.Revit.DB; using Autodesk.Revit.UI; using Autodesk.Revit.UI.Selection; namespace SpotDimensionTest.Commands { [Transaction(TransactionMode.Manual)] public class StartupCommand : IExternalCommand { public Result Execute(ExternalCommandData commandData, ref string message, ElementSet elements) { UIDocument uiDoc = commandData.Application.ActiveUIDocument; Document doc = uiDoc.Document; // STEP 1: Get preselected section views ICollection&lt;ElementId&gt; viewSelectionIds = uiDoc.Selection.GetElementIds(); List&lt;View&gt; sectionViews = new List&lt;View&gt;(); foreach (ElementId id in viewSelectionIds) { Element elem = doc.GetElement(id); if (elem is View view &amp;&amp; view.ViewType == ViewType.Section) { sectionViews.Add(view); } } if (sectionViews.Count == 0) { TaskDialog.Show(&#34;Info&#34;, &#34;Please preselect section views first.&#34;); return Result.Succeeded; } // STEP 2: User selects family instances TaskDialog.Show(&#34;Selection&#34;, &#34;Now select family instances for spot elevations.&#34;); IList&lt;Reference&gt; familyRefs = uiDoc.Selection.PickObjects( ObjectType.Element, &#34;Select family instances for spot elevations&#34;); List&lt;FamilyInstance&gt; familyInstances = new List&lt;FamilyInstance&gt;(); foreach (Reference famRef in familyRefs) { Element elem = doc.GetElement(famRef.ElementId); if (elem is FamilyInstance fi) { familyInstances.Add(fi); } } if (familyInstances.Count == 0) { TaskDialog.Show(&#34;Info&#34;, &#34;No family instances selected.&#34;); return Result.Succeeded; } // STEP 3: User picks a face on one of the family instances Reference pickedFaceRef = uiDoc.Selection.PickObject( ObjectType.Face, &#34;Select a face for the spot elevation&#34;); Element templateElem = doc.GetElement(pickedFaceRef.ElementId); GeometryObject geoObj = templateElem.GetGeometryObjectFromReference(pickedFaceRef); Face templateFace = geoObj as Face; XYZ pickedPoint = pickedFaceRef.GlobalPoint; XYZ templatePoint = CalculatePointOnFace(templateElem, templateFace, pickedPoint); // STEP 4: Create spot elevations on all family instances in all section views using (TransactionGroup tg = new TransactionGroup(doc, &#34;Create Multiple Spot Elevations&#34;)) { tg.Start(); int successCount = 0; foreach (View sectionView in sectionViews) { using (Transaction trans = new Transaction(doc, $&#34;Spot Elevations in {sectionView.Name}&#34;)) { trans.Start(); XYZ viewDir = sectionView.ViewDirection.Normalize(); XYZ viewUp = sectionView.UpDirection.Normalize(); XYZ viewRight = viewUp.CrossProduct(viewDir).Normalize(); XYZ originalPickedPoint = pickedPoint; bool viewHasSpotElevation = false; foreach (FamilyInstance fi in familyInstances) { if (viewHasSpotElevation) break; try { Options options = new Options { View = sectionView, ComputeReferences = true, IncludeNonVisibleObjects = false }; GeometryElement geometry = fi.get_Geometry(options); if (geometry == null || !geometry.Any()) continue; List&lt;Face&gt; faces = new List&lt;Face&gt;(); foreach (GeometryObject geomObj in geometry) { ExtractFacesFromGeometry(geomObj, faces); } List&lt;Face&gt; sortedFaces = SortFacesByPriority(faces, viewDir); foreach (Face face in sortedFaces) { try { IList&lt;CurveLoop&gt; edgeLoops = face.GetEdgesAsCurveLoops(); if (edgeLoops == null || edgeLoops.Count == 0) continue; XYZ elevationPoint = CalculatePointOnFace(fi, face, originalPickedPoint); try { XYZ lineStart = elevationPoint - viewRight * 0.1; XYZ lineEnd = elevationPoint &#43; viewRight * 0.1; DetailLine? detailLine = doc.Create.NewDetailCurve( sectionView, Line.CreateBound(lineStart, lineEnd)) as DetailLine; if (detailLine != null) { XYZ bendPoint = elevationPoint; XYZ endPoint = elevationPoint; Reference lineRef = new Reference(detailLine); try { SpotDimension spotDimension = doc.Create.NewSpotElevation( sectionView, lineRef, elevationPoint, bendPoint, endPoint, elevationPoint, true); if (spotDimension != null) { successCount&#43;&#43;; viewHasSpotElevation = true; break; } else { doc.Delete(detailLine.Id); } } catch (Exception) { doc.Delete(detailLine.Id); } } } catch (Exception) { // Continue to next face } } catch (Exception) { // Continue to next face } if (viewHasSpotElevation) break; } } catch (Exception) { // Continue to next family instance } if (viewHasSpotElevation) break; } trans.Commit(); } } tg.Assimilate(); TaskDialog resultsDialog = new TaskDialog(&#34;Spot Elevation Results&#34;); resultsDialog.MainInstruction = $&#34;Created {successCount} spot elevations&#34;; resultsDialog.MainContent = $&#34;Successfully created {successCount} spot elevations across {sectionViews.Count} section views.&#34;; resultsDialog.Show(); } return Result.Succeeded; } private List&lt;Face&gt; SortFacesByPriority(List&lt;Face&gt; faces, XYZ viewDir) { List&lt;Tuple&lt;Face, double&gt;&gt; facesWithScores = new List&lt;Tuple&lt;Face, double&gt;&gt;(); foreach (Face face in faces) { try { BoundingBoxUV bb = face.GetBoundingBox(); UV centerUV = new UV((bb.Min.U &#43; bb.Max.U) * 0.5, (bb.Min.V &#43; bb.Max.V) * 0.5); XYZ normal = face.ComputeNormal(centerUV); double dotProduct = Math.Abs(normal.DotProduct(viewDir)); double score = dotProduct &lt; 0.3 ? 1.0 : (dotProduct &gt; 0.7 ? 2.0 : 3.0); facesWithScores.Add(Tuple.Create(face, score)); } catch { facesWithScores.Add(Tuple.Create(face, 10.0)); } } return facesWithScores .OrderBy(tuple =&gt; tuple.Item2) .Select(tuple =&gt; tuple.Item1) .ToList(); } private void ExtractFacesFromGeometry(GeometryObject geomObj, List&lt;Face&gt; faces) { if (geomObj is GeometryInstance geomInstance) { GeometryElement symbolGeometry = geomInstance.GetSymbolGeometry(); Transform instanceTransform = geomInstance.Transform; if (symbolGeometry != null) { ExtractSolidsFromGeometry(symbolGeometry, instanceTransform, faces); } return; } if (!(geomObj is Solid solid) || solid.Faces.Size == 0) { return; } for (int i = 0; i &lt; solid.Faces.Size; i&#43;&#43;) { Face face = solid.Faces.get_Item(i); if (face != null &amp;&amp; face.Reference != null) { faces.Add(face); } } } private void ExtractSolidsFromGeometry(GeometryElement geometry, Transform transform, List&lt;Face&gt; faces) { foreach (GeometryObject obj in geometry) { if (obj is GeometryInstance nestedInstance) { GeometryElement nestedGeometry = nestedInstance.GetSymbolGeometry(); Transform combinedTransform = transform.Multiply(nestedInstance.Transform); if (nestedGeometry != null) { ExtractSolidsFromGeometry(nestedGeometry, combinedTransform, faces); } } else if (obj is Solid solid &amp;&amp; solid.Faces.Size &gt; 0) { for (int i = 0; i &lt; solid.Faces.Size; i&#43;&#43;) { Face face = solid.Faces.get_Item(i); if (face != null &amp;&amp; face.Reference != null) { faces.Add(face); } } } } } private XYZ CalculatePointOnFace(Element elem, Face face, XYZ pickedPoint) { if (face == null || pickedPoint == null) return pickedPoint; BoundingBoxUV faceBB = face.GetBoundingBox(); IntersectionResult projResult = face.Project(pickedPoint); if (projResult == null) return pickedPoint; UV pickedUV = projResult.UVPoint; FamilyInstance fi = elem as FamilyInstance; if (fi != null) { Transform transform = fi.GetTransform(); Transform inverseTransform = transform.Inverse; XYZ localPoint = inverseTransform.OfPoint(pickedPoint); XYZ faceNormal = face.ComputeNormal(pickedUV).Normalize(); XYZ localNormal = inverseTransform.OfVector(faceNormal).Normalize(); if (Math.Abs(localNormal.Z) &lt; 0.3) { BoundingBoxXYZ bbox = fi.get_BoundingBox(null); if (bbox != null) { double zPos = (bbox.Min.Z &#43; bbox.Max.Z) * 0.5; XYZ localResult = new XYZ(localPoint.X, localPoint.Y, zPos); XYZ globalResult = transform.OfPoint(localResult); projResult = face.Project(globalResult); if (projResult != null) { return face.Evaluate(projResult.UVPoint); } } } } UV adjustedUV = new UV(pickedUV.U, (faceBB.Min.V &#43; faceBB.Max.V) * 0.5); return face.Evaluate(adjustedUV); } private XYZ CalculateCurveLoopCentroid(CurveLoop curveLoop) { if (curveLoop == null || curveLoop.Count() == 0) return XYZ.Zero; XYZ sum = XYZ.Zero; int pointCount = 0; HashSet&lt;XYZ&gt; uniquePoints = new HashSet&lt;XYZ&gt;(new XYZEqualityComparer()); foreach (Curve curve in curveLoop) { uniquePoints.Add(curve.GetEndPoint(0)); uniquePoints.Add(curve.GetEndPoint(1)); } foreach (XYZ point in uniquePoints) { sum &#43;= point; pointCount&#43;&#43;; } return pointCount &gt; 0 ? sum.Divide(pointCount) : XYZ.Zero; } private class XYZEqualityComparer : IEqualityComparer&lt;XYZ&gt; { private const double Tolerance = 0.0001; public bool Equals(XYZ x, XYZ y) { if (x == null &amp;&amp; y == null) return true; if (x == null || y == null) return false; return Math.Abs(x.X - y.X) &lt; Tolerance &amp;&amp; Math.Abs(x.Y - y.Y) &lt; Tolerance &amp;&amp; Math.Abs(x.Z - y.Z) &lt; Tolerance; } public int GetHashCode(XYZ obj) { if (obj == null) return 0; double x = Math.Round(obj.X / Tolerance) * Tolerance; double y = Math.Round(obj.Y / Tolerance) * Tolerance; double z = Math.Round(obj.Z / Tolerance) * Tolerance; return x.GetHashCode() ^ y.GetHashCode() ^ z.GetHashCode(); } } } } ViewsOnSheets.cs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 using Autodesk.Revit.Attributes; using Autodesk.Revit.DB; using Autodesk.Revit.UI; using ViewOnSheetsR2025.Services; using ViewOnSheetsR2025.UI; namespace ViewOnSheetsR2025 { [Transaction(TransactionMode.Manual)] public class ViewsOnSheets : IExternalCommand { public Result Execute(ExternalCommandData commandData, ref string message, ElementSet elements) { UIDocument uidoc = commandData.Application.ActiveUIDocument; Document doc = uidoc.Document; // 1. Collect unplaced views var unplacedViews = ViewsOnSheetsR2025Service.GetUnplacedViews(doc); if (unplacedViews.Count == 0) { TaskDialog.Show( &#34;Разместить виды на листах&#34;, &#34;Не найдено непомещённых, не-шаблонных видов.&#34; ); return Result.Cancelled; } // 2. Collect all sheets var allSheets = ViewsOnSheetsR2025Service.GetAllSheets(doc); // 3. Collect title blocks var titleBlocks = new FilteredElementCollector(doc) .OfClass(typeof(FamilySymbol)) .OfCategory(BuiltInCategory.OST_TitleBlocks) .Cast&lt;FamilySymbol&gt;() .ToList(); if (titleBlocks.Count == 0) { TaskDialog.Show( &#34;Разместить виды на листах&#34;, &#34;В проекте не найдено штампов.&#34; ); return Result.Cancelled; } // 4. Show selection window var window = new ViewsOnSheetsWindow(unplacedViews, allSheets, titleBlocks); bool? result = window.ShowDialog(); if (result != true) return Result.Cancelled; // 5. Get selected views var selectedViews = window.SelectedViews; if (selectedViews == null || selectedViews.Count == 0) { TaskDialog.Show( &#34;Разместить виды на листах&#34;, &#34;Не выбраны виды.&#34; ); return Result.Cancelled; } bool createNewSheets = window.CreateNewSheets; var selectedSheets = window.SelectedSheets; if (!createNewSheets) { if (selectedSheets == null || selectedSheets.Count != selectedViews.Count) { TaskDialog.Show( &#34;Разместить виды на листах&#34;, &#34;Количество выбранных листов должно совпадать с количеством выбранных видов.&#34; ); return Result.Cancelled; } } // 6. Ask for point XYZ placementPoint; try { placementPoint = uidoc.Selection.PickPoint( &#34;Укажите точку размещения на текущем листе. &#34; &#43; &#34;Эта точка будет использована как центр для всех видов.&#34; ); } catch (Exception ex) { TaskDialog.Show( &#34;Разместить виды на листах&#34;, &#34;Выбор точки отменён или завершился неудачно:\n&#34; &#43; ex.Message ); return Result.Cancelled; } // 7. Build the dictionary of parameter values from the window var paramValues = new Dictionary&lt;string, string&gt;() { { &#34;Формат А&#34;, window.SelectedFormatA ?? &#34;&#34; }, { &#34;Кратность&#34;, window.SelectedMultiplicity ?? &#34;&#34; }, { &#34;Книжная ориентация&#34;, window.SelectedOrientation ?? &#34;&#34; } }; // 8. Retrieve the user-chosen scale from the window int scale = window.SelectedViewScale; // 9. Place views on sheets try { ViewsOnSheetsR2025Service.PlaceViewsOnSheets( doc, createNewSheets, selectedViews, selectedSheets, placementPoint, window.SelectedTitleBlockId, paramValues, scale ); return Result.Succeeded; } catch (Exception ex) { TaskDialog.Show( &#34;Разместить виды на листах&#34;, &#34;Ошибка при размещении видов:\n&#34; &#43; ex.Message ); return Result.Failed; } } } } AutoLevelMarker.cs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 using Autodesk.Revit.Attributes; using Autodesk.Revit.DB; using Autodesk.Revit.UI; namespace CreateLevelMarkers { [Transaction(TransactionMode.Manual)] public class Command : IExternalCommand { public Result Execute(ExternalCommandData commandData, ref string message, ElementSet elements) { UIApplication uiapp = commandData.Application; UIDocument uidoc = uiapp.ActiveUIDocument; Document doc = uidoc.Document; try { // Create and show the main form. AutoLevelMarker form = new AutoLevelMarker(doc); bool? dialogResult = form.ShowDialog(); if (dialogResult != true) return Result.Cancelled; // Retrieve user selections. var selectedSections = form.SelectedSections; var selectedFamilies = form.SelectedFamilies; var markerType = form.SelectedMarkerType; var offsetMeters = form.OffsetValue * 3.28084; // Convert meters to feet // Retrieve optional parameter names. var selectedSourceParam = form.SelectedSourceParam; var selectedTargetParam = form.SelectedTargetParam; // Process each section and create markers. using (Transaction t = new Transaction(doc, &#34;Create Level Markers&#34;)) { t.Start(); if (!markerType.IsActive) markerType.Activate(); foreach (ViewSection section in selectedSections) { var instances = new FilteredElementCollector(doc, section.Id) .OfClass(typeof(FamilyInstance)) .Cast&lt;FamilyInstance&gt;() .Where(i =&gt; { try { return i.Symbol != null &amp;&amp; i.Symbol.Family != null &amp;&amp; selectedFamilies.Contains(i.Symbol.Family.Name); } catch { return false; } }) .ToList(); TaskDialog.Show(&#34;Найдено&#34;, &#34;Найдено &#34; &#43; instances.Count &#43; &#34; экземпляров&#34;); foreach (FamilyInstance inst in instances) { try { BoundingBoxXYZ bb = inst.get_BoundingBox(null); if (bb != null) { XYZ center = (bb.Min &#43; bb.Max) * 0.5; XYZ placementPoint = new XYZ(center.X &#43; offsetMeters, center.Y, center.Z); FamilyInstance marker = doc.Create.NewFamilyInstance( placementPoint, markerType, section ); // Optional: copy parameter value if both parameter names are provided. if (!string.IsNullOrEmpty(selectedSourceParam) &amp;&amp; !string.IsNullOrEmpty(selectedTargetParam)) { var allParams = ParameterUtilities.GetAllParameters(inst); Parameter? sourceParam = allParams.ContainsKey(selectedSourceParam) ? allParams[selectedSourceParam] : null; if (sourceParam == null) { TaskDialog.Show(&#34;Ошибка&#34;, &#34;Параметр не найден: &#34; &#43; selectedSourceParam); continue; } double paramValue = 0; switch (sourceParam.StorageType) { case StorageType.Double: paramValue = sourceParam.AsDouble() * 1000; break; case StorageType.Integer: paramValue = sourceParam.AsInteger() * 1000; break; case StorageType.String: string stringValue = sourceParam.AsString(); double tempValue; if (!string.IsNullOrEmpty(stringValue) &amp;&amp; double.TryParse(stringValue, out tempValue)) paramValue = tempValue * 1000; else { TaskDialog.Show(&#34;Ошибка&#34;, &#34;Параметр имеет нечисловое значение: &#34; &#43; stringValue); continue; } break; default: TaskDialog.Show(&#34;Ошибка&#34;, &#34;Параметр имеет неподдерживаемый тип хранения&#34;); continue; } var markerParams = ParameterUtilities.GetAllParameters(marker); Parameter? targetParam = markerParams.ContainsKey(selectedTargetParam) ? markerParams[selectedTargetParam] : null; if (targetParam != null) { if (targetParam.IsReadOnly) { TaskDialog.Show(&#34;Ошибка&#34;, &#34;Невозможно изменить параметр только для чтения: &#34; &#43; selectedTargetParam); } else { switch (targetParam.StorageType) { case StorageType.Double: targetParam.Set((double)paramValue); break; case StorageType.Integer: targetParam.Set((int)paramValue); break; case StorageType.String: targetParam.Set(paramValue.ToString()); break; default: TaskDialog.Show(&#34;Ошибка&#34;, &#34;Целевой параметр имеет неподдерживаемый тип хранения&#34;); break; } } } else { TaskDialog.Show(&#34;Ошибка&#34;, &#34;Параметр не найден в маркере: &#34; &#43; selectedTargetParam); } } } } catch (Exception ex) { TaskDialog.Show(&#34;Ошибка&#34;, &#34;Ошибка при обработке экземпляра: &#34; &#43; ex.Message); } } } t.Commit(); } //MessageBox.Show(&#34;Логика создания маркеров будет запущена.&#34;, &#34;Информация&#34;, MessageBoxButton.OK, MessageBoxImage.Information); return Result.Succeeded; } catch (Exception ex) { message = ex.Message; return Result.Failed; } } } } ">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-08-16T19:10:51+03:00">
    <meta property="article:modified_time" content="2025-08-16T19:10:51+03:00">
    <meta property="article:tag" content="C#">
    <meta property="article:tag" content="Revit">
    <meta property="article:tag" content="Tutorial">
      <meta property="og:image" content="http://localhost:1313/LogoAYD.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:1313/LogoAYD.png">
<meta name="twitter:title" content="C# &#43; Revit API: Lesson 13 - Case Study №1 [Section Automation]">
<meta name="twitter:description" content="Introduction
This is the automation I made for my client and I would like to share the insights.
Plan:

Refactor the automation to properly organize the project.
Start with understanding how to organize the WPF forms better.
Seems like I have lots of functions just jumbled together in each file.
Basically, separate and refactor the code.



 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69


Based on analyzing the current &#34;Cmds_AutoDim.cs&#34; implementation and comparing it with the established codebase patterns, here are my refactoring suggestions:  
  
Key Refactoring Recommendations  

1. Namespace Inconsistency  

Current: namespace DimensionAutomation  
Suggested: namespace UKON.Commands.General  
	- Follow the established pattern from other command files in the same directory  

2. Class Naming Convention  

Current: public class DimensionAutomation  
Suggested: public class Cmd_AutoDim  
	- Match the naming pattern used throughout the codebase (e.g., Cmd_Test, Cmd_1Button)  

3. Variable Naming Consistency  

Current: UIApplication uiapp = commandData.Application;  
Suggested: var uiApp = commandData.Application;  
	- Follow the camelCase pattern used in other files (uiApp, uiDoc, not uiapp, uidoc)  

4. Comments Structure  

Current: Uses // only elements actually visible in this view  
Suggested: Add proper method-level XML documentation comments like other files:  
/// &lt;summary&gt;  
/// Auto-dimensioning command for section views  
/// &lt;/summary&gt;  

5. File Organization  

Current: Single complex class with multiple private methods  
Suggested: Consider splitting into:  
	- Main command class (Cmd_AutoDim)  
	- Separate service/helper classes for dimension logic  
	- This follows the single responsibility principle  

6. Error Handling Pattern  

Current: Generic try-catch with Russian error messages  
Suggested:  
	- Use consistent error message language (English like other files)  
	- Follow the established error handling pattern from other commands  

7. External Dependencies  

Current: References DimensionAutomation.UI namespace  
Suggested: Ensure UI classes follow the project&#39;s namespace structure (UKON.UI or similar)  

8. Transaction Naming  

Current: &#34;Создание маркеров и размерений&#34; (Russian)  
Suggested: Use English transaction names for consistency  

9. Method Extraction Opportunities  

The Execute method is quite long. Consider extracting:  
	- User input validation logic  
	- Section processing setup  
	- Error message display logic  

10. Constants Organization  

Current: MIN_CURVE_LENGTH defined in class  
Suggested: Consider a constants class or configuration file for project-wide constants  

The current implementation is functional but doesn&#39;t follow the established architectural patterns of the UKON  
project. The main issues are namespace inconsistency, naming conventions, and language mixing.


Old Code
Project Solution


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25


Solution
|-&gt; ViewOnSheets2025
	|-&gt; Dependencies
	|-&gt; Properties
	|-&gt; Commands
		|-&gt; AutoLevelMarker.cs 
		|-&gt; DimensionAutomation.cs  
		|-&gt; RevitSectionCreator.cs 
		|-&gt; SpotDimensionAutomation.cs 
		|-&gt; ViewsOnSheets.cs 
	|-&gt; Globals 
		|-&gt; ElementTypeInfo.cs
		|-&gt; ParameterUtilities.cs
		|-&gt; PointOnElement.cs
	|-&gt; Resources
		|-&gt; Icons
	|-&gt; Services
		|-&gt; ViewsOnSheetsR2025Service.cs
	|-&gt; UI
		|-&gt; AutoLevelMarker.xaml
		|-&gt; DimensionAutomationWindow.xaml
		|-&gt; RevitSectionsCreatorWindow.xaml
		|-&gt; ViewOnSheetsR2025Windown.xaml
	|-&gt; Application.cs           
	|-&gt; guRoo.addin



RevitSectionCreator.cs


  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380
381
382
383
384
385
386
387
388
389
390
391
392
393
394
395
396
397
398
399
400
401
402
403
404
405
406
407
408
409
410
411
412
413
414
415
416
417
418
419
420
421
422
423
424
425
426


using Autodesk.Revit.Attributes;
using Autodesk.Revit.DB;
using Autodesk.Revit.UI;
using RevitSectionCreator.UI;

namespace RevitSectionCreator
{
    [Transaction(TransactionMode.Manual)]
    public class Command : IExternalCommand
    {
        public Result Execute(ExternalCommandData commandData, ref string message, ElementSet elements)
        {
            UIApplication uiapp = commandData.Application;
            UIDocument uidoc = uiapp.ActiveUIDocument;
            Document doc = uidoc.Document;

            try
            {
                // STEP 1: Collect element types for section creation.
                List&lt;ElementTypeInfo&gt; elementTypes = new List&lt;ElementTypeInfo&gt;();

                // Collect FamilyInstance elements and group them by the family name.
                var familyInstances = new FilteredElementCollector(doc)
                    .OfClass(typeof(FamilyInstance))
                    .Cast&lt;FamilyInstance&gt;()
                    .ToList();

                var familyGroups = familyInstances
                    .GroupBy(fi =&gt; fi.Symbol.FamilyName)
                    .Select(g =&gt; new ElementTypeInfo
                    {
                        TypeName = g.Key,
                        Category = &#34;Семейство&#34;, // &#34;Family&#34; in Russian
                        ElementIds = g.Select(fi =&gt; fi.Id).ToList()
                    })
                    .ToList();
                elementTypes.AddRange(familyGroups);

                // Collect DirectShape elements.
                var directShapes = new FilteredElementCollector(doc)
                    .OfClass(typeof(DirectShape))
                    .Cast&lt;DirectShape&gt;()
                    .ToList();

                var directShapeGroups = directShapes
                    .GroupBy(ds =&gt; ds.Category?.Name ?? &#34;Без категории&#34;)
                    .Select(g =&gt; new ElementTypeInfo
                    {
                        TypeName = $&#34;DirectShape - {g.Key}&#34;,
                        Category = &#34;DirectShape&#34;,
                        ElementIds = g.Select(ds =&gt; ds.Id).ToList()
                    })
                    .ToList();
                elementTypes.AddRange(directShapeGroups);

                // Collect ImportInstance elements (excluding links).
                var importInstances = new FilteredElementCollector(doc)
                    .OfClass(typeof(ImportInstance))
                    .Cast&lt;ImportInstance&gt;()
                    .Where(ii =&gt; !ii.IsLinked)
                    .ToList();

                var importGroups = importInstances
                    .GroupBy(ii =&gt; ii.Category?.Name ?? &#34;Без категории импорта&#34;)
                    .Select(g =&gt; new ElementTypeInfo
                    {
                        TypeName = $&#34;Import - {g.Key}&#34;,
                        Category = &#34;Import&#34;,
                        ElementIds = g.Select(ii =&gt; ii.Id).ToList()
                    })
                    .ToList();
                elementTypes.AddRange(importGroups);

                if (elementTypes.Count == 0)
                {
                    TaskDialog.Show(&#34;Ошибка&#34;, &#34;В документе не найдено подходящих элементов.&#34;);
                    return Result.Failed;
                }

                // Sort the element types by category then by type name.
                elementTypes = elementTypes
                    .OrderBy(et =&gt; et.Category)
                    .ThenBy(et =&gt; et.TypeName)
                    .ToList();

                // STEP 2: Display the unified WPF window to get user choices.
                RevitSectionCreatorWindow sectionWindow = new RevitSectionCreatorWindow(elementTypes);
                if (sectionWindow.ShowDialog() != true)
                {
                    return Result.Cancelled;
                }

                // Retrieve selections from the combined window.
                ElementTypeInfo selectedType = sectionWindow.SelectedElementType;
                string selectedFace = sectionWindow.SelectedFace; // e.g., &#34;Левая грань&#34;
                double offsetMm = sectionWindow.OffsetValue;

                // STEP 3: Create section views.
                using (Transaction t = new Transaction(doc, $&#34;Создание разрезов для {selectedType.TypeName}&#34;))
                {
                    t.Start();

                    // Get the Section ViewFamilyType.
                    using ViewFamilyType sectionType = new FilteredElementCollector(doc)
                        .OfClass(typeof(ViewFamilyType))
                        .Cast&lt;ViewFamilyType&gt;()
                        .FirstOrDefault(vt =&gt; vt.ViewFamily == ViewFamily.Section);

                    if (sectionType == null)
                    {
                        TaskDialog.Show(&#34;Ошибка&#34;, &#34;Не найден тип семейства для разреза.&#34;);
                        return Result.Failed;
                    }

                    // Retrieve the actual elements from the selected type.
                    List&lt;Element&gt; elementsToProcess = new List&lt;Element&gt;();
                    foreach (ElementId id in selectedType.ElementIds)
                    {
                        Element elem = doc.GetElement(id);
                        if (elem != null)
                        {
                            elementsToProcess.Add(elem);
                        }
                    }

                    if (!elementsToProcess.Any())
                    {
                        TaskDialog.Show(&#34;Ошибка&#34;, $&#34;Элементы типа &#39;{selectedType.TypeName}&#39; не найдены.&#34;);
                        return Result.Failed;
                    }

                    // Determine the base direction from the selected face.
                    XYZ baseDirection = GetDirectionFromFace(selectedFace);
                    int sectionCount = 0;

                    foreach (Element element in elementsToProcess)
                    {
                        string elementMark = GetElementMark(element) ?? element.Name;
                        List&lt;ElementId&gt; partIds = new List&lt;ElementId&gt;();

                        // For FamilyInstance elements, try to get associated parts.
                        if (element is FamilyInstance familyInstance)
                        {
                            ICollection&lt;ElementId&gt; associatedParts = PartUtils.GetAssociatedParts(doc, familyInstance.Id, true, true);
                            partIds.AddRange(associatedParts);
                        }

                        // If no associated parts, use the element itself.
                        if (partIds.Count == 0)
                        {
                            partIds.Add(element.Id);
                        }

                        foreach (ElementId partId in partIds)
                        {
                            Element part = doc.GetElement(partId);
                            string partMark = GetElementMark(part) ?? part.Name;

                            // Use the base direction from the unified dialog.
                            XYZ finalDirection = baseDirection;

                            // Find the best-aligned face on the element.
                            Face chosenFace = GetLocalDirectionFace(part, finalDirection);
                            if (chosenFace == null)
                                continue;

                            // Create the section view.
                            ViewSection sectionView = CreateSectionView(doc, sectionType.Id, chosenFace, offsetMm);
                            if (sectionView != null)
                            {
                                try
                                {
                                    // Build a name for the new section view.
                                    string rawPartName = !string.IsNullOrEmpty(partMark) ? partMark : elementMark;
                                    string faceLabel = selectedFace.Replace(&#34; &#34;, &#34;&#34;); // Remove spaces for naming.
                                    string offsetStrForm = (offsetMm % 1 == 0) ? $&#34;{(int)offsetMm}мм&#34; : $&#34;{offsetMm}мм&#34;;
                                    string combinedName = $&#34;{rawPartName}_{faceLabel}_{offsetStrForm}&#34;;
                                    string uniqueName = GenerateUniqueName(doc, combinedName);
                                    sectionView.Name = uniqueName;

                                    // Apply crop region to the section view.
                                    CreateViewCrop(sectionView, chosenFace);
                                    sectionCount&#43;&#43;;
                                }
                                catch (Exception ex)
                                {
                                    TaskDialog.Show(&#34;Предупреждение&#34;, $&#34;Не удалось задать имя для вида: {ex.Message}&#34;);
                                }
                            }
                        }
                    }

                    t.Commit();
                    TaskDialog.Show(&#34;Успех&#34;, $&#34;Создано {sectionCount} разрезов для {selectedType.TypeName}.&#34;);
                }

                return Result.Succeeded;
            }
            catch (Exception ex)
            {
                message = ex.Message;
                return Result.Failed;
            }
        }

        #region Helper Methods

        // Maps Russian face names to direction vectors.
        private XYZ GetDirectionFromFace(string faceName)
        {
            var directionMap = new Dictionary&lt;string, XYZ&gt;
            {
                { &#34;Левая грань&#34;, new XYZ(-1, 0, 0) },
                { &#34;Правая грань&#34;, new XYZ(1, 0, 0) },
                { &#34;Передняя грань&#34;, new XYZ(0, 1, 0) },
                { &#34;Задняя грань&#34;, new XYZ(0, -1, 0) },
                { &#34;Верхняя грань&#34;, new XYZ(0, 0, 1) },
                { &#34;Нижняя грань&#34;, new XYZ(0, 0, -1) }
            };

            if (directionMap.TryGetValue(faceName, out XYZ direction))
            {
                return direction;
            }
            return XYZ.BasisY; // Fallback
        }

        // Retrieves the element&#39;s &#34;mark&#34; or returns its name.
        private string GetElementMark(Element element)
        {
            Parameter markParam = element.get_Parameter(BuiltInParameter.ALL_MODEL_MARK);
            if (markParam != null &amp;&amp; markParam.HasValue)
            {
                string markValue = markParam.AsString();
                if (!string.IsNullOrEmpty(markValue) &amp;&amp; markValue.Contains(&#34;Ст.&#34;))
                {
                    string numberPart = markValue.Split(new[] { &#34;Ст.&#34; }, StringSplitOptions.None)[1].Trim();
                    return $&#34;О_Р_{numberPart}&#34;;
                }
                return markValue;
            }
            return null;
        }

        // Generates a unique name for a view by appending additional characters if needed.
        private string GenerateUniqueName(Document doc, string baseName)
        {
            string testName = baseName;
            int counter = 1;
            List&lt;string&gt; existingNames = new FilteredElementCollector(doc)
                .OfClass(typeof(View))
                .Cast&lt;View&gt;()
                .Select(v =&gt; v.Name)
                .ToList();

            while (existingNames.Contains(testName))
            {
                counter&#43;&#43;;
                testName = baseName &#43; new string(&#39;*&#39;, counter);
            }
            return testName;
        }

        // Creates a crop boundary (CurveLoop) from a given face.
        private CurveLoop CreateCropBoundary(Face face)
        {
            try
            {
                BoundingBoxUV uvBbox = face.GetBoundingBox();
                List&lt;XYZ&gt; points = new List&lt;XYZ&gt;
                {
                    face.Evaluate(new UV(uvBbox.Min.U, uvBbox.Min.V)),
                    face.Evaluate(new UV(uvBbox.Max.U, uvBbox.Min.V)),
                    face.Evaluate(new UV(uvBbox.Max.U, uvBbox.Max.V)),
                    face.Evaluate(new UV(uvBbox.Min.U, uvBbox.Max.V))
                };

                List&lt;Curve&gt; curves = new List&lt;Curve&gt;();
                for (int i = 0; i &lt; 4; i&#43;&#43;)
                {
                    XYZ start = points[i];
                    XYZ end = points[(i &#43; 1) % 4];
                    curves.Add(Line.CreateBound(start, end));
                }
                return CurveLoop.Create(curves);
            }
            catch
            {
                return null;
            }
        }

        // Sets up the crop boundary on a section view.
        private bool CreateViewCrop(ViewSection view, Face face)
        {
            try
            {
                if (!view.CropBoxActive)
                    view.CropBoxActive = true;

                CurveLoop cropLoop = CreateCropBoundary(face);
                if (cropLoop != null)
                {
                    view.GetCropRegionShapeManager().SetCropShape(cropLoop);
                    return true;
                }
                return false;
            }
            catch
            {
                return false;
            }
        }

        // Determines the face on an element that best aligns with the local direction.
        private Face GetLocalDirectionFace(Element element, XYZ localDir)
        {
            Transform instTransform = Transform.Identity;
            if (element is FamilyInstance familyInstance)
                instTransform = familyInstance.GetTransform();
            else if (element is ImportInstance importInstance &amp;&amp; !importInstance.IsLinked)
                instTransform = importInstance.GetTransform();

            Transform invTransform = instTransform.Inverse;
            Face chosenFace = null;
            double bestAlignment = -999;

            Options options = new Options
            {
                ComputeReferences = true,
                DetailLevel = ViewDetailLevel.Fine
            };

            GeometryElement geoElem = element.get_Geometry(options);
            if (geoElem == null)
                return null;

            void ProcessGeometry(GeometryObject geo, Transform transform)
            {
                if (geo is Solid solid &amp;&amp; solid.Volume &gt; 0)
                {
                    foreach (Face face in solid.Faces)
                    {
                        XYZ faceNormalWorld = face.ComputeNormal(new UV(0.5, 0.5)).Normalize();
                        XYZ faceNormalLocal = invTransform.OfVector(faceNormalWorld).Normalize();
                        double alignment = faceNormalLocal.DotProduct(localDir);
                        if (alignment &gt; bestAlignment)
                        {
                            bestAlignment = alignment;
                            chosenFace = face;
                        }
                    }
                }
                else if (geo is GeometryInstance instance)
                {
                    Transform instanceTransform = instance.Transform;
                    GeometryElement instGeo = instance.GetInstanceGeometry();
                    if (instGeo != null)
                    {
                        foreach (GeometryObject obj in instGeo)
                        {
                            ProcessGeometry(obj, instanceTransform);
                        }
                    }
                }
            }

            foreach (GeometryObject geo in geoElem)
            {
                ProcessGeometry(geo, Transform.Identity);
            }
            return chosenFace;
        }

        // Creates and returns a section view based on the given face and offset.
        private ViewSection CreateSectionView(Document doc, ElementId sectionTypeId, Face face, double offsetMm)
        {
            try
            {
                // 1. Compute face center in world coords
                BoundingBoxUV uvBbox = face.GetBoundingBox();
                double midU = (uvBbox.Min.U &#43; uvBbox.Max.U) / 2.0;
                double midV = (uvBbox.Min.V &#43; uvBbox.Max.V) / 2.0;
                XYZ faceCenter = face.Evaluate(new UV(midU, midV));

                // 2. Get the outward normal, then invert it for “inward” view direction
                XYZ faceNormalOut = face.ComputeNormal(new UV(midU, midV)).Normalize();
                XYZ inwardNormal = faceNormalOut.Multiply(-1.0);

                // 3. Build the section’s coordinate system
                Transform transFace = Transform.Identity;
                transFace.Origin = faceCenter;
                transFace.BasisZ = inwardNormal; // ← view direction toward element

                // 4. Choose a reasonable X axis for the section
                XYZ basisX = inwardNormal.CrossProduct(XYZ.BasisZ);
                if (basisX.IsAlmostEqualTo(XYZ.Zero))
                    basisX = inwardNormal.CrossProduct(XYZ.BasisX);
                transFace.BasisX = basisX.Normalize();
                transFace.BasisY = transFace.BasisZ.CrossProduct(transFace.BasisX).Normalize();

                // 5. Apply offset *along* the inward normal
                //    Convert mm → ft, then move inward
                double offsetFt = offsetMm / 304.8;
                transFace.Origin = faceCenter.Add(inwardNormal.Multiply(offsetFt));

                // 6. Define the crop box in this new coordinate system
                BoundingBoxXYZ sectionBox = new BoundingBoxXYZ
                {
                    Transform = transFace,
                    Min = new XYZ(-2.5, -50, -0.1),
                    Max = new XYZ(2.5, 50, 0.25)
                };

                // 7. Create and return the section
                return ViewSection.CreateSection(doc, sectionTypeId, sectionBox);
            }
            catch
            {
                return null;
            }
        }

        #endregion
    }
}



DimensionAutomation.cs


  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197


using Autodesk.Revit.Attributes;
using Autodesk.Revit.DB;
using Autodesk.Revit.UI;
using DimensionAutomation.UI;

namespace DimensionAutomation
{
    [Transaction(TransactionMode.Manual)]
    public class DimensionAutomation : IExternalCommand
    {
        private const double MIN_CURVE_LENGTH = 0.001;

        private XYZ GetVerticalInView(XYZ viewDir)
        {
            XYZ upDir = XYZ.BasisZ;
            XYZ verticalInView = upDir - viewDir.Multiply(upDir.DotProduct(viewDir));
            if (verticalInView.GetLength() &lt; MIN_CURVE_LENGTH)
                return null;
            return verticalInView.Normalize();
        }

        public Result Execute(ExternalCommandData commandData, ref string message, ElementSet elements)
        {
            UIApplication uiapp = commandData.Application;
            UIDocument uidoc = uiapp.ActiveUIDocument;
            Document doc = uidoc.Document;

            try
            {
                // Show the WPF window to get user choices.
                var window = new DimensionAutomationWindow(doc);
                if (window.ShowDialog() != true)
                    return Result.Cancelled;

                // Gather user selections.
                var selectedSections = window.SelectedSectionViews;
                var selectedFamilyTypes = window.SelectedFamilyTypes;
                var selectedDimType = window.SelectedDimensionType;
                double offsetFeet = window.OffsetValue * 3.28084;

                // Basic checks.
                if (selectedSections == null || !selectedSections.Any())
                {
                    TaskDialog.Show(&#34;Информация&#34;, &#34;Не выбраны виды разрезов. Операция прервана.&#34;);
                    return Result.Cancelled;
                }
                if (selectedFamilyTypes == null || selectedFamilyTypes.Count &lt; 1)
                {
                    TaskDialog.Show(&#34;Информация&#34;, &#34;Пожалуйста, выберите хотя бы один тип семейства.&#34;);
                    return Result.Cancelled;
                }
                if (selectedDimType == null)
                {
                    TaskDialog.Show(&#34;Ошибка&#34;, &#34;Тип размерения не выбран.&#34;);
                    return Result.Failed;
                }

                // Process each section view.
                foreach (ViewSection section in selectedSections)
                {
                    var instancesInSection = new FilteredElementCollector(doc, section.Id)
                        // only elements actually visible in this view
                        .WherePasses(new VisibleInViewFilter(doc, section.Id))
                        .OfClass(typeof(FamilyInstance))
                        .Cast&lt;FamilyInstance&gt;()
                        .Where(fi =&gt;
                            fi.Symbol != null &amp;&amp;
                            selectedFamilyTypes.Any(fs =&gt; fs.Id == fi.Symbol.Id)
                        )
                        .ToList();

                    if (instancesInSection.Count &lt; 2)
                        continue;

                    ProcessSectionView(doc, section, selectedDimType, offsetFeet, instancesInSection);
                }

                return Result.Succeeded;
            }
            catch (Exception ex)
            {
                TaskDialog.Show(&#34;Ошибка&#34;, ex.ToString());
                return Result.Failed;
            }
        }

        private void ProcessSectionView(
            Document doc,
            ViewSection sectionView,
            DimensionType dimType,
            double offsetDist,
            List&lt;FamilyInstance&gt; instances)
        {
            XYZ viewDir = sectionView.ViewDirection.Normalize();
            XYZ verticalInView = GetVerticalInView(viewDir);
            if (verticalInView == null)
            {
                TaskDialog.Show(&#34;Предупреждение&#34;, &#34;Не удалось определить вертикальное направление в виде. Пропускаем...&#34;);
                return;
            }

            // Collect bounding-box centers.
            var centerPoints = new List&lt;XYZ&gt;();
            foreach (var fi in instances)
            {
                var bb = fi.get_BoundingBox(sectionView);
                if (bb != null)
                    centerPoints.Add((bb.Min &#43; bb.Max) * 0.5);
            }
            if (centerPoints.Count &lt; 2)
                return;

            // Sort by vertical location.
            centerPoints = centerPoints.OrderBy(p =&gt; p.DotProduct(verticalInView)).ToList();
            var dim3d = centerPoints.Last() - centerPoints.First();
            if (dim3d.GetLength() &lt; MIN_CURVE_LENGTH)
                return;

            // Project onto view plane.
            double dot = dim3d.DotProduct(viewDir);
            var dimPlane = (dim3d - viewDir.Multiply(dot)).Normalize();
            if (dimPlane.GetLength() &lt; MIN_CURVE_LENGTH)
                return;

            // Marker direction perpendicular to dimension direction.
            var refsDir = viewDir.CrossProduct(dimPlane).Normalize();

            using (var tx = new Transaction(doc, &#34;Создание маркеров и размерений&#34;))
            {
                tx.Start();
                var detailLines = CreateDetailLines(doc, sectionView, centerPoints, refsDir, viewDir);
                doc.Regenerate();
                CreateDimensionsBetweenLines(doc, sectionView, detailLines, refsDir, offsetDist, dimType);
                tx.Commit();
            }
        }

        private List&lt;DetailCurve&gt; CreateDetailLines(
            Document doc,
            ViewSection view,
            List&lt;XYZ&gt; centers,
            XYZ dir,
            XYZ viewDir)
        {
            const double markerLen = 0.01;
            double half = markerLen * 0.5;
            var lines = new List&lt;DetailCurve&gt;();

            foreach (var cp in centers)
            {
                var p1 = cp - dir.Multiply(half);
                var p2 = cp &#43; dir.Multiply(half);
                var plane = Plane.CreateByNormalAndOrigin(viewDir, cp);
                SketchPlane.Create(doc, plane);
                var line = Line.CreateBound(p1, p2);
                lines.Add(doc.Create.NewDetailCurve(view, line));
            }
            return lines;
        }

        private void CreateDimensionsBetweenLines(
            Document doc,
            ViewSection view,
            List&lt;DetailCurve&gt; lines,
            XYZ dir,
            double offset,
            DimensionType dimType)
        {
            for (int i = 0; i &lt; lines.Count - 1; i&#43;&#43;)
            {
                var a = lines[i].GeometryCurve.Reference;
                var b = lines[i &#43; 1].GeometryCurve.Reference;
                var refs = new ReferenceArray();
                refs.Append(a);
                refs.Append(b);

                var midA = lines[i].GeometryCurve.Evaluate(0.5, true);
                var midB = lines[i &#43; 1].GeometryCurve.Evaluate(0.5, true);

                var offA = midA &#43; dir.Multiply(offset);
                var offB = midB &#43; dir.Multiply(offset);

                var dimLine = Line.CreateBound(offA, offB);

                try
                {
                    var dim = doc.Create.NewDimension(view, dimLine, refs);
                    dim.ChangeTypeId(dimType.Id);
                }
                catch (Exception ex)
                {
                    TaskDialog.Show(&#34;Ошибка размерения&#34;, ex.Message);
                }
            }
        }
    }
}



SpotDimensionAutomation.cs


  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369


using Autodesk.Revit.Attributes;
using Autodesk.Revit.DB;
using Autodesk.Revit.UI;
using Autodesk.Revit.UI.Selection;

namespace SpotDimensionTest.Commands
{
    [Transaction(TransactionMode.Manual)]
    public class StartupCommand : IExternalCommand
    {
        public Result Execute(ExternalCommandData commandData, ref string message, ElementSet elements)
        {
            UIDocument uiDoc = commandData.Application.ActiveUIDocument;
            Document doc = uiDoc.Document;

            // STEP 1: Get preselected section views
            ICollection&lt;ElementId&gt; viewSelectionIds = uiDoc.Selection.GetElementIds();
            List&lt;View&gt; sectionViews = new List&lt;View&gt;();

            foreach (ElementId id in viewSelectionIds)
            {
                Element elem = doc.GetElement(id);
                if (elem is View view &amp;&amp; view.ViewType == ViewType.Section)
                {
                    sectionViews.Add(view);
                }
            }

            if (sectionViews.Count == 0)
            {
                TaskDialog.Show(&#34;Info&#34;, &#34;Please preselect section views first.&#34;);
                return Result.Succeeded;
            }

            // STEP 2: User selects family instances
            TaskDialog.Show(&#34;Selection&#34;, &#34;Now select family instances for spot elevations.&#34;);
            IList&lt;Reference&gt; familyRefs = uiDoc.Selection.PickObjects(
                ObjectType.Element,
                &#34;Select family instances for spot elevations&#34;);

            List&lt;FamilyInstance&gt; familyInstances = new List&lt;FamilyInstance&gt;();
            foreach (Reference famRef in familyRefs)
            {
                Element elem = doc.GetElement(famRef.ElementId);
                if (elem is FamilyInstance fi)
                {
                    familyInstances.Add(fi);
                }
            }

            if (familyInstances.Count == 0)
            {
                TaskDialog.Show(&#34;Info&#34;, &#34;No family instances selected.&#34;);
                return Result.Succeeded;
            }

            // STEP 3: User picks a face on one of the family instances
            Reference pickedFaceRef = uiDoc.Selection.PickObject(
                ObjectType.Face,
                &#34;Select a face for the spot elevation&#34;);

            Element templateElem = doc.GetElement(pickedFaceRef.ElementId);
            GeometryObject geoObj = templateElem.GetGeometryObjectFromReference(pickedFaceRef);
            Face templateFace = geoObj as Face;
            XYZ pickedPoint = pickedFaceRef.GlobalPoint;
            XYZ templatePoint = CalculatePointOnFace(templateElem, templateFace, pickedPoint);

            // STEP 4: Create spot elevations on all family instances in all section views
            using (TransactionGroup tg = new TransactionGroup(doc, &#34;Create Multiple Spot Elevations&#34;))
            {
                tg.Start();

                int successCount = 0;

                foreach (View sectionView in sectionViews)
                {
                    using (Transaction trans = new Transaction(doc, $&#34;Spot Elevations in {sectionView.Name}&#34;))
                    {
                        trans.Start();

                        XYZ viewDir = sectionView.ViewDirection.Normalize();
                        XYZ viewUp = sectionView.UpDirection.Normalize();
                        XYZ viewRight = viewUp.CrossProduct(viewDir).Normalize();

                        XYZ originalPickedPoint = pickedPoint;
                        bool viewHasSpotElevation = false;

                        foreach (FamilyInstance fi in familyInstances)
                        {
                            if (viewHasSpotElevation)
                                break;

                            try
                            {
                                Options options = new Options
                                {
                                    View = sectionView,
                                    ComputeReferences = true,
                                    IncludeNonVisibleObjects = false
                                };

                                GeometryElement geometry = fi.get_Geometry(options);
                                if (geometry == null || !geometry.Any())
                                    continue;

                                List&lt;Face&gt; faces = new List&lt;Face&gt;();
                                foreach (GeometryObject geomObj in geometry)
                                {
                                    ExtractFacesFromGeometry(geomObj, faces);
                                }

                                List&lt;Face&gt; sortedFaces = SortFacesByPriority(faces, viewDir);

                                foreach (Face face in sortedFaces)
                                {
                                    try
                                    {
                                        IList&lt;CurveLoop&gt; edgeLoops = face.GetEdgesAsCurveLoops();
                                        if (edgeLoops == null || edgeLoops.Count == 0)
                                            continue;

                                        XYZ elevationPoint = CalculatePointOnFace(fi, face, originalPickedPoint);

                                        try
                                        {
                                            XYZ lineStart = elevationPoint - viewRight * 0.1;
                                            XYZ lineEnd = elevationPoint &#43; viewRight * 0.1;
                                            DetailLine? detailLine = doc.Create.NewDetailCurve(
                                                sectionView,
                                                Line.CreateBound(lineStart, lineEnd)) as DetailLine;

                                            if (detailLine != null)
                                            {
                                                XYZ bendPoint = elevationPoint;
                                                XYZ endPoint = elevationPoint;
                                                Reference lineRef = new Reference(detailLine);
                                                try
                                                {
                                                    SpotDimension spotDimension = doc.Create.NewSpotElevation(
                                                        sectionView,
                                                        lineRef,
                                                        elevationPoint,
                                                        bendPoint,
                                                        endPoint,
                                                        elevationPoint,
                                                        true);

                                                    if (spotDimension != null)
                                                    {
                                                        successCount&#43;&#43;;
                                                        viewHasSpotElevation = true;
                                                        break;
                                                    }
                                                    else
                                                    {
                                                        doc.Delete(detailLine.Id);
                                                    }
                                                }
                                                catch (Exception)
                                                {
                                                    doc.Delete(detailLine.Id);
                                                }
                                            }
                                        }
                                        catch (Exception)
                                        {
                                            // Continue to next face
                                        }
                                    }
                                    catch (Exception)
                                    {
                                        // Continue to next face
                                    }

                                    if (viewHasSpotElevation)
                                        break;
                                }
                            }
                            catch (Exception)
                            {
                                // Continue to next family instance
                            }

                            if (viewHasSpotElevation)
                                break;
                        }

                        trans.Commit();
                    }
                }

                tg.Assimilate();

                TaskDialog resultsDialog = new TaskDialog(&#34;Spot Elevation Results&#34;);
                resultsDialog.MainInstruction = $&#34;Created {successCount} spot elevations&#34;;
                resultsDialog.MainContent = $&#34;Successfully created {successCount} spot elevations across {sectionViews.Count} section views.&#34;;
                resultsDialog.Show();
            }
            return Result.Succeeded;
        }

        private List&lt;Face&gt; SortFacesByPriority(List&lt;Face&gt; faces, XYZ viewDir)
        {
            List&lt;Tuple&lt;Face, double&gt;&gt; facesWithScores = new List&lt;Tuple&lt;Face, double&gt;&gt;();

            foreach (Face face in faces)
            {
                try
                {
                    BoundingBoxUV bb = face.GetBoundingBox();
                    UV centerUV = new UV((bb.Min.U &#43; bb.Max.U) * 0.5, (bb.Min.V &#43; bb.Max.V) * 0.5);
                    XYZ normal = face.ComputeNormal(centerUV);
                    double dotProduct = Math.Abs(normal.DotProduct(viewDir));
                    double score = dotProduct &lt; 0.3 ? 1.0 : (dotProduct &gt; 0.7 ? 2.0 : 3.0);
                    facesWithScores.Add(Tuple.Create(face, score));
                }
                catch
                {
                    facesWithScores.Add(Tuple.Create(face, 10.0));
                }
            }

            return facesWithScores
                .OrderBy(tuple =&gt; tuple.Item2)
                .Select(tuple =&gt; tuple.Item1)
                .ToList();
        }

        private void ExtractFacesFromGeometry(GeometryObject geomObj, List&lt;Face&gt; faces)
        {
            if (geomObj is GeometryInstance geomInstance)
            {
                GeometryElement symbolGeometry = geomInstance.GetSymbolGeometry();
                Transform instanceTransform = geomInstance.Transform;
                if (symbolGeometry != null)
                {
                    ExtractSolidsFromGeometry(symbolGeometry, instanceTransform, faces);
                }
                return;
            }

            if (!(geomObj is Solid solid) || solid.Faces.Size == 0)
            {
                return;
            }

            for (int i = 0; i &lt; solid.Faces.Size; i&#43;&#43;)
            {
                Face face = solid.Faces.get_Item(i);
                if (face != null &amp;&amp; face.Reference != null)
                {
                    faces.Add(face);
                }
            }
        }

        private void ExtractSolidsFromGeometry(GeometryElement geometry, Transform transform, List&lt;Face&gt; faces)
        {
            foreach (GeometryObject obj in geometry)
            {
                if (obj is GeometryInstance nestedInstance)
                {
                    GeometryElement nestedGeometry = nestedInstance.GetSymbolGeometry();
                    Transform combinedTransform = transform.Multiply(nestedInstance.Transform);
                    if (nestedGeometry != null)
                    {
                        ExtractSolidsFromGeometry(nestedGeometry, combinedTransform, faces);
                    }
                }
                else if (obj is Solid solid &amp;&amp; solid.Faces.Size &gt; 0)
                {
                    for (int i = 0; i &lt; solid.Faces.Size; i&#43;&#43;)
                    {
                        Face face = solid.Faces.get_Item(i);
                        if (face != null &amp;&amp; face.Reference != null)
                        {
                            faces.Add(face);
                        }
                    }
                }
            }
        }

        private XYZ CalculatePointOnFace(Element elem, Face face, XYZ pickedPoint)
        {
            if (face == null || pickedPoint == null)
                return pickedPoint;

            BoundingBoxUV faceBB = face.GetBoundingBox();
            IntersectionResult projResult = face.Project(pickedPoint);
            if (projResult == null)
                return pickedPoint;

            UV pickedUV = projResult.UVPoint;
            FamilyInstance fi = elem as FamilyInstance;
            if (fi != null)
            {
                Transform transform = fi.GetTransform();
                Transform inverseTransform = transform.Inverse;
                XYZ localPoint = inverseTransform.OfPoint(pickedPoint);
                XYZ faceNormal = face.ComputeNormal(pickedUV).Normalize();
                XYZ localNormal = inverseTransform.OfVector(faceNormal).Normalize();
                if (Math.Abs(localNormal.Z) &lt; 0.3)
                {
                    BoundingBoxXYZ bbox = fi.get_BoundingBox(null);
                    if (bbox != null)
                    {
                        double zPos = (bbox.Min.Z &#43; bbox.Max.Z) * 0.5;
                        XYZ localResult = new XYZ(localPoint.X, localPoint.Y, zPos);
                        XYZ globalResult = transform.OfPoint(localResult);
                        projResult = face.Project(globalResult);
                        if (projResult != null)
                        {
                            return face.Evaluate(projResult.UVPoint);
                        }
                    }
                }
            }

            UV adjustedUV = new UV(pickedUV.U, (faceBB.Min.V &#43; faceBB.Max.V) * 0.5);
            return face.Evaluate(adjustedUV);
        }

        private XYZ CalculateCurveLoopCentroid(CurveLoop curveLoop)
        {
            if (curveLoop == null || curveLoop.Count() == 0)
                return XYZ.Zero;

            XYZ sum = XYZ.Zero;
            int pointCount = 0;
            HashSet&lt;XYZ&gt; uniquePoints = new HashSet&lt;XYZ&gt;(new XYZEqualityComparer());
            foreach (Curve curve in curveLoop)
            {
                uniquePoints.Add(curve.GetEndPoint(0));
                uniquePoints.Add(curve.GetEndPoint(1));
            }
            foreach (XYZ point in uniquePoints)
            {
                sum &#43;= point;
                pointCount&#43;&#43;;
            }
            return pointCount &gt; 0 ? sum.Divide(pointCount) : XYZ.Zero;
        }

        private class XYZEqualityComparer : IEqualityComparer&lt;XYZ&gt;
        {
            private const double Tolerance = 0.0001;
            public bool Equals(XYZ x, XYZ y)
            {
                if (x == null &amp;&amp; y == null)
                    return true;
                if (x == null || y == null)
                    return false;
                return Math.Abs(x.X - y.X) &lt; Tolerance &amp;&amp;
                       Math.Abs(x.Y - y.Y) &lt; Tolerance &amp;&amp;
                       Math.Abs(x.Z - y.Z) &lt; Tolerance;
            }
            public int GetHashCode(XYZ obj)
            {
                if (obj == null)
                    return 0;
                double x = Math.Round(obj.X / Tolerance) * Tolerance;
                double y = Math.Round(obj.Y / Tolerance) * Tolerance;
                double z = Math.Round(obj.Z / Tolerance) * Tolerance;
                return x.GetHashCode() ^ y.GetHashCode() ^ z.GetHashCode();
            }
        }
    }
}



ViewsOnSheets.cs


  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133


using Autodesk.Revit.Attributes;
using Autodesk.Revit.DB;
using Autodesk.Revit.UI;
using ViewOnSheetsR2025.Services;
using ViewOnSheetsR2025.UI;

namespace ViewOnSheetsR2025
{
    [Transaction(TransactionMode.Manual)]
    public class ViewsOnSheets : IExternalCommand
    {
        public Result Execute(ExternalCommandData commandData, ref string message, ElementSet elements)
        {
            UIDocument uidoc = commandData.Application.ActiveUIDocument;
            Document doc = uidoc.Document;

            // 1. Collect unplaced views
            var unplacedViews = ViewsOnSheetsR2025Service.GetUnplacedViews(doc);
            if (unplacedViews.Count == 0)
            {
                TaskDialog.Show(
                    &#34;Разместить виды на листах&#34;,
                    &#34;Не найдено непомещённых, не-шаблонных видов.&#34;
                );
                return Result.Cancelled;
            }

            // 2. Collect all sheets
            var allSheets = ViewsOnSheetsR2025Service.GetAllSheets(doc);

            // 3. Collect title blocks
            var titleBlocks = new FilteredElementCollector(doc)
                .OfClass(typeof(FamilySymbol))
                .OfCategory(BuiltInCategory.OST_TitleBlocks)
                .Cast&lt;FamilySymbol&gt;()
                .ToList();

            if (titleBlocks.Count == 0)
            {
                TaskDialog.Show(
                    &#34;Разместить виды на листах&#34;,
                    &#34;В проекте не найдено штампов.&#34;
                );
                return Result.Cancelled;
            }

            // 4. Show selection window
            var window = new ViewsOnSheetsWindow(unplacedViews, allSheets, titleBlocks);
            bool? result = window.ShowDialog();
            if (result != true)
                return Result.Cancelled;

            // 5. Get selected views
            var selectedViews = window.SelectedViews;
            if (selectedViews == null || selectedViews.Count == 0)
            {
                TaskDialog.Show(
                    &#34;Разместить виды на листах&#34;,
                    &#34;Не выбраны виды.&#34;
                );
                return Result.Cancelled;
            }

            bool createNewSheets = window.CreateNewSheets;
            var selectedSheets = window.SelectedSheets;

            if (!createNewSheets)
            {
                if (selectedSheets == null || selectedSheets.Count != selectedViews.Count)
                {
                    TaskDialog.Show(
                        &#34;Разместить виды на листах&#34;,
                        &#34;Количество выбранных листов должно совпадать с количеством выбранных видов.&#34;
                    );
                    return Result.Cancelled;
                }
            }

            // 6. Ask for point
            XYZ placementPoint;
            try
            {
                placementPoint = uidoc.Selection.PickPoint(
                    &#34;Укажите точку размещения на текущем листе. &#34; &#43;
                    &#34;Эта точка будет использована как центр для всех видов.&#34;
                );
            }
            catch (Exception ex)
            {
                TaskDialog.Show(
                    &#34;Разместить виды на листах&#34;,
                    &#34;Выбор точки отменён или завершился неудачно:\n&#34; &#43; ex.Message
                );
                return Result.Cancelled;
            }

            // 7. Build the dictionary of parameter values from the window
            var paramValues = new Dictionary&lt;string, string&gt;()
            {
                { &#34;Формат А&#34;,           window.SelectedFormatA     ?? &#34;&#34; },
                { &#34;Кратность&#34;,          window.SelectedMultiplicity ?? &#34;&#34; },
                { &#34;Книжная ориентация&#34;, window.SelectedOrientation  ?? &#34;&#34; }
            };

            // 8. Retrieve the user-chosen scale from the window
            int scale = window.SelectedViewScale;

            // 9. Place views on sheets
            try
            {
                ViewsOnSheetsR2025Service.PlaceViewsOnSheets(
                    doc,
                    createNewSheets,
                    selectedViews,
                    selectedSheets,
                    placementPoint,
                    window.SelectedTitleBlockId,
                    paramValues,
                    scale
                );
                return Result.Succeeded;
            }
            catch (Exception ex)
            {
                TaskDialog.Show(
                    &#34;Разместить виды на листах&#34;,
                    &#34;Ошибка при размещении видов:\n&#34; &#43; ex.Message
                );
                return Result.Failed;
            }
        }
    }
}



AutoLevelMarker.cs


  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170


using Autodesk.Revit.Attributes;
using Autodesk.Revit.DB;
using Autodesk.Revit.UI;

namespace CreateLevelMarkers
{
    [Transaction(TransactionMode.Manual)]
    public class Command : IExternalCommand
    {
        public Result Execute(ExternalCommandData commandData, ref string message, ElementSet elements)
        {
            UIApplication uiapp = commandData.Application;
            UIDocument uidoc = uiapp.ActiveUIDocument;
            Document doc = uidoc.Document;

            try
            {
                // Create and show the main form.
                AutoLevelMarker form = new AutoLevelMarker(doc);
                bool? dialogResult = form.ShowDialog();

                if (dialogResult != true)
                    return Result.Cancelled;

                // Retrieve user selections.
                var selectedSections = form.SelectedSections;
                var selectedFamilies = form.SelectedFamilies;
                var markerType = form.SelectedMarkerType;
                var offsetMeters = form.OffsetValue * 3.28084; // Convert meters to feet

                // Retrieve optional parameter names.
                var selectedSourceParam = form.SelectedSourceParam;
                var selectedTargetParam = form.SelectedTargetParam;

                // Process each section and create markers.
                using (Transaction t = new Transaction(doc, &#34;Create Level Markers&#34;))
                {
                    t.Start();

                    if (!markerType.IsActive)
                        markerType.Activate();

                    foreach (ViewSection section in selectedSections)
                    {
                        var instances = new FilteredElementCollector(doc, section.Id)
                            .OfClass(typeof(FamilyInstance))
                            .Cast&lt;FamilyInstance&gt;()
                            .Where(i =&gt;
                            {
                                try
                                {
                                    return i.Symbol != null &amp;&amp;
                                           i.Symbol.Family != null &amp;&amp;
                                           selectedFamilies.Contains(i.Symbol.Family.Name);
                                }
                                catch { return false; }
                            })
                            .ToList();

                        TaskDialog.Show(&#34;Найдено&#34;, &#34;Найдено &#34; &#43; instances.Count &#43; &#34; экземпляров&#34;);

                        foreach (FamilyInstance inst in instances)
                        {
                            try
                            {
                                BoundingBoxXYZ bb = inst.get_BoundingBox(null);
                                if (bb != null)
                                {
                                    XYZ center = (bb.Min &#43; bb.Max) * 0.5;
                                    XYZ placementPoint = new XYZ(center.X &#43; offsetMeters, center.Y, center.Z);

                                    FamilyInstance marker = doc.Create.NewFamilyInstance(
                                        placementPoint,
                                        markerType,
                                        section
                                    );

                                    // Optional: copy parameter value if both parameter names are provided.
                                    if (!string.IsNullOrEmpty(selectedSourceParam) &amp;&amp; !string.IsNullOrEmpty(selectedTargetParam))
                                    {
                                        var allParams = ParameterUtilities.GetAllParameters(inst);
                                        Parameter? sourceParam = allParams.ContainsKey(selectedSourceParam) ?
                                            allParams[selectedSourceParam] : null;
                                        if (sourceParam == null)
                                        {
                                            TaskDialog.Show(&#34;Ошибка&#34;, &#34;Параметр не найден: &#34; &#43; selectedSourceParam);
                                            continue;
                                        }

                                        double paramValue = 0;
                                        switch (sourceParam.StorageType)
                                        {
                                            case StorageType.Double:
                                                paramValue = sourceParam.AsDouble() * 1000;
                                                break;
                                            case StorageType.Integer:
                                                paramValue = sourceParam.AsInteger() * 1000;
                                                break;
                                            case StorageType.String:
                                                string stringValue = sourceParam.AsString();
                                                double tempValue;
                                                if (!string.IsNullOrEmpty(stringValue) &amp;&amp; double.TryParse(stringValue, out tempValue))
                                                    paramValue = tempValue * 1000;
                                                else
                                                {
                                                    TaskDialog.Show(&#34;Ошибка&#34;, &#34;Параметр имеет нечисловое значение: &#34; &#43; stringValue);
                                                    continue;
                                                }
                                                break;
                                            default:
                                                TaskDialog.Show(&#34;Ошибка&#34;, &#34;Параметр имеет неподдерживаемый тип хранения&#34;);
                                                continue;
                                        }

                                        var markerParams = ParameterUtilities.GetAllParameters(marker);
                                        Parameter? targetParam = markerParams.ContainsKey(selectedTargetParam) ?
                                            markerParams[selectedTargetParam] : null;
                                        if (targetParam != null)
                                        {
                                            if (targetParam.IsReadOnly)
                                            {
                                                TaskDialog.Show(&#34;Ошибка&#34;, &#34;Невозможно изменить параметр только для чтения: &#34; &#43; selectedTargetParam);
                                            }
                                            else
                                            {
                                                switch (targetParam.StorageType)
                                                {
                                                    case StorageType.Double:
                                                        targetParam.Set((double)paramValue);
                                                        break;
                                                    case StorageType.Integer:
                                                        targetParam.Set((int)paramValue);
                                                        break;
                                                    case StorageType.String:
                                                        targetParam.Set(paramValue.ToString());
                                                        break;
                                                    default:
                                                        TaskDialog.Show(&#34;Ошибка&#34;, &#34;Целевой параметр имеет неподдерживаемый тип хранения&#34;);
                                                        break;
                                                }
                                            }
                                        }
                                        else
                                        {
                                            TaskDialog.Show(&#34;Ошибка&#34;, &#34;Параметр не найден в маркере: &#34; &#43; selectedTargetParam);
                                        }
                                    }
                                }
                            }
                            catch (Exception ex)
                            {
                                TaskDialog.Show(&#34;Ошибка&#34;, &#34;Ошибка при обработке экземпляра: &#34; &#43; ex.Message);
                            }
                        }
                    }

                    t.Commit();
                }

                //MessageBox.Show(&#34;Логика создания маркеров будет запущена.&#34;, &#34;Информация&#34;, MessageBoxButton.OK, MessageBoxImage.Information);
                return Result.Succeeded;
            }
            catch (Exception ex)
            {
                message = ex.Message;
                return Result.Failed;
            }
        }
    }
}


">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://localhost:1313/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "C# + Revit API: Lesson 13 - Case Study №1 [Section Automation]",
      "item": "http://localhost:1313/posts/post-13/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "C# + Revit API: Lesson 13 - Case Study №1 [Section Automation]",
  "name": "C# \u002b Revit API: Lesson 13 - Case Study №1 [Section Automation]",
  "description": "Introduction This is the automation I made for my client and I would like to share the insights.\nPlan: Refactor the automation to properly organize the project. Start with understanding how to organize the WPF forms better. Seems like I have lots of functions just jumbled together in each file. Basically, separate and refactor the code. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 Based on analyzing the current \u0026#34;Cmds_AutoDim.cs\u0026#34; implementation and comparing it with the established codebase patterns, here are my refactoring suggestions: Key Refactoring Recommendations 1. Namespace Inconsistency Current: namespace DimensionAutomation Suggested: namespace UKON.Commands.General - Follow the established pattern from other command files in the same directory 2. Class Naming Convention Current: public class DimensionAutomation Suggested: public class Cmd_AutoDim - Match the naming pattern used throughout the codebase (e.g., Cmd_Test, Cmd_1Button) 3. Variable Naming Consistency Current: UIApplication uiapp = commandData.Application; Suggested: var uiApp = commandData.Application; - Follow the camelCase pattern used in other files (uiApp, uiDoc, not uiapp, uidoc) 4. Comments Structure Current: Uses // only elements actually visible in this view Suggested: Add proper method-level XML documentation comments like other files: /// \u0026lt;summary\u0026gt; /// Auto-dimensioning command for section views /// \u0026lt;/summary\u0026gt; 5. File Organization Current: Single complex class with multiple private methods Suggested: Consider splitting into: - Main command class (Cmd_AutoDim) - Separate service/helper classes for dimension logic - This follows the single responsibility principle 6. Error Handling Pattern Current: Generic try-catch with Russian error messages Suggested: - Use consistent error message language (English like other files) - Follow the established error handling pattern from other commands 7. External Dependencies Current: References DimensionAutomation.UI namespace Suggested: Ensure UI classes follow the project\u0026#39;s namespace structure (UKON.UI or similar) 8. Transaction Naming Current: \u0026#34;Создание маркеров и размерений\u0026#34; (Russian) Suggested: Use English transaction names for consistency 9. Method Extraction Opportunities The Execute method is quite long. Consider extracting: - User input validation logic - Section processing setup - Error message display logic 10. Constants Organization Current: MIN_CURVE_LENGTH defined in class Suggested: Consider a constants class or configuration file for project-wide constants The current implementation is functional but doesn\u0026#39;t follow the established architectural patterns of the UKON project. The main issues are namespace inconsistency, naming conventions, and language mixing. Old Code Project Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 Solution |-\u0026gt; ViewOnSheets2025 |-\u0026gt; Dependencies |-\u0026gt; Properties |-\u0026gt; Commands |-\u0026gt; AutoLevelMarker.cs |-\u0026gt; DimensionAutomation.cs |-\u0026gt; RevitSectionCreator.cs |-\u0026gt; SpotDimensionAutomation.cs |-\u0026gt; ViewsOnSheets.cs |-\u0026gt; Globals |-\u0026gt; ElementTypeInfo.cs |-\u0026gt; ParameterUtilities.cs |-\u0026gt; PointOnElement.cs |-\u0026gt; Resources |-\u0026gt; Icons |-\u0026gt; Services |-\u0026gt; ViewsOnSheetsR2025Service.cs |-\u0026gt; UI |-\u0026gt; AutoLevelMarker.xaml |-\u0026gt; DimensionAutomationWindow.xaml |-\u0026gt; RevitSectionsCreatorWindow.xaml |-\u0026gt; ViewOnSheetsR2025Windown.xaml |-\u0026gt; Application.cs |-\u0026gt; guRoo.addin RevitSectionCreator.cs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 using Autodesk.Revit.Attributes; using Autodesk.Revit.DB; using Autodesk.Revit.UI; using RevitSectionCreator.UI; namespace RevitSectionCreator { [Transaction(TransactionMode.Manual)] public class Command : IExternalCommand { public Result Execute(ExternalCommandData commandData, ref string message, ElementSet elements) { UIApplication uiapp = commandData.Application; UIDocument uidoc = uiapp.ActiveUIDocument; Document doc = uidoc.Document; try { // STEP 1: Collect element types for section creation. List\u0026lt;ElementTypeInfo\u0026gt; elementTypes = new List\u0026lt;ElementTypeInfo\u0026gt;(); // Collect FamilyInstance elements and group them by the family name. var familyInstances = new FilteredElementCollector(doc) .OfClass(typeof(FamilyInstance)) .Cast\u0026lt;FamilyInstance\u0026gt;() .ToList(); var familyGroups = familyInstances .GroupBy(fi =\u0026gt; fi.Symbol.FamilyName) .Select(g =\u0026gt; new ElementTypeInfo { TypeName = g.Key, Category = \u0026#34;Семейство\u0026#34;, // \u0026#34;Family\u0026#34; in Russian ElementIds = g.Select(fi =\u0026gt; fi.Id).ToList() }) .ToList(); elementTypes.AddRange(familyGroups); // Collect DirectShape elements. var directShapes = new FilteredElementCollector(doc) .OfClass(typeof(DirectShape)) .Cast\u0026lt;DirectShape\u0026gt;() .ToList(); var directShapeGroups = directShapes .GroupBy(ds =\u0026gt; ds.Category?.Name ?? \u0026#34;Без категории\u0026#34;) .Select(g =\u0026gt; new ElementTypeInfo { TypeName = $\u0026#34;DirectShape - {g.Key}\u0026#34;, Category = \u0026#34;DirectShape\u0026#34;, ElementIds = g.Select(ds =\u0026gt; ds.Id).ToList() }) .ToList(); elementTypes.AddRange(directShapeGroups); // Collect ImportInstance elements (excluding links). var importInstances = new FilteredElementCollector(doc) .OfClass(typeof(ImportInstance)) .Cast\u0026lt;ImportInstance\u0026gt;() .Where(ii =\u0026gt; !ii.IsLinked) .ToList(); var importGroups = importInstances .GroupBy(ii =\u0026gt; ii.Category?.Name ?? \u0026#34;Без категории импорта\u0026#34;) .Select(g =\u0026gt; new ElementTypeInfo { TypeName = $\u0026#34;Import - {g.Key}\u0026#34;, Category = \u0026#34;Import\u0026#34;, ElementIds = g.Select(ii =\u0026gt; ii.Id).ToList() }) .ToList(); elementTypes.AddRange(importGroups); if (elementTypes.Count == 0) { TaskDialog.Show(\u0026#34;Ошибка\u0026#34;, \u0026#34;В документе не найдено подходящих элементов.\u0026#34;); return Result.Failed; } // Sort the element types by category then by type name. elementTypes = elementTypes .OrderBy(et =\u0026gt; et.Category) .ThenBy(et =\u0026gt; et.TypeName) .ToList(); // STEP 2: Display the unified WPF window to get user choices. RevitSectionCreatorWindow sectionWindow = new RevitSectionCreatorWindow(elementTypes); if (sectionWindow.ShowDialog() != true) { return Result.Cancelled; } // Retrieve selections from the combined window. ElementTypeInfo selectedType = sectionWindow.SelectedElementType; string selectedFace = sectionWindow.SelectedFace; // e.g., \u0026#34;Левая грань\u0026#34; double offsetMm = sectionWindow.OffsetValue; // STEP 3: Create section views. using (Transaction t = new Transaction(doc, $\u0026#34;Создание разрезов для {selectedType.TypeName}\u0026#34;)) { t.Start(); // Get the Section ViewFamilyType. using ViewFamilyType sectionType = new FilteredElementCollector(doc) .OfClass(typeof(ViewFamilyType)) .Cast\u0026lt;ViewFamilyType\u0026gt;() .FirstOrDefault(vt =\u0026gt; vt.ViewFamily == ViewFamily.Section); if (sectionType == null) { TaskDialog.Show(\u0026#34;Ошибка\u0026#34;, \u0026#34;Не найден тип семейства для разреза.\u0026#34;); return Result.Failed; } // Retrieve the actual elements from the selected type. List\u0026lt;Element\u0026gt; elementsToProcess = new List\u0026lt;Element\u0026gt;(); foreach (ElementId id in selectedType.ElementIds) { Element elem = doc.GetElement(id); if (elem != null) { elementsToProcess.Add(elem); } } if (!elementsToProcess.Any()) { TaskDialog.Show(\u0026#34;Ошибка\u0026#34;, $\u0026#34;Элементы типа \u0026#39;{selectedType.TypeName}\u0026#39; не найдены.\u0026#34;); return Result.Failed; } // Determine the base direction from the selected face. XYZ baseDirection = GetDirectionFromFace(selectedFace); int sectionCount = 0; foreach (Element element in elementsToProcess) { string elementMark = GetElementMark(element) ?? element.Name; List\u0026lt;ElementId\u0026gt; partIds = new List\u0026lt;ElementId\u0026gt;(); // For FamilyInstance elements, try to get associated parts. if (element is FamilyInstance familyInstance) { ICollection\u0026lt;ElementId\u0026gt; associatedParts = PartUtils.GetAssociatedParts(doc, familyInstance.Id, true, true); partIds.AddRange(associatedParts); } // If no associated parts, use the element itself. if (partIds.Count == 0) { partIds.Add(element.Id); } foreach (ElementId partId in partIds) { Element part = doc.GetElement(partId); string partMark = GetElementMark(part) ?? part.Name; // Use the base direction from the unified dialog. XYZ finalDirection = baseDirection; // Find the best-aligned face on the element. Face chosenFace = GetLocalDirectionFace(part, finalDirection); if (chosenFace == null) continue; // Create the section view. ViewSection sectionView = CreateSectionView(doc, sectionType.Id, chosenFace, offsetMm); if (sectionView != null) { try { // Build a name for the new section view. string rawPartName = !string.IsNullOrEmpty(partMark) ? partMark : elementMark; string faceLabel = selectedFace.Replace(\u0026#34; \u0026#34;, \u0026#34;\u0026#34;); // Remove spaces for naming. string offsetStrForm = (offsetMm % 1 == 0) ? $\u0026#34;{(int)offsetMm}мм\u0026#34; : $\u0026#34;{offsetMm}мм\u0026#34;; string combinedName = $\u0026#34;{rawPartName}_{faceLabel}_{offsetStrForm}\u0026#34;; string uniqueName = GenerateUniqueName(doc, combinedName); sectionView.Name = uniqueName; // Apply crop region to the section view. CreateViewCrop(sectionView, chosenFace); sectionCount++; } catch (Exception ex) { TaskDialog.Show(\u0026#34;Предупреждение\u0026#34;, $\u0026#34;Не удалось задать имя для вида: {ex.Message}\u0026#34;); } } } } t.Commit(); TaskDialog.Show(\u0026#34;Успех\u0026#34;, $\u0026#34;Создано {sectionCount} разрезов для {selectedType.TypeName}.\u0026#34;); } return Result.Succeeded; } catch (Exception ex) { message = ex.Message; return Result.Failed; } } #region Helper Methods // Maps Russian face names to direction vectors. private XYZ GetDirectionFromFace(string faceName) { var directionMap = new Dictionary\u0026lt;string, XYZ\u0026gt; { { \u0026#34;Левая грань\u0026#34;, new XYZ(-1, 0, 0) }, { \u0026#34;Правая грань\u0026#34;, new XYZ(1, 0, 0) }, { \u0026#34;Передняя грань\u0026#34;, new XYZ(0, 1, 0) }, { \u0026#34;Задняя грань\u0026#34;, new XYZ(0, -1, 0) }, { \u0026#34;Верхняя грань\u0026#34;, new XYZ(0, 0, 1) }, { \u0026#34;Нижняя грань\u0026#34;, new XYZ(0, 0, -1) } }; if (directionMap.TryGetValue(faceName, out XYZ direction)) { return direction; } return XYZ.BasisY; // Fallback } // Retrieves the element\u0026#39;s \u0026#34;mark\u0026#34; or returns its name. private string GetElementMark(Element element) { Parameter markParam = element.get_Parameter(BuiltInParameter.ALL_MODEL_MARK); if (markParam != null \u0026amp;\u0026amp; markParam.HasValue) { string markValue = markParam.AsString(); if (!string.IsNullOrEmpty(markValue) \u0026amp;\u0026amp; markValue.Contains(\u0026#34;Ст.\u0026#34;)) { string numberPart = markValue.Split(new[] { \u0026#34;Ст.\u0026#34; }, StringSplitOptions.None)[1].Trim(); return $\u0026#34;О_Р_{numberPart}\u0026#34;; } return markValue; } return null; } // Generates a unique name for a view by appending additional characters if needed. private string GenerateUniqueName(Document doc, string baseName) { string testName = baseName; int counter = 1; List\u0026lt;string\u0026gt; existingNames = new FilteredElementCollector(doc) .OfClass(typeof(View)) .Cast\u0026lt;View\u0026gt;() .Select(v =\u0026gt; v.Name) .ToList(); while (existingNames.Contains(testName)) { counter++; testName = baseName + new string(\u0026#39;*\u0026#39;, counter); } return testName; } // Creates a crop boundary (CurveLoop) from a given face. private CurveLoop CreateCropBoundary(Face face) { try { BoundingBoxUV uvBbox = face.GetBoundingBox(); List\u0026lt;XYZ\u0026gt; points = new List\u0026lt;XYZ\u0026gt; { face.Evaluate(new UV(uvBbox.Min.U, uvBbox.Min.V)), face.Evaluate(new UV(uvBbox.Max.U, uvBbox.Min.V)), face.Evaluate(new UV(uvBbox.Max.U, uvBbox.Max.V)), face.Evaluate(new UV(uvBbox.Min.U, uvBbox.Max.V)) }; List\u0026lt;Curve\u0026gt; curves = new List\u0026lt;Curve\u0026gt;(); for (int i = 0; i \u0026lt; 4; i++) { XYZ start = points[i]; XYZ end = points[(i + 1) % 4]; curves.Add(Line.CreateBound(start, end)); } return CurveLoop.Create(curves); } catch { return null; } } // Sets up the crop boundary on a section view. private bool CreateViewCrop(ViewSection view, Face face) { try { if (!view.CropBoxActive) view.CropBoxActive = true; CurveLoop cropLoop = CreateCropBoundary(face); if (cropLoop != null) { view.GetCropRegionShapeManager().SetCropShape(cropLoop); return true; } return false; } catch { return false; } } // Determines the face on an element that best aligns with the local direction. private Face GetLocalDirectionFace(Element element, XYZ localDir) { Transform instTransform = Transform.Identity; if (element is FamilyInstance familyInstance) instTransform = familyInstance.GetTransform(); else if (element is ImportInstance importInstance \u0026amp;\u0026amp; !importInstance.IsLinked) instTransform = importInstance.GetTransform(); Transform invTransform = instTransform.Inverse; Face chosenFace = null; double bestAlignment = -999; Options options = new Options { ComputeReferences = true, DetailLevel = ViewDetailLevel.Fine }; GeometryElement geoElem = element.get_Geometry(options); if (geoElem == null) return null; void ProcessGeometry(GeometryObject geo, Transform transform) { if (geo is Solid solid \u0026amp;\u0026amp; solid.Volume \u0026gt; 0) { foreach (Face face in solid.Faces) { XYZ faceNormalWorld = face.ComputeNormal(new UV(0.5, 0.5)).Normalize(); XYZ faceNormalLocal = invTransform.OfVector(faceNormalWorld).Normalize(); double alignment = faceNormalLocal.DotProduct(localDir); if (alignment \u0026gt; bestAlignment) { bestAlignment = alignment; chosenFace = face; } } } else if (geo is GeometryInstance instance) { Transform instanceTransform = instance.Transform; GeometryElement instGeo = instance.GetInstanceGeometry(); if (instGeo != null) { foreach (GeometryObject obj in instGeo) { ProcessGeometry(obj, instanceTransform); } } } } foreach (GeometryObject geo in geoElem) { ProcessGeometry(geo, Transform.Identity); } return chosenFace; } // Creates and returns a section view based on the given face and offset. private ViewSection CreateSectionView(Document doc, ElementId sectionTypeId, Face face, double offsetMm) { try { // 1. Compute face center in world coords BoundingBoxUV uvBbox = face.GetBoundingBox(); double midU = (uvBbox.Min.U + uvBbox.Max.U) / 2.0; double midV = (uvBbox.Min.V + uvBbox.Max.V) / 2.0; XYZ faceCenter = face.Evaluate(new UV(midU, midV)); // 2. Get the outward normal, then invert it for “inward” view direction XYZ faceNormalOut = face.ComputeNormal(new UV(midU, midV)).Normalize(); XYZ inwardNormal = faceNormalOut.Multiply(-1.0); // 3. Build the section’s coordinate system Transform transFace = Transform.Identity; transFace.Origin = faceCenter; transFace.BasisZ = inwardNormal; // ← view direction toward element // 4. Choose a reasonable X axis for the section XYZ basisX = inwardNormal.CrossProduct(XYZ.BasisZ); if (basisX.IsAlmostEqualTo(XYZ.Zero)) basisX = inwardNormal.CrossProduct(XYZ.BasisX); transFace.BasisX = basisX.Normalize(); transFace.BasisY = transFace.BasisZ.CrossProduct(transFace.BasisX).Normalize(); // 5. Apply offset *along* the inward normal // Convert mm → ft, then move inward double offsetFt = offsetMm / 304.8; transFace.Origin = faceCenter.Add(inwardNormal.Multiply(offsetFt)); // 6. Define the crop box in this new coordinate system BoundingBoxXYZ sectionBox = new BoundingBoxXYZ { Transform = transFace, Min = new XYZ(-2.5, -50, -0.1), Max = new XYZ(2.5, 50, 0.25) }; // 7. Create and return the section return ViewSection.CreateSection(doc, sectionTypeId, sectionBox); } catch { return null; } } #endregion } } DimensionAutomation.cs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 using Autodesk.Revit.Attributes; using Autodesk.Revit.DB; using Autodesk.Revit.UI; using DimensionAutomation.UI; namespace DimensionAutomation { [Transaction(TransactionMode.Manual)] public class DimensionAutomation : IExternalCommand { private const double MIN_CURVE_LENGTH = 0.001; private XYZ GetVerticalInView(XYZ viewDir) { XYZ upDir = XYZ.BasisZ; XYZ verticalInView = upDir - viewDir.Multiply(upDir.DotProduct(viewDir)); if (verticalInView.GetLength() \u0026lt; MIN_CURVE_LENGTH) return null; return verticalInView.Normalize(); } public Result Execute(ExternalCommandData commandData, ref string message, ElementSet elements) { UIApplication uiapp = commandData.Application; UIDocument uidoc = uiapp.ActiveUIDocument; Document doc = uidoc.Document; try { // Show the WPF window to get user choices. var window = new DimensionAutomationWindow(doc); if (window.ShowDialog() != true) return Result.Cancelled; // Gather user selections. var selectedSections = window.SelectedSectionViews; var selectedFamilyTypes = window.SelectedFamilyTypes; var selectedDimType = window.SelectedDimensionType; double offsetFeet = window.OffsetValue * 3.28084; // Basic checks. if (selectedSections == null || !selectedSections.Any()) { TaskDialog.Show(\u0026#34;Информация\u0026#34;, \u0026#34;Не выбраны виды разрезов. Операция прервана.\u0026#34;); return Result.Cancelled; } if (selectedFamilyTypes == null || selectedFamilyTypes.Count \u0026lt; 1) { TaskDialog.Show(\u0026#34;Информация\u0026#34;, \u0026#34;Пожалуйста, выберите хотя бы один тип семейства.\u0026#34;); return Result.Cancelled; } if (selectedDimType == null) { TaskDialog.Show(\u0026#34;Ошибка\u0026#34;, \u0026#34;Тип размерения не выбран.\u0026#34;); return Result.Failed; } // Process each section view. foreach (ViewSection section in selectedSections) { var instancesInSection = new FilteredElementCollector(doc, section.Id) // only elements actually visible in this view .WherePasses(new VisibleInViewFilter(doc, section.Id)) .OfClass(typeof(FamilyInstance)) .Cast\u0026lt;FamilyInstance\u0026gt;() .Where(fi =\u0026gt; fi.Symbol != null \u0026amp;\u0026amp; selectedFamilyTypes.Any(fs =\u0026gt; fs.Id == fi.Symbol.Id) ) .ToList(); if (instancesInSection.Count \u0026lt; 2) continue; ProcessSectionView(doc, section, selectedDimType, offsetFeet, instancesInSection); } return Result.Succeeded; } catch (Exception ex) { TaskDialog.Show(\u0026#34;Ошибка\u0026#34;, ex.ToString()); return Result.Failed; } } private void ProcessSectionView( Document doc, ViewSection sectionView, DimensionType dimType, double offsetDist, List\u0026lt;FamilyInstance\u0026gt; instances) { XYZ viewDir = sectionView.ViewDirection.Normalize(); XYZ verticalInView = GetVerticalInView(viewDir); if (verticalInView == null) { TaskDialog.Show(\u0026#34;Предупреждение\u0026#34;, \u0026#34;Не удалось определить вертикальное направление в виде. Пропускаем...\u0026#34;); return; } // Collect bounding-box centers. var centerPoints = new List\u0026lt;XYZ\u0026gt;(); foreach (var fi in instances) { var bb = fi.get_BoundingBox(sectionView); if (bb != null) centerPoints.Add((bb.Min + bb.Max) * 0.5); } if (centerPoints.Count \u0026lt; 2) return; // Sort by vertical location. centerPoints = centerPoints.OrderBy(p =\u0026gt; p.DotProduct(verticalInView)).ToList(); var dim3d = centerPoints.Last() - centerPoints.First(); if (dim3d.GetLength() \u0026lt; MIN_CURVE_LENGTH) return; // Project onto view plane. double dot = dim3d.DotProduct(viewDir); var dimPlane = (dim3d - viewDir.Multiply(dot)).Normalize(); if (dimPlane.GetLength() \u0026lt; MIN_CURVE_LENGTH) return; // Marker direction perpendicular to dimension direction. var refsDir = viewDir.CrossProduct(dimPlane).Normalize(); using (var tx = new Transaction(doc, \u0026#34;Создание маркеров и размерений\u0026#34;)) { tx.Start(); var detailLines = CreateDetailLines(doc, sectionView, centerPoints, refsDir, viewDir); doc.Regenerate(); CreateDimensionsBetweenLines(doc, sectionView, detailLines, refsDir, offsetDist, dimType); tx.Commit(); } } private List\u0026lt;DetailCurve\u0026gt; CreateDetailLines( Document doc, ViewSection view, List\u0026lt;XYZ\u0026gt; centers, XYZ dir, XYZ viewDir) { const double markerLen = 0.01; double half = markerLen * 0.5; var lines = new List\u0026lt;DetailCurve\u0026gt;(); foreach (var cp in centers) { var p1 = cp - dir.Multiply(half); var p2 = cp + dir.Multiply(half); var plane = Plane.CreateByNormalAndOrigin(viewDir, cp); SketchPlane.Create(doc, plane); var line = Line.CreateBound(p1, p2); lines.Add(doc.Create.NewDetailCurve(view, line)); } return lines; } private void CreateDimensionsBetweenLines( Document doc, ViewSection view, List\u0026lt;DetailCurve\u0026gt; lines, XYZ dir, double offset, DimensionType dimType) { for (int i = 0; i \u0026lt; lines.Count - 1; i++) { var a = lines[i].GeometryCurve.Reference; var b = lines[i + 1].GeometryCurve.Reference; var refs = new ReferenceArray(); refs.Append(a); refs.Append(b); var midA = lines[i].GeometryCurve.Evaluate(0.5, true); var midB = lines[i + 1].GeometryCurve.Evaluate(0.5, true); var offA = midA + dir.Multiply(offset); var offB = midB + dir.Multiply(offset); var dimLine = Line.CreateBound(offA, offB); try { var dim = doc.Create.NewDimension(view, dimLine, refs); dim.ChangeTypeId(dimType.Id); } catch (Exception ex) { TaskDialog.Show(\u0026#34;Ошибка размерения\u0026#34;, ex.Message); } } } } } SpotDimensionAutomation.cs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 using Autodesk.Revit.Attributes; using Autodesk.Revit.DB; using Autodesk.Revit.UI; using Autodesk.Revit.UI.Selection; namespace SpotDimensionTest.Commands { [Transaction(TransactionMode.Manual)] public class StartupCommand : IExternalCommand { public Result Execute(ExternalCommandData commandData, ref string message, ElementSet elements) { UIDocument uiDoc = commandData.Application.ActiveUIDocument; Document doc = uiDoc.Document; // STEP 1: Get preselected section views ICollection\u0026lt;ElementId\u0026gt; viewSelectionIds = uiDoc.Selection.GetElementIds(); List\u0026lt;View\u0026gt; sectionViews = new List\u0026lt;View\u0026gt;(); foreach (ElementId id in viewSelectionIds) { Element elem = doc.GetElement(id); if (elem is View view \u0026amp;\u0026amp; view.ViewType == ViewType.Section) { sectionViews.Add(view); } } if (sectionViews.Count == 0) { TaskDialog.Show(\u0026#34;Info\u0026#34;, \u0026#34;Please preselect section views first.\u0026#34;); return Result.Succeeded; } // STEP 2: User selects family instances TaskDialog.Show(\u0026#34;Selection\u0026#34;, \u0026#34;Now select family instances for spot elevations.\u0026#34;); IList\u0026lt;Reference\u0026gt; familyRefs = uiDoc.Selection.PickObjects( ObjectType.Element, \u0026#34;Select family instances for spot elevations\u0026#34;); List\u0026lt;FamilyInstance\u0026gt; familyInstances = new List\u0026lt;FamilyInstance\u0026gt;(); foreach (Reference famRef in familyRefs) { Element elem = doc.GetElement(famRef.ElementId); if (elem is FamilyInstance fi) { familyInstances.Add(fi); } } if (familyInstances.Count == 0) { TaskDialog.Show(\u0026#34;Info\u0026#34;, \u0026#34;No family instances selected.\u0026#34;); return Result.Succeeded; } // STEP 3: User picks a face on one of the family instances Reference pickedFaceRef = uiDoc.Selection.PickObject( ObjectType.Face, \u0026#34;Select a face for the spot elevation\u0026#34;); Element templateElem = doc.GetElement(pickedFaceRef.ElementId); GeometryObject geoObj = templateElem.GetGeometryObjectFromReference(pickedFaceRef); Face templateFace = geoObj as Face; XYZ pickedPoint = pickedFaceRef.GlobalPoint; XYZ templatePoint = CalculatePointOnFace(templateElem, templateFace, pickedPoint); // STEP 4: Create spot elevations on all family instances in all section views using (TransactionGroup tg = new TransactionGroup(doc, \u0026#34;Create Multiple Spot Elevations\u0026#34;)) { tg.Start(); int successCount = 0; foreach (View sectionView in sectionViews) { using (Transaction trans = new Transaction(doc, $\u0026#34;Spot Elevations in {sectionView.Name}\u0026#34;)) { trans.Start(); XYZ viewDir = sectionView.ViewDirection.Normalize(); XYZ viewUp = sectionView.UpDirection.Normalize(); XYZ viewRight = viewUp.CrossProduct(viewDir).Normalize(); XYZ originalPickedPoint = pickedPoint; bool viewHasSpotElevation = false; foreach (FamilyInstance fi in familyInstances) { if (viewHasSpotElevation) break; try { Options options = new Options { View = sectionView, ComputeReferences = true, IncludeNonVisibleObjects = false }; GeometryElement geometry = fi.get_Geometry(options); if (geometry == null || !geometry.Any()) continue; List\u0026lt;Face\u0026gt; faces = new List\u0026lt;Face\u0026gt;(); foreach (GeometryObject geomObj in geometry) { ExtractFacesFromGeometry(geomObj, faces); } List\u0026lt;Face\u0026gt; sortedFaces = SortFacesByPriority(faces, viewDir); foreach (Face face in sortedFaces) { try { IList\u0026lt;CurveLoop\u0026gt; edgeLoops = face.GetEdgesAsCurveLoops(); if (edgeLoops == null || edgeLoops.Count == 0) continue; XYZ elevationPoint = CalculatePointOnFace(fi, face, originalPickedPoint); try { XYZ lineStart = elevationPoint - viewRight * 0.1; XYZ lineEnd = elevationPoint + viewRight * 0.1; DetailLine? detailLine = doc.Create.NewDetailCurve( sectionView, Line.CreateBound(lineStart, lineEnd)) as DetailLine; if (detailLine != null) { XYZ bendPoint = elevationPoint; XYZ endPoint = elevationPoint; Reference lineRef = new Reference(detailLine); try { SpotDimension spotDimension = doc.Create.NewSpotElevation( sectionView, lineRef, elevationPoint, bendPoint, endPoint, elevationPoint, true); if (spotDimension != null) { successCount++; viewHasSpotElevation = true; break; } else { doc.Delete(detailLine.Id); } } catch (Exception) { doc.Delete(detailLine.Id); } } } catch (Exception) { // Continue to next face } } catch (Exception) { // Continue to next face } if (viewHasSpotElevation) break; } } catch (Exception) { // Continue to next family instance } if (viewHasSpotElevation) break; } trans.Commit(); } } tg.Assimilate(); TaskDialog resultsDialog = new TaskDialog(\u0026#34;Spot Elevation Results\u0026#34;); resultsDialog.MainInstruction = $\u0026#34;Created {successCount} spot elevations\u0026#34;; resultsDialog.MainContent = $\u0026#34;Successfully created {successCount} spot elevations across {sectionViews.Count} section views.\u0026#34;; resultsDialog.Show(); } return Result.Succeeded; } private List\u0026lt;Face\u0026gt; SortFacesByPriority(List\u0026lt;Face\u0026gt; faces, XYZ viewDir) { List\u0026lt;Tuple\u0026lt;Face, double\u0026gt;\u0026gt; facesWithScores = new List\u0026lt;Tuple\u0026lt;Face, double\u0026gt;\u0026gt;(); foreach (Face face in faces) { try { BoundingBoxUV bb = face.GetBoundingBox(); UV centerUV = new UV((bb.Min.U + bb.Max.U) * 0.5, (bb.Min.V + bb.Max.V) * 0.5); XYZ normal = face.ComputeNormal(centerUV); double dotProduct = Math.Abs(normal.DotProduct(viewDir)); double score = dotProduct \u0026lt; 0.3 ? 1.0 : (dotProduct \u0026gt; 0.7 ? 2.0 : 3.0); facesWithScores.Add(Tuple.Create(face, score)); } catch { facesWithScores.Add(Tuple.Create(face, 10.0)); } } return facesWithScores .OrderBy(tuple =\u0026gt; tuple.Item2) .Select(tuple =\u0026gt; tuple.Item1) .ToList(); } private void ExtractFacesFromGeometry(GeometryObject geomObj, List\u0026lt;Face\u0026gt; faces) { if (geomObj is GeometryInstance geomInstance) { GeometryElement symbolGeometry = geomInstance.GetSymbolGeometry(); Transform instanceTransform = geomInstance.Transform; if (symbolGeometry != null) { ExtractSolidsFromGeometry(symbolGeometry, instanceTransform, faces); } return; } if (!(geomObj is Solid solid) || solid.Faces.Size == 0) { return; } for (int i = 0; i \u0026lt; solid.Faces.Size; i++) { Face face = solid.Faces.get_Item(i); if (face != null \u0026amp;\u0026amp; face.Reference != null) { faces.Add(face); } } } private void ExtractSolidsFromGeometry(GeometryElement geometry, Transform transform, List\u0026lt;Face\u0026gt; faces) { foreach (GeometryObject obj in geometry) { if (obj is GeometryInstance nestedInstance) { GeometryElement nestedGeometry = nestedInstance.GetSymbolGeometry(); Transform combinedTransform = transform.Multiply(nestedInstance.Transform); if (nestedGeometry != null) { ExtractSolidsFromGeometry(nestedGeometry, combinedTransform, faces); } } else if (obj is Solid solid \u0026amp;\u0026amp; solid.Faces.Size \u0026gt; 0) { for (int i = 0; i \u0026lt; solid.Faces.Size; i++) { Face face = solid.Faces.get_Item(i); if (face != null \u0026amp;\u0026amp; face.Reference != null) { faces.Add(face); } } } } } private XYZ CalculatePointOnFace(Element elem, Face face, XYZ pickedPoint) { if (face == null || pickedPoint == null) return pickedPoint; BoundingBoxUV faceBB = face.GetBoundingBox(); IntersectionResult projResult = face.Project(pickedPoint); if (projResult == null) return pickedPoint; UV pickedUV = projResult.UVPoint; FamilyInstance fi = elem as FamilyInstance; if (fi != null) { Transform transform = fi.GetTransform(); Transform inverseTransform = transform.Inverse; XYZ localPoint = inverseTransform.OfPoint(pickedPoint); XYZ faceNormal = face.ComputeNormal(pickedUV).Normalize(); XYZ localNormal = inverseTransform.OfVector(faceNormal).Normalize(); if (Math.Abs(localNormal.Z) \u0026lt; 0.3) { BoundingBoxXYZ bbox = fi.get_BoundingBox(null); if (bbox != null) { double zPos = (bbox.Min.Z + bbox.Max.Z) * 0.5; XYZ localResult = new XYZ(localPoint.X, localPoint.Y, zPos); XYZ globalResult = transform.OfPoint(localResult); projResult = face.Project(globalResult); if (projResult != null) { return face.Evaluate(projResult.UVPoint); } } } } UV adjustedUV = new UV(pickedUV.U, (faceBB.Min.V + faceBB.Max.V) * 0.5); return face.Evaluate(adjustedUV); } private XYZ CalculateCurveLoopCentroid(CurveLoop curveLoop) { if (curveLoop == null || curveLoop.Count() == 0) return XYZ.Zero; XYZ sum = XYZ.Zero; int pointCount = 0; HashSet\u0026lt;XYZ\u0026gt; uniquePoints = new HashSet\u0026lt;XYZ\u0026gt;(new XYZEqualityComparer()); foreach (Curve curve in curveLoop) { uniquePoints.Add(curve.GetEndPoint(0)); uniquePoints.Add(curve.GetEndPoint(1)); } foreach (XYZ point in uniquePoints) { sum += point; pointCount++; } return pointCount \u0026gt; 0 ? sum.Divide(pointCount) : XYZ.Zero; } private class XYZEqualityComparer : IEqualityComparer\u0026lt;XYZ\u0026gt; { private const double Tolerance = 0.0001; public bool Equals(XYZ x, XYZ y) { if (x == null \u0026amp;\u0026amp; y == null) return true; if (x == null || y == null) return false; return Math.Abs(x.X - y.X) \u0026lt; Tolerance \u0026amp;\u0026amp; Math.Abs(x.Y - y.Y) \u0026lt; Tolerance \u0026amp;\u0026amp; Math.Abs(x.Z - y.Z) \u0026lt; Tolerance; } public int GetHashCode(XYZ obj) { if (obj == null) return 0; double x = Math.Round(obj.X / Tolerance) * Tolerance; double y = Math.Round(obj.Y / Tolerance) * Tolerance; double z = Math.Round(obj.Z / Tolerance) * Tolerance; return x.GetHashCode() ^ y.GetHashCode() ^ z.GetHashCode(); } } } } ViewsOnSheets.cs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 using Autodesk.Revit.Attributes; using Autodesk.Revit.DB; using Autodesk.Revit.UI; using ViewOnSheetsR2025.Services; using ViewOnSheetsR2025.UI; namespace ViewOnSheetsR2025 { [Transaction(TransactionMode.Manual)] public class ViewsOnSheets : IExternalCommand { public Result Execute(ExternalCommandData commandData, ref string message, ElementSet elements) { UIDocument uidoc = commandData.Application.ActiveUIDocument; Document doc = uidoc.Document; // 1. Collect unplaced views var unplacedViews = ViewsOnSheetsR2025Service.GetUnplacedViews(doc); if (unplacedViews.Count == 0) { TaskDialog.Show( \u0026#34;Разместить виды на листах\u0026#34;, \u0026#34;Не найдено непомещённых, не-шаблонных видов.\u0026#34; ); return Result.Cancelled; } // 2. Collect all sheets var allSheets = ViewsOnSheetsR2025Service.GetAllSheets(doc); // 3. Collect title blocks var titleBlocks = new FilteredElementCollector(doc) .OfClass(typeof(FamilySymbol)) .OfCategory(BuiltInCategory.OST_TitleBlocks) .Cast\u0026lt;FamilySymbol\u0026gt;() .ToList(); if (titleBlocks.Count == 0) { TaskDialog.Show( \u0026#34;Разместить виды на листах\u0026#34;, \u0026#34;В проекте не найдено штампов.\u0026#34; ); return Result.Cancelled; } // 4. Show selection window var window = new ViewsOnSheetsWindow(unplacedViews, allSheets, titleBlocks); bool? result = window.ShowDialog(); if (result != true) return Result.Cancelled; // 5. Get selected views var selectedViews = window.SelectedViews; if (selectedViews == null || selectedViews.Count == 0) { TaskDialog.Show( \u0026#34;Разместить виды на листах\u0026#34;, \u0026#34;Не выбраны виды.\u0026#34; ); return Result.Cancelled; } bool createNewSheets = window.CreateNewSheets; var selectedSheets = window.SelectedSheets; if (!createNewSheets) { if (selectedSheets == null || selectedSheets.Count != selectedViews.Count) { TaskDialog.Show( \u0026#34;Разместить виды на листах\u0026#34;, \u0026#34;Количество выбранных листов должно совпадать с количеством выбранных видов.\u0026#34; ); return Result.Cancelled; } } // 6. Ask for point XYZ placementPoint; try { placementPoint = uidoc.Selection.PickPoint( \u0026#34;Укажите точку размещения на текущем листе. \u0026#34; + \u0026#34;Эта точка будет использована как центр для всех видов.\u0026#34; ); } catch (Exception ex) { TaskDialog.Show( \u0026#34;Разместить виды на листах\u0026#34;, \u0026#34;Выбор точки отменён или завершился неудачно:\\n\u0026#34; + ex.Message ); return Result.Cancelled; } // 7. Build the dictionary of parameter values from the window var paramValues = new Dictionary\u0026lt;string, string\u0026gt;() { { \u0026#34;Формат А\u0026#34;, window.SelectedFormatA ?? \u0026#34;\u0026#34; }, { \u0026#34;Кратность\u0026#34;, window.SelectedMultiplicity ?? \u0026#34;\u0026#34; }, { \u0026#34;Книжная ориентация\u0026#34;, window.SelectedOrientation ?? \u0026#34;\u0026#34; } }; // 8. Retrieve the user-chosen scale from the window int scale = window.SelectedViewScale; // 9. Place views on sheets try { ViewsOnSheetsR2025Service.PlaceViewsOnSheets( doc, createNewSheets, selectedViews, selectedSheets, placementPoint, window.SelectedTitleBlockId, paramValues, scale ); return Result.Succeeded; } catch (Exception ex) { TaskDialog.Show( \u0026#34;Разместить виды на листах\u0026#34;, \u0026#34;Ошибка при размещении видов:\\n\u0026#34; + ex.Message ); return Result.Failed; } } } } AutoLevelMarker.cs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 using Autodesk.Revit.Attributes; using Autodesk.Revit.DB; using Autodesk.Revit.UI; namespace CreateLevelMarkers { [Transaction(TransactionMode.Manual)] public class Command : IExternalCommand { public Result Execute(ExternalCommandData commandData, ref string message, ElementSet elements) { UIApplication uiapp = commandData.Application; UIDocument uidoc = uiapp.ActiveUIDocument; Document doc = uidoc.Document; try { // Create and show the main form. AutoLevelMarker form = new AutoLevelMarker(doc); bool? dialogResult = form.ShowDialog(); if (dialogResult != true) return Result.Cancelled; // Retrieve user selections. var selectedSections = form.SelectedSections; var selectedFamilies = form.SelectedFamilies; var markerType = form.SelectedMarkerType; var offsetMeters = form.OffsetValue * 3.28084; // Convert meters to feet // Retrieve optional parameter names. var selectedSourceParam = form.SelectedSourceParam; var selectedTargetParam = form.SelectedTargetParam; // Process each section and create markers. using (Transaction t = new Transaction(doc, \u0026#34;Create Level Markers\u0026#34;)) { t.Start(); if (!markerType.IsActive) markerType.Activate(); foreach (ViewSection section in selectedSections) { var instances = new FilteredElementCollector(doc, section.Id) .OfClass(typeof(FamilyInstance)) .Cast\u0026lt;FamilyInstance\u0026gt;() .Where(i =\u0026gt; { try { return i.Symbol != null \u0026amp;\u0026amp; i.Symbol.Family != null \u0026amp;\u0026amp; selectedFamilies.Contains(i.Symbol.Family.Name); } catch { return false; } }) .ToList(); TaskDialog.Show(\u0026#34;Найдено\u0026#34;, \u0026#34;Найдено \u0026#34; + instances.Count + \u0026#34; экземпляров\u0026#34;); foreach (FamilyInstance inst in instances) { try { BoundingBoxXYZ bb = inst.get_BoundingBox(null); if (bb != null) { XYZ center = (bb.Min + bb.Max) * 0.5; XYZ placementPoint = new XYZ(center.X + offsetMeters, center.Y, center.Z); FamilyInstance marker = doc.Create.NewFamilyInstance( placementPoint, markerType, section ); // Optional: copy parameter value if both parameter names are provided. if (!string.IsNullOrEmpty(selectedSourceParam) \u0026amp;\u0026amp; !string.IsNullOrEmpty(selectedTargetParam)) { var allParams = ParameterUtilities.GetAllParameters(inst); Parameter? sourceParam = allParams.ContainsKey(selectedSourceParam) ? allParams[selectedSourceParam] : null; if (sourceParam == null) { TaskDialog.Show(\u0026#34;Ошибка\u0026#34;, \u0026#34;Параметр не найден: \u0026#34; + selectedSourceParam); continue; } double paramValue = 0; switch (sourceParam.StorageType) { case StorageType.Double: paramValue = sourceParam.AsDouble() * 1000; break; case StorageType.Integer: paramValue = sourceParam.AsInteger() * 1000; break; case StorageType.String: string stringValue = sourceParam.AsString(); double tempValue; if (!string.IsNullOrEmpty(stringValue) \u0026amp;\u0026amp; double.TryParse(stringValue, out tempValue)) paramValue = tempValue * 1000; else { TaskDialog.Show(\u0026#34;Ошибка\u0026#34;, \u0026#34;Параметр имеет нечисловое значение: \u0026#34; + stringValue); continue; } break; default: TaskDialog.Show(\u0026#34;Ошибка\u0026#34;, \u0026#34;Параметр имеет неподдерживаемый тип хранения\u0026#34;); continue; } var markerParams = ParameterUtilities.GetAllParameters(marker); Parameter? targetParam = markerParams.ContainsKey(selectedTargetParam) ? markerParams[selectedTargetParam] : null; if (targetParam != null) { if (targetParam.IsReadOnly) { TaskDialog.Show(\u0026#34;Ошибка\u0026#34;, \u0026#34;Невозможно изменить параметр только для чтения: \u0026#34; + selectedTargetParam); } else { switch (targetParam.StorageType) { case StorageType.Double: targetParam.Set((double)paramValue); break; case StorageType.Integer: targetParam.Set((int)paramValue); break; case StorageType.String: targetParam.Set(paramValue.ToString()); break; default: TaskDialog.Show(\u0026#34;Ошибка\u0026#34;, \u0026#34;Целевой параметр имеет неподдерживаемый тип хранения\u0026#34;); break; } } } else { TaskDialog.Show(\u0026#34;Ошибка\u0026#34;, \u0026#34;Параметр не найден в маркере: \u0026#34; + selectedTargetParam); } } } } catch (Exception ex) { TaskDialog.Show(\u0026#34;Ошибка\u0026#34;, \u0026#34;Ошибка при обработке экземпляра: \u0026#34; + ex.Message); } } } t.Commit(); } //MessageBox.Show(\u0026#34;Логика создания маркеров будет запущена.\u0026#34;, \u0026#34;Информация\u0026#34;, MessageBoxButton.OK, MessageBoxImage.Information); return Result.Succeeded; } catch (Exception ex) { message = ex.Message; return Result.Failed; } } } } ",
  "keywords": [
    "C#", "Revit", "Tutorial"
  ],
  "articleBody": "Introduction This is the automation I made for my client and I would like to share the insights.\nPlan: Refactor the automation to properly organize the project. Start with understanding how to organize the WPF forms better. Seems like I have lots of functions just jumbled together in each file. Basically, separate and refactor the code. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 Based on analyzing the current \"Cmds_AutoDim.cs\" implementation and comparing it with the established codebase patterns, here are my refactoring suggestions: Key Refactoring Recommendations 1. Namespace Inconsistency Current: namespace DimensionAutomation Suggested: namespace UKON.Commands.General - Follow the established pattern from other command files in the same directory 2. Class Naming Convention Current: public class DimensionAutomation Suggested: public class Cmd_AutoDim - Match the naming pattern used throughout the codebase (e.g., Cmd_Test, Cmd_1Button) 3. Variable Naming Consistency Current: UIApplication uiapp = commandData.Application; Suggested: var uiApp = commandData.Application; - Follow the camelCase pattern used in other files (uiApp, uiDoc, not uiapp, uidoc) 4. Comments Structure Current: Uses // only elements actually visible in this view Suggested: Add proper method-level XML documentation comments like other files: /// /// Auto-dimensioning command for section views /// 5. File Organization Current: Single complex class with multiple private methods Suggested: Consider splitting into: - Main command class (Cmd_AutoDim) - Separate service/helper classes for dimension logic - This follows the single responsibility principle 6. Error Handling Pattern Current: Generic try-catch with Russian error messages Suggested: - Use consistent error message language (English like other files) - Follow the established error handling pattern from other commands 7. External Dependencies Current: References DimensionAutomation.UI namespace Suggested: Ensure UI classes follow the project's namespace structure (UKON.UI or similar) 8. Transaction Naming Current: \"Создание маркеров и размерений\" (Russian) Suggested: Use English transaction names for consistency 9. Method Extraction Opportunities The Execute method is quite long. Consider extracting: - User input validation logic - Section processing setup - Error message display logic 10. Constants Organization Current: MIN_CURVE_LENGTH defined in class Suggested: Consider a constants class or configuration file for project-wide constants The current implementation is functional but doesn't follow the established architectural patterns of the UKON project. The main issues are namespace inconsistency, naming conventions, and language mixing. Old Code Project Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 Solution |-\u003e ViewOnSheets2025 |-\u003e Dependencies |-\u003e Properties |-\u003e Commands |-\u003e AutoLevelMarker.cs |-\u003e DimensionAutomation.cs |-\u003e RevitSectionCreator.cs |-\u003e SpotDimensionAutomation.cs |-\u003e ViewsOnSheets.cs |-\u003e Globals |-\u003e ElementTypeInfo.cs |-\u003e ParameterUtilities.cs |-\u003e PointOnElement.cs |-\u003e Resources |-\u003e Icons |-\u003e Services |-\u003e ViewsOnSheetsR2025Service.cs |-\u003e UI |-\u003e AutoLevelMarker.xaml |-\u003e DimensionAutomationWindow.xaml |-\u003e RevitSectionsCreatorWindow.xaml |-\u003e ViewOnSheetsR2025Windown.xaml |-\u003e Application.cs |-\u003e guRoo.addin RevitSectionCreator.cs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 using Autodesk.Revit.Attributes; using Autodesk.Revit.DB; using Autodesk.Revit.UI; using RevitSectionCreator.UI; namespace RevitSectionCreator { [Transaction(TransactionMode.Manual)] public class Command : IExternalCommand { public Result Execute(ExternalCommandData commandData, ref string message, ElementSet elements) { UIApplication uiapp = commandData.Application; UIDocument uidoc = uiapp.ActiveUIDocument; Document doc = uidoc.Document; try { // STEP 1: Collect element types for section creation. List\u003cElementTypeInfo\u003e elementTypes = new List\u003cElementTypeInfo\u003e(); // Collect FamilyInstance elements and group them by the family name. var familyInstances = new FilteredElementCollector(doc) .OfClass(typeof(FamilyInstance)) .Cast\u003cFamilyInstance\u003e() .ToList(); var familyGroups = familyInstances .GroupBy(fi =\u003e fi.Symbol.FamilyName) .Select(g =\u003e new ElementTypeInfo { TypeName = g.Key, Category = \"Семейство\", // \"Family\" in Russian ElementIds = g.Select(fi =\u003e fi.Id).ToList() }) .ToList(); elementTypes.AddRange(familyGroups); // Collect DirectShape elements. var directShapes = new FilteredElementCollector(doc) .OfClass(typeof(DirectShape)) .Cast\u003cDirectShape\u003e() .ToList(); var directShapeGroups = directShapes .GroupBy(ds =\u003e ds.Category?.Name ?? \"Без категории\") .Select(g =\u003e new ElementTypeInfo { TypeName = $\"DirectShape - {g.Key}\", Category = \"DirectShape\", ElementIds = g.Select(ds =\u003e ds.Id).ToList() }) .ToList(); elementTypes.AddRange(directShapeGroups); // Collect ImportInstance elements (excluding links). var importInstances = new FilteredElementCollector(doc) .OfClass(typeof(ImportInstance)) .Cast\u003cImportInstance\u003e() .Where(ii =\u003e !ii.IsLinked) .ToList(); var importGroups = importInstances .GroupBy(ii =\u003e ii.Category?.Name ?? \"Без категории импорта\") .Select(g =\u003e new ElementTypeInfo { TypeName = $\"Import - {g.Key}\", Category = \"Import\", ElementIds = g.Select(ii =\u003e ii.Id).ToList() }) .ToList(); elementTypes.AddRange(importGroups); if (elementTypes.Count == 0) { TaskDialog.Show(\"Ошибка\", \"В документе не найдено подходящих элементов.\"); return Result.Failed; } // Sort the element types by category then by type name. elementTypes = elementTypes .OrderBy(et =\u003e et.Category) .ThenBy(et =\u003e et.TypeName) .ToList(); // STEP 2: Display the unified WPF window to get user choices. RevitSectionCreatorWindow sectionWindow = new RevitSectionCreatorWindow(elementTypes); if (sectionWindow.ShowDialog() != true) { return Result.Cancelled; } // Retrieve selections from the combined window. ElementTypeInfo selectedType = sectionWindow.SelectedElementType; string selectedFace = sectionWindow.SelectedFace; // e.g., \"Левая грань\" double offsetMm = sectionWindow.OffsetValue; // STEP 3: Create section views. using (Transaction t = new Transaction(doc, $\"Создание разрезов для {selectedType.TypeName}\")) { t.Start(); // Get the Section ViewFamilyType. using ViewFamilyType sectionType = new FilteredElementCollector(doc) .OfClass(typeof(ViewFamilyType)) .Cast\u003cViewFamilyType\u003e() .FirstOrDefault(vt =\u003e vt.ViewFamily == ViewFamily.Section); if (sectionType == null) { TaskDialog.Show(\"Ошибка\", \"Не найден тип семейства для разреза.\"); return Result.Failed; } // Retrieve the actual elements from the selected type. List\u003cElement\u003e elementsToProcess = new List\u003cElement\u003e(); foreach (ElementId id in selectedType.ElementIds) { Element elem = doc.GetElement(id); if (elem != null) { elementsToProcess.Add(elem); } } if (!elementsToProcess.Any()) { TaskDialog.Show(\"Ошибка\", $\"Элементы типа '{selectedType.TypeName}' не найдены.\"); return Result.Failed; } // Determine the base direction from the selected face. XYZ baseDirection = GetDirectionFromFace(selectedFace); int sectionCount = 0; foreach (Element element in elementsToProcess) { string elementMark = GetElementMark(element) ?? element.Name; List\u003cElementId\u003e partIds = new List\u003cElementId\u003e(); // For FamilyInstance elements, try to get associated parts. if (element is FamilyInstance familyInstance) { ICollection\u003cElementId\u003e associatedParts = PartUtils.GetAssociatedParts(doc, familyInstance.Id, true, true); partIds.AddRange(associatedParts); } // If no associated parts, use the element itself. if (partIds.Count == 0) { partIds.Add(element.Id); } foreach (ElementId partId in partIds) { Element part = doc.GetElement(partId); string partMark = GetElementMark(part) ?? part.Name; // Use the base direction from the unified dialog. XYZ finalDirection = baseDirection; // Find the best-aligned face on the element. Face chosenFace = GetLocalDirectionFace(part, finalDirection); if (chosenFace == null) continue; // Create the section view. ViewSection sectionView = CreateSectionView(doc, sectionType.Id, chosenFace, offsetMm); if (sectionView != null) { try { // Build a name for the new section view. string rawPartName = !string.IsNullOrEmpty(partMark) ? partMark : elementMark; string faceLabel = selectedFace.Replace(\" \", \"\"); // Remove spaces for naming. string offsetStrForm = (offsetMm % 1 == 0) ? $\"{(int)offsetMm}мм\" : $\"{offsetMm}мм\"; string combinedName = $\"{rawPartName}_{faceLabel}_{offsetStrForm}\"; string uniqueName = GenerateUniqueName(doc, combinedName); sectionView.Name = uniqueName; // Apply crop region to the section view. CreateViewCrop(sectionView, chosenFace); sectionCount++; } catch (Exception ex) { TaskDialog.Show(\"Предупреждение\", $\"Не удалось задать имя для вида: {ex.Message}\"); } } } } t.Commit(); TaskDialog.Show(\"Успех\", $\"Создано {sectionCount} разрезов для {selectedType.TypeName}.\"); } return Result.Succeeded; } catch (Exception ex) { message = ex.Message; return Result.Failed; } } #region Helper Methods // Maps Russian face names to direction vectors. private XYZ GetDirectionFromFace(string faceName) { var directionMap = new Dictionary\u003cstring, XYZ\u003e { { \"Левая грань\", new XYZ(-1, 0, 0) }, { \"Правая грань\", new XYZ(1, 0, 0) }, { \"Передняя грань\", new XYZ(0, 1, 0) }, { \"Задняя грань\", new XYZ(0, -1, 0) }, { \"Верхняя грань\", new XYZ(0, 0, 1) }, { \"Нижняя грань\", new XYZ(0, 0, -1) } }; if (directionMap.TryGetValue(faceName, out XYZ direction)) { return direction; } return XYZ.BasisY; // Fallback } // Retrieves the element's \"mark\" or returns its name. private string GetElementMark(Element element) { Parameter markParam = element.get_Parameter(BuiltInParameter.ALL_MODEL_MARK); if (markParam != null \u0026\u0026 markParam.HasValue) { string markValue = markParam.AsString(); if (!string.IsNullOrEmpty(markValue) \u0026\u0026 markValue.Contains(\"Ст.\")) { string numberPart = markValue.Split(new[] { \"Ст.\" }, StringSplitOptions.None)[1].Trim(); return $\"О_Р_{numberPart}\"; } return markValue; } return null; } // Generates a unique name for a view by appending additional characters if needed. private string GenerateUniqueName(Document doc, string baseName) { string testName = baseName; int counter = 1; List\u003cstring\u003e existingNames = new FilteredElementCollector(doc) .OfClass(typeof(View)) .Cast\u003cView\u003e() .Select(v =\u003e v.Name) .ToList(); while (existingNames.Contains(testName)) { counter++; testName = baseName + new string('*', counter); } return testName; } // Creates a crop boundary (CurveLoop) from a given face. private CurveLoop CreateCropBoundary(Face face) { try { BoundingBoxUV uvBbox = face.GetBoundingBox(); List\u003cXYZ\u003e points = new List\u003cXYZ\u003e { face.Evaluate(new UV(uvBbox.Min.U, uvBbox.Min.V)), face.Evaluate(new UV(uvBbox.Max.U, uvBbox.Min.V)), face.Evaluate(new UV(uvBbox.Max.U, uvBbox.Max.V)), face.Evaluate(new UV(uvBbox.Min.U, uvBbox.Max.V)) }; List\u003cCurve\u003e curves = new List\u003cCurve\u003e(); for (int i = 0; i \u003c 4; i++) { XYZ start = points[i]; XYZ end = points[(i + 1) % 4]; curves.Add(Line.CreateBound(start, end)); } return CurveLoop.Create(curves); } catch { return null; } } // Sets up the crop boundary on a section view. private bool CreateViewCrop(ViewSection view, Face face) { try { if (!view.CropBoxActive) view.CropBoxActive = true; CurveLoop cropLoop = CreateCropBoundary(face); if (cropLoop != null) { view.GetCropRegionShapeManager().SetCropShape(cropLoop); return true; } return false; } catch { return false; } } // Determines the face on an element that best aligns with the local direction. private Face GetLocalDirectionFace(Element element, XYZ localDir) { Transform instTransform = Transform.Identity; if (element is FamilyInstance familyInstance) instTransform = familyInstance.GetTransform(); else if (element is ImportInstance importInstance \u0026\u0026 !importInstance.IsLinked) instTransform = importInstance.GetTransform(); Transform invTransform = instTransform.Inverse; Face chosenFace = null; double bestAlignment = -999; Options options = new Options { ComputeReferences = true, DetailLevel = ViewDetailLevel.Fine }; GeometryElement geoElem = element.get_Geometry(options); if (geoElem == null) return null; void ProcessGeometry(GeometryObject geo, Transform transform) { if (geo is Solid solid \u0026\u0026 solid.Volume \u003e 0) { foreach (Face face in solid.Faces) { XYZ faceNormalWorld = face.ComputeNormal(new UV(0.5, 0.5)).Normalize(); XYZ faceNormalLocal = invTransform.OfVector(faceNormalWorld).Normalize(); double alignment = faceNormalLocal.DotProduct(localDir); if (alignment \u003e bestAlignment) { bestAlignment = alignment; chosenFace = face; } } } else if (geo is GeometryInstance instance) { Transform instanceTransform = instance.Transform; GeometryElement instGeo = instance.GetInstanceGeometry(); if (instGeo != null) { foreach (GeometryObject obj in instGeo) { ProcessGeometry(obj, instanceTransform); } } } } foreach (GeometryObject geo in geoElem) { ProcessGeometry(geo, Transform.Identity); } return chosenFace; } // Creates and returns a section view based on the given face and offset. private ViewSection CreateSectionView(Document doc, ElementId sectionTypeId, Face face, double offsetMm) { try { // 1. Compute face center in world coords BoundingBoxUV uvBbox = face.GetBoundingBox(); double midU = (uvBbox.Min.U + uvBbox.Max.U) / 2.0; double midV = (uvBbox.Min.V + uvBbox.Max.V) / 2.0; XYZ faceCenter = face.Evaluate(new UV(midU, midV)); // 2. Get the outward normal, then invert it for “inward” view direction XYZ faceNormalOut = face.ComputeNormal(new UV(midU, midV)).Normalize(); XYZ inwardNormal = faceNormalOut.Multiply(-1.0); // 3. Build the section’s coordinate system Transform transFace = Transform.Identity; transFace.Origin = faceCenter; transFace.BasisZ = inwardNormal; // ← view direction toward element // 4. Choose a reasonable X axis for the section XYZ basisX = inwardNormal.CrossProduct(XYZ.BasisZ); if (basisX.IsAlmostEqualTo(XYZ.Zero)) basisX = inwardNormal.CrossProduct(XYZ.BasisX); transFace.BasisX = basisX.Normalize(); transFace.BasisY = transFace.BasisZ.CrossProduct(transFace.BasisX).Normalize(); // 5. Apply offset *along* the inward normal // Convert mm → ft, then move inward double offsetFt = offsetMm / 304.8; transFace.Origin = faceCenter.Add(inwardNormal.Multiply(offsetFt)); // 6. Define the crop box in this new coordinate system BoundingBoxXYZ sectionBox = new BoundingBoxXYZ { Transform = transFace, Min = new XYZ(-2.5, -50, -0.1), Max = new XYZ(2.5, 50, 0.25) }; // 7. Create and return the section return ViewSection.CreateSection(doc, sectionTypeId, sectionBox); } catch { return null; } } #endregion } } DimensionAutomation.cs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 using Autodesk.Revit.Attributes; using Autodesk.Revit.DB; using Autodesk.Revit.UI; using DimensionAutomation.UI; namespace DimensionAutomation { [Transaction(TransactionMode.Manual)] public class DimensionAutomation : IExternalCommand { private const double MIN_CURVE_LENGTH = 0.001; private XYZ GetVerticalInView(XYZ viewDir) { XYZ upDir = XYZ.BasisZ; XYZ verticalInView = upDir - viewDir.Multiply(upDir.DotProduct(viewDir)); if (verticalInView.GetLength() \u003c MIN_CURVE_LENGTH) return null; return verticalInView.Normalize(); } public Result Execute(ExternalCommandData commandData, ref string message, ElementSet elements) { UIApplication uiapp = commandData.Application; UIDocument uidoc = uiapp.ActiveUIDocument; Document doc = uidoc.Document; try { // Show the WPF window to get user choices. var window = new DimensionAutomationWindow(doc); if (window.ShowDialog() != true) return Result.Cancelled; // Gather user selections. var selectedSections = window.SelectedSectionViews; var selectedFamilyTypes = window.SelectedFamilyTypes; var selectedDimType = window.SelectedDimensionType; double offsetFeet = window.OffsetValue * 3.28084; // Basic checks. if (selectedSections == null || !selectedSections.Any()) { TaskDialog.Show(\"Информация\", \"Не выбраны виды разрезов. Операция прервана.\"); return Result.Cancelled; } if (selectedFamilyTypes == null || selectedFamilyTypes.Count \u003c 1) { TaskDialog.Show(\"Информация\", \"Пожалуйста, выберите хотя бы один тип семейства.\"); return Result.Cancelled; } if (selectedDimType == null) { TaskDialog.Show(\"Ошибка\", \"Тип размерения не выбран.\"); return Result.Failed; } // Process each section view. foreach (ViewSection section in selectedSections) { var instancesInSection = new FilteredElementCollector(doc, section.Id) // only elements actually visible in this view .WherePasses(new VisibleInViewFilter(doc, section.Id)) .OfClass(typeof(FamilyInstance)) .Cast\u003cFamilyInstance\u003e() .Where(fi =\u003e fi.Symbol != null \u0026\u0026 selectedFamilyTypes.Any(fs =\u003e fs.Id == fi.Symbol.Id) ) .ToList(); if (instancesInSection.Count \u003c 2) continue; ProcessSectionView(doc, section, selectedDimType, offsetFeet, instancesInSection); } return Result.Succeeded; } catch (Exception ex) { TaskDialog.Show(\"Ошибка\", ex.ToString()); return Result.Failed; } } private void ProcessSectionView( Document doc, ViewSection sectionView, DimensionType dimType, double offsetDist, List\u003cFamilyInstance\u003e instances) { XYZ viewDir = sectionView.ViewDirection.Normalize(); XYZ verticalInView = GetVerticalInView(viewDir); if (verticalInView == null) { TaskDialog.Show(\"Предупреждение\", \"Не удалось определить вертикальное направление в виде. Пропускаем...\"); return; } // Collect bounding-box centers. var centerPoints = new List\u003cXYZ\u003e(); foreach (var fi in instances) { var bb = fi.get_BoundingBox(sectionView); if (bb != null) centerPoints.Add((bb.Min + bb.Max) * 0.5); } if (centerPoints.Count \u003c 2) return; // Sort by vertical location. centerPoints = centerPoints.OrderBy(p =\u003e p.DotProduct(verticalInView)).ToList(); var dim3d = centerPoints.Last() - centerPoints.First(); if (dim3d.GetLength() \u003c MIN_CURVE_LENGTH) return; // Project onto view plane. double dot = dim3d.DotProduct(viewDir); var dimPlane = (dim3d - viewDir.Multiply(dot)).Normalize(); if (dimPlane.GetLength() \u003c MIN_CURVE_LENGTH) return; // Marker direction perpendicular to dimension direction. var refsDir = viewDir.CrossProduct(dimPlane).Normalize(); using (var tx = new Transaction(doc, \"Создание маркеров и размерений\")) { tx.Start(); var detailLines = CreateDetailLines(doc, sectionView, centerPoints, refsDir, viewDir); doc.Regenerate(); CreateDimensionsBetweenLines(doc, sectionView, detailLines, refsDir, offsetDist, dimType); tx.Commit(); } } private List\u003cDetailCurve\u003e CreateDetailLines( Document doc, ViewSection view, List\u003cXYZ\u003e centers, XYZ dir, XYZ viewDir) { const double markerLen = 0.01; double half = markerLen * 0.5; var lines = new List\u003cDetailCurve\u003e(); foreach (var cp in centers) { var p1 = cp - dir.Multiply(half); var p2 = cp + dir.Multiply(half); var plane = Plane.CreateByNormalAndOrigin(viewDir, cp); SketchPlane.Create(doc, plane); var line = Line.CreateBound(p1, p2); lines.Add(doc.Create.NewDetailCurve(view, line)); } return lines; } private void CreateDimensionsBetweenLines( Document doc, ViewSection view, List\u003cDetailCurve\u003e lines, XYZ dir, double offset, DimensionType dimType) { for (int i = 0; i \u003c lines.Count - 1; i++) { var a = lines[i].GeometryCurve.Reference; var b = lines[i + 1].GeometryCurve.Reference; var refs = new ReferenceArray(); refs.Append(a); refs.Append(b); var midA = lines[i].GeometryCurve.Evaluate(0.5, true); var midB = lines[i + 1].GeometryCurve.Evaluate(0.5, true); var offA = midA + dir.Multiply(offset); var offB = midB + dir.Multiply(offset); var dimLine = Line.CreateBound(offA, offB); try { var dim = doc.Create.NewDimension(view, dimLine, refs); dim.ChangeTypeId(dimType.Id); } catch (Exception ex) { TaskDialog.Show(\"Ошибка размерения\", ex.Message); } } } } } SpotDimensionAutomation.cs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 using Autodesk.Revit.Attributes; using Autodesk.Revit.DB; using Autodesk.Revit.UI; using Autodesk.Revit.UI.Selection; namespace SpotDimensionTest.Commands { [Transaction(TransactionMode.Manual)] public class StartupCommand : IExternalCommand { public Result Execute(ExternalCommandData commandData, ref string message, ElementSet elements) { UIDocument uiDoc = commandData.Application.ActiveUIDocument; Document doc = uiDoc.Document; // STEP 1: Get preselected section views ICollection\u003cElementId\u003e viewSelectionIds = uiDoc.Selection.GetElementIds(); List\u003cView\u003e sectionViews = new List\u003cView\u003e(); foreach (ElementId id in viewSelectionIds) { Element elem = doc.GetElement(id); if (elem is View view \u0026\u0026 view.ViewType == ViewType.Section) { sectionViews.Add(view); } } if (sectionViews.Count == 0) { TaskDialog.Show(\"Info\", \"Please preselect section views first.\"); return Result.Succeeded; } // STEP 2: User selects family instances TaskDialog.Show(\"Selection\", \"Now select family instances for spot elevations.\"); IList\u003cReference\u003e familyRefs = uiDoc.Selection.PickObjects( ObjectType.Element, \"Select family instances for spot elevations\"); List\u003cFamilyInstance\u003e familyInstances = new List\u003cFamilyInstance\u003e(); foreach (Reference famRef in familyRefs) { Element elem = doc.GetElement(famRef.ElementId); if (elem is FamilyInstance fi) { familyInstances.Add(fi); } } if (familyInstances.Count == 0) { TaskDialog.Show(\"Info\", \"No family instances selected.\"); return Result.Succeeded; } // STEP 3: User picks a face on one of the family instances Reference pickedFaceRef = uiDoc.Selection.PickObject( ObjectType.Face, \"Select a face for the spot elevation\"); Element templateElem = doc.GetElement(pickedFaceRef.ElementId); GeometryObject geoObj = templateElem.GetGeometryObjectFromReference(pickedFaceRef); Face templateFace = geoObj as Face; XYZ pickedPoint = pickedFaceRef.GlobalPoint; XYZ templatePoint = CalculatePointOnFace(templateElem, templateFace, pickedPoint); // STEP 4: Create spot elevations on all family instances in all section views using (TransactionGroup tg = new TransactionGroup(doc, \"Create Multiple Spot Elevations\")) { tg.Start(); int successCount = 0; foreach (View sectionView in sectionViews) { using (Transaction trans = new Transaction(doc, $\"Spot Elevations in {sectionView.Name}\")) { trans.Start(); XYZ viewDir = sectionView.ViewDirection.Normalize(); XYZ viewUp = sectionView.UpDirection.Normalize(); XYZ viewRight = viewUp.CrossProduct(viewDir).Normalize(); XYZ originalPickedPoint = pickedPoint; bool viewHasSpotElevation = false; foreach (FamilyInstance fi in familyInstances) { if (viewHasSpotElevation) break; try { Options options = new Options { View = sectionView, ComputeReferences = true, IncludeNonVisibleObjects = false }; GeometryElement geometry = fi.get_Geometry(options); if (geometry == null || !geometry.Any()) continue; List\u003cFace\u003e faces = new List\u003cFace\u003e(); foreach (GeometryObject geomObj in geometry) { ExtractFacesFromGeometry(geomObj, faces); } List\u003cFace\u003e sortedFaces = SortFacesByPriority(faces, viewDir); foreach (Face face in sortedFaces) { try { IList\u003cCurveLoop\u003e edgeLoops = face.GetEdgesAsCurveLoops(); if (edgeLoops == null || edgeLoops.Count == 0) continue; XYZ elevationPoint = CalculatePointOnFace(fi, face, originalPickedPoint); try { XYZ lineStart = elevationPoint - viewRight * 0.1; XYZ lineEnd = elevationPoint + viewRight * 0.1; DetailLine? detailLine = doc.Create.NewDetailCurve( sectionView, Line.CreateBound(lineStart, lineEnd)) as DetailLine; if (detailLine != null) { XYZ bendPoint = elevationPoint; XYZ endPoint = elevationPoint; Reference lineRef = new Reference(detailLine); try { SpotDimension spotDimension = doc.Create.NewSpotElevation( sectionView, lineRef, elevationPoint, bendPoint, endPoint, elevationPoint, true); if (spotDimension != null) { successCount++; viewHasSpotElevation = true; break; } else { doc.Delete(detailLine.Id); } } catch (Exception) { doc.Delete(detailLine.Id); } } } catch (Exception) { // Continue to next face } } catch (Exception) { // Continue to next face } if (viewHasSpotElevation) break; } } catch (Exception) { // Continue to next family instance } if (viewHasSpotElevation) break; } trans.Commit(); } } tg.Assimilate(); TaskDialog resultsDialog = new TaskDialog(\"Spot Elevation Results\"); resultsDialog.MainInstruction = $\"Created {successCount} spot elevations\"; resultsDialog.MainContent = $\"Successfully created {successCount} spot elevations across {sectionViews.Count} section views.\"; resultsDialog.Show(); } return Result.Succeeded; } private List\u003cFace\u003e SortFacesByPriority(List\u003cFace\u003e faces, XYZ viewDir) { List\u003cTuple\u003cFace, double\u003e\u003e facesWithScores = new List\u003cTuple\u003cFace, double\u003e\u003e(); foreach (Face face in faces) { try { BoundingBoxUV bb = face.GetBoundingBox(); UV centerUV = new UV((bb.Min.U + bb.Max.U) * 0.5, (bb.Min.V + bb.Max.V) * 0.5); XYZ normal = face.ComputeNormal(centerUV); double dotProduct = Math.Abs(normal.DotProduct(viewDir)); double score = dotProduct \u003c 0.3 ? 1.0 : (dotProduct \u003e 0.7 ? 2.0 : 3.0); facesWithScores.Add(Tuple.Create(face, score)); } catch { facesWithScores.Add(Tuple.Create(face, 10.0)); } } return facesWithScores .OrderBy(tuple =\u003e tuple.Item2) .Select(tuple =\u003e tuple.Item1) .ToList(); } private void ExtractFacesFromGeometry(GeometryObject geomObj, List\u003cFace\u003e faces) { if (geomObj is GeometryInstance geomInstance) { GeometryElement symbolGeometry = geomInstance.GetSymbolGeometry(); Transform instanceTransform = geomInstance.Transform; if (symbolGeometry != null) { ExtractSolidsFromGeometry(symbolGeometry, instanceTransform, faces); } return; } if (!(geomObj is Solid solid) || solid.Faces.Size == 0) { return; } for (int i = 0; i \u003c solid.Faces.Size; i++) { Face face = solid.Faces.get_Item(i); if (face != null \u0026\u0026 face.Reference != null) { faces.Add(face); } } } private void ExtractSolidsFromGeometry(GeometryElement geometry, Transform transform, List\u003cFace\u003e faces) { foreach (GeometryObject obj in geometry) { if (obj is GeometryInstance nestedInstance) { GeometryElement nestedGeometry = nestedInstance.GetSymbolGeometry(); Transform combinedTransform = transform.Multiply(nestedInstance.Transform); if (nestedGeometry != null) { ExtractSolidsFromGeometry(nestedGeometry, combinedTransform, faces); } } else if (obj is Solid solid \u0026\u0026 solid.Faces.Size \u003e 0) { for (int i = 0; i \u003c solid.Faces.Size; i++) { Face face = solid.Faces.get_Item(i); if (face != null \u0026\u0026 face.Reference != null) { faces.Add(face); } } } } } private XYZ CalculatePointOnFace(Element elem, Face face, XYZ pickedPoint) { if (face == null || pickedPoint == null) return pickedPoint; BoundingBoxUV faceBB = face.GetBoundingBox(); IntersectionResult projResult = face.Project(pickedPoint); if (projResult == null) return pickedPoint; UV pickedUV = projResult.UVPoint; FamilyInstance fi = elem as FamilyInstance; if (fi != null) { Transform transform = fi.GetTransform(); Transform inverseTransform = transform.Inverse; XYZ localPoint = inverseTransform.OfPoint(pickedPoint); XYZ faceNormal = face.ComputeNormal(pickedUV).Normalize(); XYZ localNormal = inverseTransform.OfVector(faceNormal).Normalize(); if (Math.Abs(localNormal.Z) \u003c 0.3) { BoundingBoxXYZ bbox = fi.get_BoundingBox(null); if (bbox != null) { double zPos = (bbox.Min.Z + bbox.Max.Z) * 0.5; XYZ localResult = new XYZ(localPoint.X, localPoint.Y, zPos); XYZ globalResult = transform.OfPoint(localResult); projResult = face.Project(globalResult); if (projResult != null) { return face.Evaluate(projResult.UVPoint); } } } } UV adjustedUV = new UV(pickedUV.U, (faceBB.Min.V + faceBB.Max.V) * 0.5); return face.Evaluate(adjustedUV); } private XYZ CalculateCurveLoopCentroid(CurveLoop curveLoop) { if (curveLoop == null || curveLoop.Count() == 0) return XYZ.Zero; XYZ sum = XYZ.Zero; int pointCount = 0; HashSet\u003cXYZ\u003e uniquePoints = new HashSet\u003cXYZ\u003e(new XYZEqualityComparer()); foreach (Curve curve in curveLoop) { uniquePoints.Add(curve.GetEndPoint(0)); uniquePoints.Add(curve.GetEndPoint(1)); } foreach (XYZ point in uniquePoints) { sum += point; pointCount++; } return pointCount \u003e 0 ? sum.Divide(pointCount) : XYZ.Zero; } private class XYZEqualityComparer : IEqualityComparer\u003cXYZ\u003e { private const double Tolerance = 0.0001; public bool Equals(XYZ x, XYZ y) { if (x == null \u0026\u0026 y == null) return true; if (x == null || y == null) return false; return Math.Abs(x.X - y.X) \u003c Tolerance \u0026\u0026 Math.Abs(x.Y - y.Y) \u003c Tolerance \u0026\u0026 Math.Abs(x.Z - y.Z) \u003c Tolerance; } public int GetHashCode(XYZ obj) { if (obj == null) return 0; double x = Math.Round(obj.X / Tolerance) * Tolerance; double y = Math.Round(obj.Y / Tolerance) * Tolerance; double z = Math.Round(obj.Z / Tolerance) * Tolerance; return x.GetHashCode() ^ y.GetHashCode() ^ z.GetHashCode(); } } } } ViewsOnSheets.cs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 using Autodesk.Revit.Attributes; using Autodesk.Revit.DB; using Autodesk.Revit.UI; using ViewOnSheetsR2025.Services; using ViewOnSheetsR2025.UI; namespace ViewOnSheetsR2025 { [Transaction(TransactionMode.Manual)] public class ViewsOnSheets : IExternalCommand { public Result Execute(ExternalCommandData commandData, ref string message, ElementSet elements) { UIDocument uidoc = commandData.Application.ActiveUIDocument; Document doc = uidoc.Document; // 1. Collect unplaced views var unplacedViews = ViewsOnSheetsR2025Service.GetUnplacedViews(doc); if (unplacedViews.Count == 0) { TaskDialog.Show( \"Разместить виды на листах\", \"Не найдено непомещённых, не-шаблонных видов.\" ); return Result.Cancelled; } // 2. Collect all sheets var allSheets = ViewsOnSheetsR2025Service.GetAllSheets(doc); // 3. Collect title blocks var titleBlocks = new FilteredElementCollector(doc) .OfClass(typeof(FamilySymbol)) .OfCategory(BuiltInCategory.OST_TitleBlocks) .Cast\u003cFamilySymbol\u003e() .ToList(); if (titleBlocks.Count == 0) { TaskDialog.Show( \"Разместить виды на листах\", \"В проекте не найдено штампов.\" ); return Result.Cancelled; } // 4. Show selection window var window = new ViewsOnSheetsWindow(unplacedViews, allSheets, titleBlocks); bool? result = window.ShowDialog(); if (result != true) return Result.Cancelled; // 5. Get selected views var selectedViews = window.SelectedViews; if (selectedViews == null || selectedViews.Count == 0) { TaskDialog.Show( \"Разместить виды на листах\", \"Не выбраны виды.\" ); return Result.Cancelled; } bool createNewSheets = window.CreateNewSheets; var selectedSheets = window.SelectedSheets; if (!createNewSheets) { if (selectedSheets == null || selectedSheets.Count != selectedViews.Count) { TaskDialog.Show( \"Разместить виды на листах\", \"Количество выбранных листов должно совпадать с количеством выбранных видов.\" ); return Result.Cancelled; } } // 6. Ask for point XYZ placementPoint; try { placementPoint = uidoc.Selection.PickPoint( \"Укажите точку размещения на текущем листе. \" + \"Эта точка будет использована как центр для всех видов.\" ); } catch (Exception ex) { TaskDialog.Show( \"Разместить виды на листах\", \"Выбор точки отменён или завершился неудачно:\\n\" + ex.Message ); return Result.Cancelled; } // 7. Build the dictionary of parameter values from the window var paramValues = new Dictionary\u003cstring, string\u003e() { { \"Формат А\", window.SelectedFormatA ?? \"\" }, { \"Кратность\", window.SelectedMultiplicity ?? \"\" }, { \"Книжная ориентация\", window.SelectedOrientation ?? \"\" } }; // 8. Retrieve the user-chosen scale from the window int scale = window.SelectedViewScale; // 9. Place views on sheets try { ViewsOnSheetsR2025Service.PlaceViewsOnSheets( doc, createNewSheets, selectedViews, selectedSheets, placementPoint, window.SelectedTitleBlockId, paramValues, scale ); return Result.Succeeded; } catch (Exception ex) { TaskDialog.Show( \"Разместить виды на листах\", \"Ошибка при размещении видов:\\n\" + ex.Message ); return Result.Failed; } } } } AutoLevelMarker.cs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 using Autodesk.Revit.Attributes; using Autodesk.Revit.DB; using Autodesk.Revit.UI; namespace CreateLevelMarkers { [Transaction(TransactionMode.Manual)] public class Command : IExternalCommand { public Result Execute(ExternalCommandData commandData, ref string message, ElementSet elements) { UIApplication uiapp = commandData.Application; UIDocument uidoc = uiapp.ActiveUIDocument; Document doc = uidoc.Document; try { // Create and show the main form. AutoLevelMarker form = new AutoLevelMarker(doc); bool? dialogResult = form.ShowDialog(); if (dialogResult != true) return Result.Cancelled; // Retrieve user selections. var selectedSections = form.SelectedSections; var selectedFamilies = form.SelectedFamilies; var markerType = form.SelectedMarkerType; var offsetMeters = form.OffsetValue * 3.28084; // Convert meters to feet // Retrieve optional parameter names. var selectedSourceParam = form.SelectedSourceParam; var selectedTargetParam = form.SelectedTargetParam; // Process each section and create markers. using (Transaction t = new Transaction(doc, \"Create Level Markers\")) { t.Start(); if (!markerType.IsActive) markerType.Activate(); foreach (ViewSection section in selectedSections) { var instances = new FilteredElementCollector(doc, section.Id) .OfClass(typeof(FamilyInstance)) .Cast\u003cFamilyInstance\u003e() .Where(i =\u003e { try { return i.Symbol != null \u0026\u0026 i.Symbol.Family != null \u0026\u0026 selectedFamilies.Contains(i.Symbol.Family.Name); } catch { return false; } }) .ToList(); TaskDialog.Show(\"Найдено\", \"Найдено \" + instances.Count + \" экземпляров\"); foreach (FamilyInstance inst in instances) { try { BoundingBoxXYZ bb = inst.get_BoundingBox(null); if (bb != null) { XYZ center = (bb.Min + bb.Max) * 0.5; XYZ placementPoint = new XYZ(center.X + offsetMeters, center.Y, center.Z); FamilyInstance marker = doc.Create.NewFamilyInstance( placementPoint, markerType, section ); // Optional: copy parameter value if both parameter names are provided. if (!string.IsNullOrEmpty(selectedSourceParam) \u0026\u0026 !string.IsNullOrEmpty(selectedTargetParam)) { var allParams = ParameterUtilities.GetAllParameters(inst); Parameter? sourceParam = allParams.ContainsKey(selectedSourceParam) ? allParams[selectedSourceParam] : null; if (sourceParam == null) { TaskDialog.Show(\"Ошибка\", \"Параметр не найден: \" + selectedSourceParam); continue; } double paramValue = 0; switch (sourceParam.StorageType) { case StorageType.Double: paramValue = sourceParam.AsDouble() * 1000; break; case StorageType.Integer: paramValue = sourceParam.AsInteger() * 1000; break; case StorageType.String: string stringValue = sourceParam.AsString(); double tempValue; if (!string.IsNullOrEmpty(stringValue) \u0026\u0026 double.TryParse(stringValue, out tempValue)) paramValue = tempValue * 1000; else { TaskDialog.Show(\"Ошибка\", \"Параметр имеет нечисловое значение: \" + stringValue); continue; } break; default: TaskDialog.Show(\"Ошибка\", \"Параметр имеет неподдерживаемый тип хранения\"); continue; } var markerParams = ParameterUtilities.GetAllParameters(marker); Parameter? targetParam = markerParams.ContainsKey(selectedTargetParam) ? markerParams[selectedTargetParam] : null; if (targetParam != null) { if (targetParam.IsReadOnly) { TaskDialog.Show(\"Ошибка\", \"Невозможно изменить параметр только для чтения: \" + selectedTargetParam); } else { switch (targetParam.StorageType) { case StorageType.Double: targetParam.Set((double)paramValue); break; case StorageType.Integer: targetParam.Set((int)paramValue); break; case StorageType.String: targetParam.Set(paramValue.ToString()); break; default: TaskDialog.Show(\"Ошибка\", \"Целевой параметр имеет неподдерживаемый тип хранения\"); break; } } } else { TaskDialog.Show(\"Ошибка\", \"Параметр не найден в маркере: \" + selectedTargetParam); } } } } catch (Exception ex) { TaskDialog.Show(\"Ошибка\", \"Ошибка при обработке экземпляра: \" + ex.Message); } } } t.Commit(); } //MessageBox.Show(\"Логика создания маркеров будет запущена.\", \"Информация\", MessageBoxButton.OK, MessageBoxImage.Information); return Result.Succeeded; } catch (Exception ex) { message = ex.Message; return Result.Failed; } } } } ",
  "wordCount" : "5480",
  "inLanguage": "en",
  "image": "http://localhost:1313/LogoAYD.png","datePublished": "2025-08-16T19:10:51+03:00",
  "dateModified": "2025-08-16T19:10:51+03:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/posts/post-13/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Blog (Alt + H)">Blog</a>
        </div>

        
        <div class="logo main-logo">
            <a href="https://aydrafting.com" target="_blank">
                <img src="/LogoAYD.png" alt="Blog" height="40">
            </a>
        </div>

        
        <div class="logo-switches">
            <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                    fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                    stroke-linejoin="round">
                    <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                </svg>
                <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                    fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                    stroke-linejoin="round">
                    <circle cx="12" cy="12" r="5"></circle>
                    <line x1="12" y1="1" x2="12" y2="3"></line>
                    <line x1="12" y1="21" x2="12" y2="23"></line>
                    <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                    <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                    <line x1="1" y1="12" x2="3" y2="12"></line>
                    <line x1="21" y1="12" x2="23" y2="12"></line>
                    <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                    <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                </svg>
            </button>
        </div>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      C# &#43; Revit API: Lesson 13 - Case Study №1 [Section Automation]
      <span class="entry-hint" title="Draft">
        <svg xmlns="http://www.w3.org/2000/svg" height="35" viewBox="0 -960 960 960" fill="currentColor">
          <path
            d="M160-410v-60h300v60H160Zm0-165v-60h470v60H160Zm0-165v-60h470v60H160Zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22q0 11-4.5 22.5T862.09-380L643-160H520Zm300-263-37-37 37 37ZM580-220h38l121-122-18-19-19-18-122 121v38Zm141-141-19-18 37 37-18-19Z" />
        </svg>
      </span>
    </h1>
    <div class="post-meta"><span title='2025-08-16 19:10:51 +0300 MSK'>August 16, 2025</span>&nbsp;·&nbsp;26 min&nbsp;|&nbsp;<a href="mailto:%20aydimir@aydrafting.com" rel="noopener noreferrer edit" target="_blank">Suggest Changes</a>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#introduction" aria-label="Introduction">Introduction</a><ul>
                        
                <li>
                    <a href="#plan" aria-label="Plan:">Plan:</a></li></ul>
                </li>
                <li>
                    <a href="#old-code" aria-label="Old Code">Old Code</a><ul>
                        
                <li>
                    <a href="#project-solution" aria-label="Project Solution">Project Solution</a><ul>
                        
                <li>
                    <a href="#revitsectioncreatorcs" aria-label="RevitSectionCreator.cs">RevitSectionCreator.cs</a></li>
                <li>
                    <a href="#dimensionautomationcs" aria-label="DimensionAutomation.cs">DimensionAutomation.cs</a></li>
                <li>
                    <a href="#spotdimensionautomationcs" aria-label="SpotDimensionAutomation.cs">SpotDimensionAutomation.cs</a></li>
                <li>
                    <a href="#viewsonsheetscs" aria-label="ViewsOnSheets.cs">ViewsOnSheets.cs</a></li>
                <li>
                    <a href="#autolevelmarkercs" aria-label="AutoLevelMarker.cs">AutoLevelMarker.cs</a>
                </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="introduction">Introduction<a hidden class="anchor" aria-hidden="true" href="#introduction">#</a></h1>
<p>This is the automation I made for my client and I would like to share the insights.</p>
<h2 id="plan">Plan:<a hidden class="anchor" aria-hidden="true" href="#plan">#</a></h2>
<ol>
<li>Refactor the automation to properly organize the project.</li>
<li>Start with understanding how to organize the WPF forms better.</li>
<li>Seems like I have lots of functions just jumbled together in each file.</li>
<li>Basically, separate and refactor the code.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="n">Based</span> <span class="k">on</span> <span class="n">analyzing</span> <span class="n">the</span> <span class="n">current</span> <span class="s">&#34;Cmds_AutoDim.cs&#34;</span> <span class="n">implementation</span> <span class="n">and</span> <span class="n">comparing</span> <span class="n">it</span> <span class="n">with</span> <span class="n">the</span> <span class="n">established</span> <span class="n">codebase</span> <span class="n">patterns</span><span class="p">,</span> <span class="n">here</span> <span class="n">are</span> <span class="n">my</span> <span class="n">refactoring</span> <span class="n">suggestions</span><span class="p">:</span>  
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl"><span class="n">Key</span> <span class="n">Refactoring</span> <span class="n">Recommendations</span>  
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="m">1.</span> <span class="n">Namespace</span> <span class="n">Inconsistency</span>  
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Current</span><span class="p">:</span> <span class="k">namespace</span> <span class="nn">DimensionAutomation</span>  
</span></span><span class="line"><span class="cl"><span class="n">Suggested</span><span class="p">:</span> <span class="k">namespace</span> <span class="nn">UKON.Commands.General</span>  
</span></span><span class="line"><span class="cl">	<span class="p">-</span> <span class="n">Follow</span> <span class="n">the</span> <span class="n">established</span> <span class="n">pattern</span> <span class="k">from</span> <span class="n">other</span> <span class="n">command</span> <span class="n">files</span> <span class="k">in</span> <span class="n">the</span> <span class="n">same</span> <span class="n">directory</span>  
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="m">2.</span> <span class="n">Class</span> <span class="n">Naming</span> <span class="n">Convention</span>  
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Current</span><span class="p">:</span> <span class="kd">public</span> <span class="k">class</span> <span class="nc">DimensionAutomation</span>  
</span></span><span class="line"><span class="cl"><span class="n">Suggested</span><span class="p">:</span> <span class="kd">public</span> <span class="k">class</span> <span class="nc">Cmd_AutoDim</span>  
</span></span><span class="line"><span class="cl">	<span class="p">-</span> <span class="n">Match</span> <span class="n">the</span> <span class="n">naming</span> <span class="n">pattern</span> <span class="n">used</span> <span class="n">throughout</span> <span class="n">the</span> <span class="n">codebase</span> <span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">g</span><span class="p">.,</span> <span class="n">Cmd_Test</span><span class="p">,</span> <span class="n">Cmd_1Button</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="m">3.</span> <span class="n">Variable</span> <span class="n">Naming</span> <span class="n">Consistency</span>  
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Current</span><span class="p">:</span> <span class="n">UIApplication</span> <span class="n">uiapp</span> <span class="p">=</span> <span class="n">commandData</span><span class="p">.</span><span class="n">Application</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl"><span class="n">Suggested</span><span class="p">:</span> <span class="kt">var</span> <span class="n">uiApp</span> <span class="p">=</span> <span class="n">commandData</span><span class="p">.</span><span class="n">Application</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">	<span class="p">-</span> <span class="n">Follow</span> <span class="n">the</span> <span class="n">camelCase</span> <span class="n">pattern</span> <span class="n">used</span> <span class="k">in</span> <span class="n">other</span> <span class="n">files</span> <span class="p">(</span><span class="n">uiApp</span><span class="p">,</span> <span class="n">uiDoc</span><span class="p">,</span> <span class="n">not</span> <span class="n">uiapp</span><span class="p">,</span> <span class="n">uidoc</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="m">4.</span> <span class="n">Comments</span> <span class="n">Structure</span>  
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Current</span><span class="p">:</span> <span class="n">Uses</span> <span class="c1">// only elements actually visible in this view  </span>
</span></span><span class="line"><span class="cl"><span class="n">Suggested</span><span class="p">:</span> <span class="n">Add</span> <span class="n">proper</span> <span class="n">method</span><span class="p">-</span><span class="n">level</span> <span class="n">XML</span> <span class="n">documentation</span> <span class="n">comments</span> <span class="n">like</span> <span class="n">other</span> <span class="n">files</span><span class="p">:</span>  
</span></span><span class="line"><span class="cl"><span class="cs">/// &lt;summary&gt;  </span>
</span></span><span class="line"><span class="cl"><span class="cs">/// Auto-dimensioning command for section views  </span>
</span></span><span class="line"><span class="cl"><span class="cs">/// &lt;/summary&gt;  </span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="m">5.</span> <span class="n">File</span> <span class="n">Organization</span>  
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Current</span><span class="p">:</span> <span class="n">Single</span> <span class="n">complex</span> <span class="k">class</span> <span class="nc">with</span> <span class="n">multiple</span> <span class="kd">private</span> <span class="n">methods</span>  
</span></span><span class="line"><span class="cl"><span class="n">Suggested</span><span class="p">:</span> <span class="n">Consider</span> <span class="n">splitting</span> <span class="k">into</span><span class="p">:</span>  
</span></span><span class="line"><span class="cl">	<span class="p">-</span> <span class="n">Main</span> <span class="n">command</span> <span class="k">class</span> <span class="p">(</span><span class="n">Cmd_AutoDim</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">	<span class="p">-</span> <span class="n">Separate</span> <span class="n">service</span><span class="p">/</span><span class="n">helper</span> <span class="n">classes</span> <span class="k">for</span> <span class="n">dimension</span> <span class="n">logic</span>  
</span></span><span class="line"><span class="cl">	<span class="p">-</span> <span class="n">This</span> <span class="n">follows</span> <span class="n">the</span> <span class="n">single</span> <span class="n">responsibility</span> <span class="n">principle</span>  
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="m">6.</span> <span class="n">Error</span> <span class="n">Handling</span> <span class="n">Pattern</span>  
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Current</span><span class="p">:</span> <span class="n">Generic</span> <span class="k">try</span><span class="p">-</span><span class="k">catch</span> <span class="n">with</span> <span class="n">Russian</span> <span class="n">error</span> <span class="n">messages</span>  
</span></span><span class="line"><span class="cl"><span class="n">Suggested</span><span class="p">:</span>  
</span></span><span class="line"><span class="cl">	<span class="p">-</span> <span class="n">Use</span> <span class="n">consistent</span> <span class="n">error</span> <span class="n">message</span> <span class="n">language</span> <span class="p">(</span><span class="n">English</span> <span class="n">like</span> <span class="n">other</span> <span class="n">files</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">	<span class="p">-</span> <span class="n">Follow</span> <span class="n">the</span> <span class="n">established</span> <span class="n">error</span> <span class="n">handling</span> <span class="n">pattern</span> <span class="k">from</span> <span class="n">other</span> <span class="n">commands</span>  
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="m">7.</span> <span class="n">External</span> <span class="n">Dependencies</span>  
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Current</span><span class="p">:</span> <span class="n">References</span> <span class="n">DimensionAutomation</span><span class="p">.</span><span class="n">UI</span> <span class="k">namespace</span>  
</span></span><span class="line"><span class="cl"><span class="nn">Suggested</span><span class="p">:</span> <span class="n">Ensure</span> <span class="n">UI</span> <span class="n">classes</span> <span class="n">follow</span> <span class="n">the</span> <span class="n">project</span><span class="err">&#39;</span><span class="n">s</span> <span class="k">namespace</span> <span class="nn">structure</span> <span class="p">(</span><span class="n">UKON</span><span class="p">.</span><span class="n">UI</span> <span class="n">or</span> <span class="n">similar</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="m">8.</span> <span class="n">Transaction</span> <span class="n">Naming</span>  
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Current</span><span class="p">:</span> <span class="s">&#34;Создание маркеров и размерений&#34;</span> <span class="p">(</span><span class="n">Russian</span><span class="p">)</span>  
</span></span><span class="line"><span class="cl"><span class="n">Suggested</span><span class="p">:</span> <span class="n">Use</span> <span class="n">English</span> <span class="n">transaction</span> <span class="n">names</span> <span class="k">for</span> <span class="n">consistency</span>  
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="m">9.</span> <span class="n">Method</span> <span class="n">Extraction</span> <span class="n">Opportunities</span>  
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">The</span> <span class="n">Execute</span> <span class="n">method</span> <span class="k">is</span> <span class="n">quite</span> <span class="kt">long</span><span class="p">.</span> <span class="n">Consider</span> <span class="n">extracting</span><span class="p">:</span>  
</span></span><span class="line"><span class="cl">	<span class="p">-</span> <span class="n">User</span> <span class="n">input</span> <span class="n">validation</span> <span class="n">logic</span>  
</span></span><span class="line"><span class="cl">	<span class="p">-</span> <span class="n">Section</span> <span class="n">processing</span> <span class="n">setup</span>  
</span></span><span class="line"><span class="cl">	<span class="p">-</span> <span class="n">Error</span> <span class="n">message</span> <span class="n">display</span> <span class="n">logic</span>  
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="m">10.</span> <span class="n">Constants</span> <span class="n">Organization</span>  
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Current</span><span class="p">:</span> <span class="n">MIN_CURVE_LENGTH</span> <span class="n">defined</span> <span class="k">in</span> <span class="k">class</span>  
</span></span><span class="line"><span class="cl"><span class="nc">Suggested</span><span class="p">:</span> <span class="n">Consider</span> <span class="n">a</span> <span class="n">constants</span> <span class="k">class</span> <span class="nc">or</span> <span class="n">configuration</span> <span class="n">file</span> <span class="k">for</span> <span class="n">project</span><span class="p">-</span><span class="n">wide</span> <span class="n">constants</span>  
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">The</span> <span class="n">current</span> <span class="n">implementation</span> <span class="k">is</span> <span class="n">functional</span> <span class="n">but</span> <span class="n">doesn</span><span class="err">&#39;</span><span class="n">t</span> <span class="n">follow</span> <span class="n">the</span> <span class="n">established</span> <span class="n">architectural</span> <span class="n">patterns</span> <span class="n">of</span> <span class="n">the</span> <span class="n">UKON</span>  
</span></span><span class="line"><span class="cl"><span class="n">project</span><span class="p">.</span> <span class="n">The</span> <span class="n">main</span> <span class="n">issues</span> <span class="n">are</span> <span class="k">namespace</span> <span class="nn">inconsistency</span><span class="p">,</span> <span class="n">naming</span> <span class="n">conventions</span><span class="p">,</span> <span class="n">and</span> <span class="n">language</span> <span class="n">mixing</span><span class="p">.</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="old-code">Old Code<a hidden class="anchor" aria-hidden="true" href="#old-code">#</a></h1>
<h2 id="project-solution"><code>Project Solution</code><a hidden class="anchor" aria-hidden="true" href="#project-solution">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">Solution
</span></span><span class="line"><span class="cl"><span class="p">|</span>-&gt; ViewOnSheets2025
</span></span><span class="line"><span class="cl">	<span class="p">|</span>-&gt; Dependencies
</span></span><span class="line"><span class="cl">	<span class="p">|</span>-&gt; Properties
</span></span><span class="line"><span class="cl">	<span class="p">|</span>-&gt; Commands
</span></span><span class="line"><span class="cl">		<span class="p">|</span>-&gt; AutoLevelMarker.cs 
</span></span><span class="line"><span class="cl">		<span class="p">|</span>-&gt; DimensionAutomation.cs  
</span></span><span class="line"><span class="cl">		<span class="p">|</span>-&gt; RevitSectionCreator.cs 
</span></span><span class="line"><span class="cl">		<span class="p">|</span>-&gt; SpotDimensionAutomation.cs 
</span></span><span class="line"><span class="cl">		<span class="p">|</span>-&gt; ViewsOnSheets.cs 
</span></span><span class="line"><span class="cl">	<span class="p">|</span>-&gt; Globals 
</span></span><span class="line"><span class="cl">		<span class="p">|</span>-&gt; ElementTypeInfo.cs
</span></span><span class="line"><span class="cl">		<span class="p">|</span>-&gt; ParameterUtilities.cs
</span></span><span class="line"><span class="cl">		<span class="p">|</span>-&gt; PointOnElement.cs
</span></span><span class="line"><span class="cl">	<span class="p">|</span>-&gt; Resources
</span></span><span class="line"><span class="cl">		<span class="p">|</span>-&gt; Icons
</span></span><span class="line"><span class="cl">	<span class="p">|</span>-&gt; Services
</span></span><span class="line"><span class="cl">		<span class="p">|</span>-&gt; ViewsOnSheetsR2025Service.cs
</span></span><span class="line"><span class="cl">	<span class="p">|</span>-&gt; UI
</span></span><span class="line"><span class="cl">		<span class="p">|</span>-&gt; AutoLevelMarker.xaml
</span></span><span class="line"><span class="cl">		<span class="p">|</span>-&gt; DimensionAutomationWindow.xaml
</span></span><span class="line"><span class="cl">		<span class="p">|</span>-&gt; RevitSectionsCreatorWindow.xaml
</span></span><span class="line"><span class="cl">		<span class="p">|</span>-&gt; ViewOnSheetsR2025Windown.xaml
</span></span><span class="line"><span class="cl">	<span class="p">|</span>-&gt; Application.cs           
</span></span><span class="line"><span class="cl">	<span class="p">|</span>-&gt; guRoo.addin
</span></span></code></pre></td></tr></table>
</div>
</div><hr>
<h3 id="revitsectioncreatorcs"><code>RevitSectionCreator.cs</code><a hidden class="anchor" aria-hidden="true" href="#revitsectioncreatorcs">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span><span class="lnt">204
</span><span class="lnt">205
</span><span class="lnt">206
</span><span class="lnt">207
</span><span class="lnt">208
</span><span class="lnt">209
</span><span class="lnt">210
</span><span class="lnt">211
</span><span class="lnt">212
</span><span class="lnt">213
</span><span class="lnt">214
</span><span class="lnt">215
</span><span class="lnt">216
</span><span class="lnt">217
</span><span class="lnt">218
</span><span class="lnt">219
</span><span class="lnt">220
</span><span class="lnt">221
</span><span class="lnt">222
</span><span class="lnt">223
</span><span class="lnt">224
</span><span class="lnt">225
</span><span class="lnt">226
</span><span class="lnt">227
</span><span class="lnt">228
</span><span class="lnt">229
</span><span class="lnt">230
</span><span class="lnt">231
</span><span class="lnt">232
</span><span class="lnt">233
</span><span class="lnt">234
</span><span class="lnt">235
</span><span class="lnt">236
</span><span class="lnt">237
</span><span class="lnt">238
</span><span class="lnt">239
</span><span class="lnt">240
</span><span class="lnt">241
</span><span class="lnt">242
</span><span class="lnt">243
</span><span class="lnt">244
</span><span class="lnt">245
</span><span class="lnt">246
</span><span class="lnt">247
</span><span class="lnt">248
</span><span class="lnt">249
</span><span class="lnt">250
</span><span class="lnt">251
</span><span class="lnt">252
</span><span class="lnt">253
</span><span class="lnt">254
</span><span class="lnt">255
</span><span class="lnt">256
</span><span class="lnt">257
</span><span class="lnt">258
</span><span class="lnt">259
</span><span class="lnt">260
</span><span class="lnt">261
</span><span class="lnt">262
</span><span class="lnt">263
</span><span class="lnt">264
</span><span class="lnt">265
</span><span class="lnt">266
</span><span class="lnt">267
</span><span class="lnt">268
</span><span class="lnt">269
</span><span class="lnt">270
</span><span class="lnt">271
</span><span class="lnt">272
</span><span class="lnt">273
</span><span class="lnt">274
</span><span class="lnt">275
</span><span class="lnt">276
</span><span class="lnt">277
</span><span class="lnt">278
</span><span class="lnt">279
</span><span class="lnt">280
</span><span class="lnt">281
</span><span class="lnt">282
</span><span class="lnt">283
</span><span class="lnt">284
</span><span class="lnt">285
</span><span class="lnt">286
</span><span class="lnt">287
</span><span class="lnt">288
</span><span class="lnt">289
</span><span class="lnt">290
</span><span class="lnt">291
</span><span class="lnt">292
</span><span class="lnt">293
</span><span class="lnt">294
</span><span class="lnt">295
</span><span class="lnt">296
</span><span class="lnt">297
</span><span class="lnt">298
</span><span class="lnt">299
</span><span class="lnt">300
</span><span class="lnt">301
</span><span class="lnt">302
</span><span class="lnt">303
</span><span class="lnt">304
</span><span class="lnt">305
</span><span class="lnt">306
</span><span class="lnt">307
</span><span class="lnt">308
</span><span class="lnt">309
</span><span class="lnt">310
</span><span class="lnt">311
</span><span class="lnt">312
</span><span class="lnt">313
</span><span class="lnt">314
</span><span class="lnt">315
</span><span class="lnt">316
</span><span class="lnt">317
</span><span class="lnt">318
</span><span class="lnt">319
</span><span class="lnt">320
</span><span class="lnt">321
</span><span class="lnt">322
</span><span class="lnt">323
</span><span class="lnt">324
</span><span class="lnt">325
</span><span class="lnt">326
</span><span class="lnt">327
</span><span class="lnt">328
</span><span class="lnt">329
</span><span class="lnt">330
</span><span class="lnt">331
</span><span class="lnt">332
</span><span class="lnt">333
</span><span class="lnt">334
</span><span class="lnt">335
</span><span class="lnt">336
</span><span class="lnt">337
</span><span class="lnt">338
</span><span class="lnt">339
</span><span class="lnt">340
</span><span class="lnt">341
</span><span class="lnt">342
</span><span class="lnt">343
</span><span class="lnt">344
</span><span class="lnt">345
</span><span class="lnt">346
</span><span class="lnt">347
</span><span class="lnt">348
</span><span class="lnt">349
</span><span class="lnt">350
</span><span class="lnt">351
</span><span class="lnt">352
</span><span class="lnt">353
</span><span class="lnt">354
</span><span class="lnt">355
</span><span class="lnt">356
</span><span class="lnt">357
</span><span class="lnt">358
</span><span class="lnt">359
</span><span class="lnt">360
</span><span class="lnt">361
</span><span class="lnt">362
</span><span class="lnt">363
</span><span class="lnt">364
</span><span class="lnt">365
</span><span class="lnt">366
</span><span class="lnt">367
</span><span class="lnt">368
</span><span class="lnt">369
</span><span class="lnt">370
</span><span class="lnt">371
</span><span class="lnt">372
</span><span class="lnt">373
</span><span class="lnt">374
</span><span class="lnt">375
</span><span class="lnt">376
</span><span class="lnt">377
</span><span class="lnt">378
</span><span class="lnt">379
</span><span class="lnt">380
</span><span class="lnt">381
</span><span class="lnt">382
</span><span class="lnt">383
</span><span class="lnt">384
</span><span class="lnt">385
</span><span class="lnt">386
</span><span class="lnt">387
</span><span class="lnt">388
</span><span class="lnt">389
</span><span class="lnt">390
</span><span class="lnt">391
</span><span class="lnt">392
</span><span class="lnt">393
</span><span class="lnt">394
</span><span class="lnt">395
</span><span class="lnt">396
</span><span class="lnt">397
</span><span class="lnt">398
</span><span class="lnt">399
</span><span class="lnt">400
</span><span class="lnt">401
</span><span class="lnt">402
</span><span class="lnt">403
</span><span class="lnt">404
</span><span class="lnt">405
</span><span class="lnt">406
</span><span class="lnt">407
</span><span class="lnt">408
</span><span class="lnt">409
</span><span class="lnt">410
</span><span class="lnt">411
</span><span class="lnt">412
</span><span class="lnt">413
</span><span class="lnt">414
</span><span class="lnt">415
</span><span class="lnt">416
</span><span class="lnt">417
</span><span class="lnt">418
</span><span class="lnt">419
</span><span class="lnt">420
</span><span class="lnt">421
</span><span class="lnt">422
</span><span class="lnt">423
</span><span class="lnt">424
</span><span class="lnt">425
</span><span class="lnt">426
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="k">using</span> <span class="nn">Autodesk.Revit.Attributes</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="nn">Autodesk.Revit.DB</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="nn">Autodesk.Revit.UI</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="nn">RevitSectionCreator.UI</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">namespace</span> <span class="nn">RevitSectionCreator</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="na">    [Transaction(TransactionMode.Manual)]</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="k">class</span> <span class="nc">Command</span> <span class="p">:</span> <span class="n">IExternalCommand</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kd">public</span> <span class="n">Result</span> <span class="n">Execute</span><span class="p">(</span><span class="n">ExternalCommandData</span> <span class="n">commandData</span><span class="p">,</span> <span class="k">ref</span> <span class="kt">string</span> <span class="n">message</span><span class="p">,</span> <span class="n">ElementSet</span> <span class="n">elements</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">UIApplication</span> <span class="n">uiapp</span> <span class="p">=</span> <span class="n">commandData</span><span class="p">.</span><span class="n">Application</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">UIDocument</span> <span class="n">uidoc</span> <span class="p">=</span> <span class="n">uiapp</span><span class="p">.</span><span class="n">ActiveUIDocument</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">Document</span> <span class="n">doc</span> <span class="p">=</span> <span class="n">uidoc</span><span class="p">.</span><span class="n">Document</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="k">try</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// STEP 1: Collect element types for section creation.</span>
</span></span><span class="line"><span class="cl">                <span class="n">List</span><span class="p">&lt;</span><span class="n">ElementTypeInfo</span><span class="p">&gt;</span> <span class="n">elementTypes</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">ElementTypeInfo</span><span class="p">&gt;();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="c1">// Collect FamilyInstance elements and group them by the family name.</span>
</span></span><span class="line"><span class="cl">                <span class="kt">var</span> <span class="n">familyInstances</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="p">.</span><span class="n">OfClass</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">FamilyInstance</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                    <span class="p">.</span><span class="n">Cast</span><span class="p">&lt;</span><span class="n">FamilyInstance</span><span class="p">&gt;()</span>
</span></span><span class="line"><span class="cl">                    <span class="p">.</span><span class="n">ToList</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="kt">var</span> <span class="n">familyGroups</span> <span class="p">=</span> <span class="n">familyInstances</span>
</span></span><span class="line"><span class="cl">                    <span class="p">.</span><span class="n">GroupBy</span><span class="p">(</span><span class="n">fi</span> <span class="p">=&gt;</span> <span class="n">fi</span><span class="p">.</span><span class="n">Symbol</span><span class="p">.</span><span class="n">FamilyName</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="p">.</span><span class="n">Select</span><span class="p">(</span><span class="n">g</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">ElementTypeInfo</span>
</span></span><span class="line"><span class="cl">                    <span class="p">{</span>
</span></span><span class="line"><span class="cl">                        <span class="n">TypeName</span> <span class="p">=</span> <span class="n">g</span><span class="p">.</span><span class="n">Key</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                        <span class="n">Category</span> <span class="p">=</span> <span class="s">&#34;Семейство&#34;</span><span class="p">,</span> <span class="c1">// &#34;Family&#34; in Russian</span>
</span></span><span class="line"><span class="cl">                        <span class="n">ElementIds</span> <span class="p">=</span> <span class="n">g</span><span class="p">.</span><span class="n">Select</span><span class="p">(</span><span class="n">fi</span> <span class="p">=&gt;</span> <span class="n">fi</span><span class="p">.</span><span class="n">Id</span><span class="p">).</span><span class="n">ToList</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">                    <span class="p">})</span>
</span></span><span class="line"><span class="cl">                    <span class="p">.</span><span class="n">ToList</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">                <span class="n">elementTypes</span><span class="p">.</span><span class="n">AddRange</span><span class="p">(</span><span class="n">familyGroups</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="c1">// Collect DirectShape elements.</span>
</span></span><span class="line"><span class="cl">                <span class="kt">var</span> <span class="n">directShapes</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="p">.</span><span class="n">OfClass</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">DirectShape</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                    <span class="p">.</span><span class="n">Cast</span><span class="p">&lt;</span><span class="n">DirectShape</span><span class="p">&gt;()</span>
</span></span><span class="line"><span class="cl">                    <span class="p">.</span><span class="n">ToList</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="kt">var</span> <span class="n">directShapeGroups</span> <span class="p">=</span> <span class="n">directShapes</span>
</span></span><span class="line"><span class="cl">                    <span class="p">.</span><span class="n">GroupBy</span><span class="p">(</span><span class="n">ds</span> <span class="p">=&gt;</span> <span class="n">ds</span><span class="p">.</span><span class="n">Category</span><span class="p">?.</span><span class="n">Name</span> <span class="p">??</span> <span class="s">&#34;Без категории&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="p">.</span><span class="n">Select</span><span class="p">(</span><span class="n">g</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">ElementTypeInfo</span>
</span></span><span class="line"><span class="cl">                    <span class="p">{</span>
</span></span><span class="line"><span class="cl">                        <span class="n">TypeName</span> <span class="p">=</span> <span class="s">$&#34;DirectShape - {g.Key}&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                        <span class="n">Category</span> <span class="p">=</span> <span class="s">&#34;DirectShape&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                        <span class="n">ElementIds</span> <span class="p">=</span> <span class="n">g</span><span class="p">.</span><span class="n">Select</span><span class="p">(</span><span class="n">ds</span> <span class="p">=&gt;</span> <span class="n">ds</span><span class="p">.</span><span class="n">Id</span><span class="p">).</span><span class="n">ToList</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">                    <span class="p">})</span>
</span></span><span class="line"><span class="cl">                    <span class="p">.</span><span class="n">ToList</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">                <span class="n">elementTypes</span><span class="p">.</span><span class="n">AddRange</span><span class="p">(</span><span class="n">directShapeGroups</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="c1">// Collect ImportInstance elements (excluding links).</span>
</span></span><span class="line"><span class="cl">                <span class="kt">var</span> <span class="n">importInstances</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="p">.</span><span class="n">OfClass</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">ImportInstance</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                    <span class="p">.</span><span class="n">Cast</span><span class="p">&lt;</span><span class="n">ImportInstance</span><span class="p">&gt;()</span>
</span></span><span class="line"><span class="cl">                    <span class="p">.</span><span class="n">Where</span><span class="p">(</span><span class="n">ii</span> <span class="p">=&gt;</span> <span class="p">!</span><span class="n">ii</span><span class="p">.</span><span class="n">IsLinked</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="p">.</span><span class="n">ToList</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="kt">var</span> <span class="n">importGroups</span> <span class="p">=</span> <span class="n">importInstances</span>
</span></span><span class="line"><span class="cl">                    <span class="p">.</span><span class="n">GroupBy</span><span class="p">(</span><span class="n">ii</span> <span class="p">=&gt;</span> <span class="n">ii</span><span class="p">.</span><span class="n">Category</span><span class="p">?.</span><span class="n">Name</span> <span class="p">??</span> <span class="s">&#34;Без категории импорта&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="p">.</span><span class="n">Select</span><span class="p">(</span><span class="n">g</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">ElementTypeInfo</span>
</span></span><span class="line"><span class="cl">                    <span class="p">{</span>
</span></span><span class="line"><span class="cl">                        <span class="n">TypeName</span> <span class="p">=</span> <span class="s">$&#34;Import - {g.Key}&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                        <span class="n">Category</span> <span class="p">=</span> <span class="s">&#34;Import&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                        <span class="n">ElementIds</span> <span class="p">=</span> <span class="n">g</span><span class="p">.</span><span class="n">Select</span><span class="p">(</span><span class="n">ii</span> <span class="p">=&gt;</span> <span class="n">ii</span><span class="p">.</span><span class="n">Id</span><span class="p">).</span><span class="n">ToList</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">                    <span class="p">})</span>
</span></span><span class="line"><span class="cl">                    <span class="p">.</span><span class="n">ToList</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">                <span class="n">elementTypes</span><span class="p">.</span><span class="n">AddRange</span><span class="p">(</span><span class="n">importGroups</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">elementTypes</span><span class="p">.</span><span class="n">Count</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">TaskDialog</span><span class="p">.</span><span class="n">Show</span><span class="p">(</span><span class="s">&#34;Ошибка&#34;</span><span class="p">,</span> <span class="s">&#34;В документе не найдено подходящих элементов.&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                    <span class="k">return</span> <span class="n">Result</span><span class="p">.</span><span class="n">Failed</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="c1">// Sort the element types by category then by type name.</span>
</span></span><span class="line"><span class="cl">                <span class="n">elementTypes</span> <span class="p">=</span> <span class="n">elementTypes</span>
</span></span><span class="line"><span class="cl">                    <span class="p">.</span><span class="n">OrderBy</span><span class="p">(</span><span class="n">et</span> <span class="p">=&gt;</span> <span class="n">et</span><span class="p">.</span><span class="n">Category</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="p">.</span><span class="n">ThenBy</span><span class="p">(</span><span class="n">et</span> <span class="p">=&gt;</span> <span class="n">et</span><span class="p">.</span><span class="n">TypeName</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="p">.</span><span class="n">ToList</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="c1">// STEP 2: Display the unified WPF window to get user choices.</span>
</span></span><span class="line"><span class="cl">                <span class="n">RevitSectionCreatorWindow</span> <span class="n">sectionWindow</span> <span class="p">=</span> <span class="k">new</span> <span class="n">RevitSectionCreatorWindow</span><span class="p">(</span><span class="n">elementTypes</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">sectionWindow</span><span class="p">.</span><span class="n">ShowDialog</span><span class="p">()</span> <span class="p">!=</span> <span class="kc">true</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="k">return</span> <span class="n">Result</span><span class="p">.</span><span class="n">Cancelled</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="c1">// Retrieve selections from the combined window.</span>
</span></span><span class="line"><span class="cl">                <span class="n">ElementTypeInfo</span> <span class="n">selectedType</span> <span class="p">=</span> <span class="n">sectionWindow</span><span class="p">.</span><span class="n">SelectedElementType</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="kt">string</span> <span class="n">selectedFace</span> <span class="p">=</span> <span class="n">sectionWindow</span><span class="p">.</span><span class="n">SelectedFace</span><span class="p">;</span> <span class="c1">// e.g., &#34;Левая грань&#34;</span>
</span></span><span class="line"><span class="cl">                <span class="kt">double</span> <span class="n">offsetMm</span> <span class="p">=</span> <span class="n">sectionWindow</span><span class="p">.</span><span class="n">OffsetValue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="c1">// STEP 3: Create section views.</span>
</span></span><span class="line"><span class="cl">                <span class="k">using</span> <span class="p">(</span><span class="n">Transaction</span> <span class="n">t</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Transaction</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="s">$&#34;Создание разрезов для {selectedType.TypeName}&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">t</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                    <span class="c1">// Get the Section ViewFamilyType.</span>
</span></span><span class="line"><span class="cl">                    <span class="k">using</span> <span class="nn">ViewFamilyType</span> <span class="n">sectionType</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                        <span class="p">.</span><span class="n">OfClass</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">ViewFamilyType</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                        <span class="p">.</span><span class="n">Cast</span><span class="p">&lt;</span><span class="n">ViewFamilyType</span><span class="p">&gt;()</span>
</span></span><span class="line"><span class="cl">                        <span class="p">.</span><span class="n">FirstOrDefault</span><span class="p">(</span><span class="n">vt</span> <span class="p">=&gt;</span> <span class="n">vt</span><span class="p">.</span><span class="n">ViewFamily</span> <span class="p">==</span> <span class="n">ViewFamily</span><span class="p">.</span><span class="n">Section</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                    <span class="k">if</span> <span class="p">(</span><span class="n">sectionType</span> <span class="p">==</span> <span class="kc">null</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="p">{</span>
</span></span><span class="line"><span class="cl">                        <span class="n">TaskDialog</span><span class="p">.</span><span class="n">Show</span><span class="p">(</span><span class="s">&#34;Ошибка&#34;</span><span class="p">,</span> <span class="s">&#34;Не найден тип семейства для разреза.&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                        <span class="k">return</span> <span class="n">Result</span><span class="p">.</span><span class="n">Failed</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                    <span class="c1">// Retrieve the actual elements from the selected type.</span>
</span></span><span class="line"><span class="cl">                    <span class="n">List</span><span class="p">&lt;</span><span class="n">Element</span><span class="p">&gt;</span> <span class="n">elementsToProcess</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Element</span><span class="p">&gt;();</span>
</span></span><span class="line"><span class="cl">                    <span class="k">foreach</span> <span class="p">(</span><span class="n">ElementId</span> <span class="n">id</span> <span class="k">in</span> <span class="n">selectedType</span><span class="p">.</span><span class="n">ElementIds</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="p">{</span>
</span></span><span class="line"><span class="cl">                        <span class="n">Element</span> <span class="n">elem</span> <span class="p">=</span> <span class="n">doc</span><span class="p">.</span><span class="n">GetElement</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                        <span class="k">if</span> <span class="p">(</span><span class="n">elem</span> <span class="p">!=</span> <span class="kc">null</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                        <span class="p">{</span>
</span></span><span class="line"><span class="cl">                            <span class="n">elementsToProcess</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">elem</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                        <span class="p">}</span>
</span></span><span class="line"><span class="cl">                    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                    <span class="k">if</span> <span class="p">(!</span><span class="n">elementsToProcess</span><span class="p">.</span><span class="n">Any</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">                    <span class="p">{</span>
</span></span><span class="line"><span class="cl">                        <span class="n">TaskDialog</span><span class="p">.</span><span class="n">Show</span><span class="p">(</span><span class="s">&#34;Ошибка&#34;</span><span class="p">,</span> <span class="s">$&#34;Элементы типа &#39;{selectedType.TypeName}&#39; не найдены.&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                        <span class="k">return</span> <span class="n">Result</span><span class="p">.</span><span class="n">Failed</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                    <span class="c1">// Determine the base direction from the selected face.</span>
</span></span><span class="line"><span class="cl">                    <span class="n">XYZ</span> <span class="n">baseDirection</span> <span class="p">=</span> <span class="n">GetDirectionFromFace</span><span class="p">(</span><span class="n">selectedFace</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                    <span class="kt">int</span> <span class="n">sectionCount</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                    <span class="k">foreach</span> <span class="p">(</span><span class="n">Element</span> <span class="n">element</span> <span class="k">in</span> <span class="n">elementsToProcess</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="p">{</span>
</span></span><span class="line"><span class="cl">                        <span class="kt">string</span> <span class="n">elementMark</span> <span class="p">=</span> <span class="n">GetElementMark</span><span class="p">(</span><span class="n">element</span><span class="p">)</span> <span class="p">??</span> <span class="n">element</span><span class="p">.</span><span class="n">Name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                        <span class="n">List</span><span class="p">&lt;</span><span class="n">ElementId</span><span class="p">&gt;</span> <span class="n">partIds</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">ElementId</span><span class="p">&gt;();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                        <span class="c1">// For FamilyInstance elements, try to get associated parts.</span>
</span></span><span class="line"><span class="cl">                        <span class="k">if</span> <span class="p">(</span><span class="n">element</span> <span class="k">is</span> <span class="n">FamilyInstance</span> <span class="n">familyInstance</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                        <span class="p">{</span>
</span></span><span class="line"><span class="cl">                            <span class="n">ICollection</span><span class="p">&lt;</span><span class="n">ElementId</span><span class="p">&gt;</span> <span class="n">associatedParts</span> <span class="p">=</span> <span class="n">PartUtils</span><span class="p">.</span><span class="n">GetAssociatedParts</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="n">familyInstance</span><span class="p">.</span><span class="n">Id</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                            <span class="n">partIds</span><span class="p">.</span><span class="n">AddRange</span><span class="p">(</span><span class="n">associatedParts</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                        <span class="c1">// If no associated parts, use the element itself.</span>
</span></span><span class="line"><span class="cl">                        <span class="k">if</span> <span class="p">(</span><span class="n">partIds</span><span class="p">.</span><span class="n">Count</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                        <span class="p">{</span>
</span></span><span class="line"><span class="cl">                            <span class="n">partIds</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">element</span><span class="p">.</span><span class="n">Id</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                        <span class="k">foreach</span> <span class="p">(</span><span class="n">ElementId</span> <span class="n">partId</span> <span class="k">in</span> <span class="n">partIds</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                        <span class="p">{</span>
</span></span><span class="line"><span class="cl">                            <span class="n">Element</span> <span class="n">part</span> <span class="p">=</span> <span class="n">doc</span><span class="p">.</span><span class="n">GetElement</span><span class="p">(</span><span class="n">partId</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                            <span class="kt">string</span> <span class="n">partMark</span> <span class="p">=</span> <span class="n">GetElementMark</span><span class="p">(</span><span class="n">part</span><span class="p">)</span> <span class="p">??</span> <span class="n">part</span><span class="p">.</span><span class="n">Name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                            <span class="c1">// Use the base direction from the unified dialog.</span>
</span></span><span class="line"><span class="cl">                            <span class="n">XYZ</span> <span class="n">finalDirection</span> <span class="p">=</span> <span class="n">baseDirection</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                            <span class="c1">// Find the best-aligned face on the element.</span>
</span></span><span class="line"><span class="cl">                            <span class="n">Face</span> <span class="n">chosenFace</span> <span class="p">=</span> <span class="n">GetLocalDirectionFace</span><span class="p">(</span><span class="n">part</span><span class="p">,</span> <span class="n">finalDirection</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                            <span class="k">if</span> <span class="p">(</span><span class="n">chosenFace</span> <span class="p">==</span> <span class="kc">null</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                                <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                            <span class="c1">// Create the section view.</span>
</span></span><span class="line"><span class="cl">                            <span class="n">ViewSection</span> <span class="n">sectionView</span> <span class="p">=</span> <span class="n">CreateSectionView</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="n">sectionType</span><span class="p">.</span><span class="n">Id</span><span class="p">,</span> <span class="n">chosenFace</span><span class="p">,</span> <span class="n">offsetMm</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                            <span class="k">if</span> <span class="p">(</span><span class="n">sectionView</span> <span class="p">!=</span> <span class="kc">null</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                                <span class="k">try</span>
</span></span><span class="line"><span class="cl">                                <span class="p">{</span>
</span></span><span class="line"><span class="cl">                                    <span class="c1">// Build a name for the new section view.</span>
</span></span><span class="line"><span class="cl">                                    <span class="kt">string</span> <span class="n">rawPartName</span> <span class="p">=</span> <span class="p">!</span><span class="kt">string</span><span class="p">.</span><span class="n">IsNullOrEmpty</span><span class="p">(</span><span class="n">partMark</span><span class="p">)</span> <span class="p">?</span> <span class="n">partMark</span> <span class="p">:</span> <span class="n">elementMark</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                                    <span class="kt">string</span> <span class="n">faceLabel</span> <span class="p">=</span> <span class="n">selectedFace</span><span class="p">.</span><span class="n">Replace</span><span class="p">(</span><span class="s">&#34; &#34;</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">);</span> <span class="c1">// Remove spaces for naming.</span>
</span></span><span class="line"><span class="cl">                                    <span class="kt">string</span> <span class="n">offsetStrForm</span> <span class="p">=</span> <span class="p">(</span><span class="n">offsetMm</span> <span class="p">%</span> <span class="m">1</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span> <span class="p">?</span> <span class="s">$&#34;{(int)offsetMm}мм&#34;</span> <span class="p">:</span> <span class="s">$&#34;{offsetMm}мм&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                                    <span class="kt">string</span> <span class="n">combinedName</span> <span class="p">=</span> <span class="s">$&#34;{rawPartName}_{faceLabel}_{offsetStrForm}&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                                    <span class="kt">string</span> <span class="n">uniqueName</span> <span class="p">=</span> <span class="n">GenerateUniqueName</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="n">combinedName</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                                    <span class="n">sectionView</span><span class="p">.</span><span class="n">Name</span> <span class="p">=</span> <span class="n">uniqueName</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                                    <span class="c1">// Apply crop region to the section view.</span>
</span></span><span class="line"><span class="cl">                                    <span class="n">CreateViewCrop</span><span class="p">(</span><span class="n">sectionView</span><span class="p">,</span> <span class="n">chosenFace</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                                    <span class="n">sectionCount</span><span class="p">++;</span>
</span></span><span class="line"><span class="cl">                                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                                <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">ex</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                                <span class="p">{</span>
</span></span><span class="line"><span class="cl">                                    <span class="n">TaskDialog</span><span class="p">.</span><span class="n">Show</span><span class="p">(</span><span class="s">&#34;Предупреждение&#34;</span><span class="p">,</span> <span class="s">$&#34;Не удалось задать имя для вида: {ex.Message}&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                            <span class="p">}</span>
</span></span><span class="line"><span class="cl">                        <span class="p">}</span>
</span></span><span class="line"><span class="cl">                    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                    <span class="n">t</span><span class="p">.</span><span class="n">Commit</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">                    <span class="n">TaskDialog</span><span class="p">.</span><span class="n">Show</span><span class="p">(</span><span class="s">&#34;Успех&#34;</span><span class="p">,</span> <span class="s">$&#34;Создано {sectionCount} разрезов для {selectedType.TypeName}.&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="n">Result</span><span class="p">.</span><span class="n">Succeeded</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">ex</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">message</span> <span class="p">=</span> <span class="n">ex</span><span class="p">.</span><span class="n">Message</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="n">Result</span><span class="p">.</span><span class="n">Failed</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cp">#region</span> <span class="n">Helper</span> <span class="n">Methods</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// Maps Russian face names to direction vectors.</span>
</span></span><span class="line"><span class="cl">        <span class="kd">private</span> <span class="n">XYZ</span> <span class="n">GetDirectionFromFace</span><span class="p">(</span><span class="kt">string</span> <span class="n">faceName</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="kt">var</span> <span class="n">directionMap</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="n">XYZ</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="p">{</span> <span class="s">&#34;Левая грань&#34;</span><span class="p">,</span> <span class="k">new</span> <span class="n">XYZ</span><span class="p">(-</span><span class="m">1</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span> <span class="p">},</span>
</span></span><span class="line"><span class="cl">                <span class="p">{</span> <span class="s">&#34;Правая грань&#34;</span><span class="p">,</span> <span class="k">new</span> <span class="n">XYZ</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span> <span class="p">},</span>
</span></span><span class="line"><span class="cl">                <span class="p">{</span> <span class="s">&#34;Передняя грань&#34;</span><span class="p">,</span> <span class="k">new</span> <span class="n">XYZ</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span> <span class="p">},</span>
</span></span><span class="line"><span class="cl">                <span class="p">{</span> <span class="s">&#34;Задняя грань&#34;</span><span class="p">,</span> <span class="k">new</span> <span class="n">XYZ</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="p">-</span><span class="m">1</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span> <span class="p">},</span>
</span></span><span class="line"><span class="cl">                <span class="p">{</span> <span class="s">&#34;Верхняя грань&#34;</span><span class="p">,</span> <span class="k">new</span> <span class="n">XYZ</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span> <span class="p">},</span>
</span></span><span class="line"><span class="cl">                <span class="p">{</span> <span class="s">&#34;Нижняя грань&#34;</span><span class="p">,</span> <span class="k">new</span> <span class="n">XYZ</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="p">-</span><span class="m">1</span><span class="p">)</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">directionMap</span><span class="p">.</span><span class="n">TryGetValue</span><span class="p">(</span><span class="n">faceName</span><span class="p">,</span> <span class="k">out</span> <span class="n">XYZ</span> <span class="n">direction</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="n">direction</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">XYZ</span><span class="p">.</span><span class="n">BasisY</span><span class="p">;</span> <span class="c1">// Fallback</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// Retrieves the element&#39;s &#34;mark&#34; or returns its name.</span>
</span></span><span class="line"><span class="cl">        <span class="kd">private</span> <span class="kt">string</span> <span class="n">GetElementMark</span><span class="p">(</span><span class="n">Element</span> <span class="n">element</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">Parameter</span> <span class="n">markParam</span> <span class="p">=</span> <span class="n">element</span><span class="p">.</span><span class="n">get_Parameter</span><span class="p">(</span><span class="n">BuiltInParameter</span><span class="p">.</span><span class="n">ALL_MODEL_MARK</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">markParam</span> <span class="p">!=</span> <span class="kc">null</span> <span class="p">&amp;&amp;</span> <span class="n">markParam</span><span class="p">.</span><span class="n">HasValue</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="kt">string</span> <span class="n">markValue</span> <span class="p">=</span> <span class="n">markParam</span><span class="p">.</span><span class="n">AsString</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(!</span><span class="kt">string</span><span class="p">.</span><span class="n">IsNullOrEmpty</span><span class="p">(</span><span class="n">markValue</span><span class="p">)</span> <span class="p">&amp;&amp;</span> <span class="n">markValue</span><span class="p">.</span><span class="n">Contains</span><span class="p">(</span><span class="s">&#34;Ст.&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="kt">string</span> <span class="n">numberPart</span> <span class="p">=</span> <span class="n">markValue</span><span class="p">.</span><span class="n">Split</span><span class="p">(</span><span class="k">new</span><span class="p">[]</span> <span class="p">{</span> <span class="s">&#34;Ст.&#34;</span> <span class="p">},</span> <span class="n">StringSplitOptions</span><span class="p">.</span><span class="n">None</span><span class="p">)[</span><span class="m">1</span><span class="p">].</span><span class="n">Trim</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">                    <span class="k">return</span> <span class="s">$&#34;О_Р_{numberPart}&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="n">markValue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// Generates a unique name for a view by appending additional characters if needed.</span>
</span></span><span class="line"><span class="cl">        <span class="kd">private</span> <span class="kt">string</span> <span class="n">GenerateUniqueName</span><span class="p">(</span><span class="n">Document</span> <span class="n">doc</span><span class="p">,</span> <span class="kt">string</span> <span class="n">baseName</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="kt">string</span> <span class="n">testName</span> <span class="p">=</span> <span class="n">baseName</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int</span> <span class="n">counter</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">List</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">existingNames</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">.</span><span class="n">OfClass</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">View</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                <span class="p">.</span><span class="n">Cast</span><span class="p">&lt;</span><span class="n">View</span><span class="p">&gt;()</span>
</span></span><span class="line"><span class="cl">                <span class="p">.</span><span class="n">Select</span><span class="p">(</span><span class="n">v</span> <span class="p">=&gt;</span> <span class="n">v</span><span class="p">.</span><span class="n">Name</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">.</span><span class="n">ToList</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="k">while</span> <span class="p">(</span><span class="n">existingNames</span><span class="p">.</span><span class="n">Contains</span><span class="p">(</span><span class="n">testName</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">counter</span><span class="p">++;</span>
</span></span><span class="line"><span class="cl">                <span class="n">testName</span> <span class="p">=</span> <span class="n">baseName</span> <span class="p">+</span> <span class="k">new</span> <span class="kt">string</span><span class="p">(</span><span class="sc">&#39;*&#39;</span><span class="p">,</span> <span class="n">counter</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">testName</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// Creates a crop boundary (CurveLoop) from a given face.</span>
</span></span><span class="line"><span class="cl">        <span class="kd">private</span> <span class="n">CurveLoop</span> <span class="n">CreateCropBoundary</span><span class="p">(</span><span class="n">Face</span> <span class="n">face</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">try</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">BoundingBoxUV</span> <span class="n">uvBbox</span> <span class="p">=</span> <span class="n">face</span><span class="p">.</span><span class="n">GetBoundingBox</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">                <span class="n">List</span><span class="p">&lt;</span><span class="n">XYZ</span><span class="p">&gt;</span> <span class="n">points</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">XYZ</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">                <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">face</span><span class="p">.</span><span class="n">Evaluate</span><span class="p">(</span><span class="k">new</span> <span class="n">UV</span><span class="p">(</span><span class="n">uvBbox</span><span class="p">.</span><span class="n">Min</span><span class="p">.</span><span class="n">U</span><span class="p">,</span> <span class="n">uvBbox</span><span class="p">.</span><span class="n">Min</span><span class="p">.</span><span class="n">V</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">                    <span class="n">face</span><span class="p">.</span><span class="n">Evaluate</span><span class="p">(</span><span class="k">new</span> <span class="n">UV</span><span class="p">(</span><span class="n">uvBbox</span><span class="p">.</span><span class="n">Max</span><span class="p">.</span><span class="n">U</span><span class="p">,</span> <span class="n">uvBbox</span><span class="p">.</span><span class="n">Min</span><span class="p">.</span><span class="n">V</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">                    <span class="n">face</span><span class="p">.</span><span class="n">Evaluate</span><span class="p">(</span><span class="k">new</span> <span class="n">UV</span><span class="p">(</span><span class="n">uvBbox</span><span class="p">.</span><span class="n">Max</span><span class="p">.</span><span class="n">U</span><span class="p">,</span> <span class="n">uvBbox</span><span class="p">.</span><span class="n">Max</span><span class="p">.</span><span class="n">V</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">                    <span class="n">face</span><span class="p">.</span><span class="n">Evaluate</span><span class="p">(</span><span class="k">new</span> <span class="n">UV</span><span class="p">(</span><span class="n">uvBbox</span><span class="p">.</span><span class="n">Min</span><span class="p">.</span><span class="n">U</span><span class="p">,</span> <span class="n">uvBbox</span><span class="p">.</span><span class="n">Max</span><span class="p">.</span><span class="n">V</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="n">List</span><span class="p">&lt;</span><span class="n">Curve</span><span class="p">&gt;</span> <span class="n">curves</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Curve</span><span class="p">&gt;();</span>
</span></span><span class="line"><span class="cl">                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">4</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
</span></span><span class="line"><span class="cl">                <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">XYZ</span> <span class="n">start</span> <span class="p">=</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                    <span class="n">XYZ</span> <span class="n">end</span> <span class="p">=</span> <span class="n">points</span><span class="p">[(</span><span class="n">i</span> <span class="p">+</span> <span class="m">1</span><span class="p">)</span> <span class="p">%</span> <span class="m">4</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                    <span class="n">curves</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">Line</span><span class="p">.</span><span class="n">CreateBound</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="n">CurveLoop</span><span class="p">.</span><span class="n">Create</span><span class="p">(</span><span class="n">curves</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">catch</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// Sets up the crop boundary on a section view.</span>
</span></span><span class="line"><span class="cl">        <span class="kd">private</span> <span class="kt">bool</span> <span class="n">CreateViewCrop</span><span class="p">(</span><span class="n">ViewSection</span> <span class="n">view</span><span class="p">,</span> <span class="n">Face</span> <span class="n">face</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">try</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(!</span><span class="n">view</span><span class="p">.</span><span class="n">CropBoxActive</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="n">view</span><span class="p">.</span><span class="n">CropBoxActive</span> <span class="p">=</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="n">CurveLoop</span> <span class="n">cropLoop</span> <span class="p">=</span> <span class="n">CreateCropBoundary</span><span class="p">(</span><span class="n">face</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">cropLoop</span> <span class="p">!=</span> <span class="kc">null</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">view</span><span class="p">.</span><span class="n">GetCropRegionShapeManager</span><span class="p">().</span><span class="n">SetCropShape</span><span class="p">(</span><span class="n">cropLoop</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">catch</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// Determines the face on an element that best aligns with the local direction.</span>
</span></span><span class="line"><span class="cl">        <span class="kd">private</span> <span class="n">Face</span> <span class="n">GetLocalDirectionFace</span><span class="p">(</span><span class="n">Element</span> <span class="n">element</span><span class="p">,</span> <span class="n">XYZ</span> <span class="n">localDir</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">Transform</span> <span class="n">instTransform</span> <span class="p">=</span> <span class="n">Transform</span><span class="p">.</span><span class="n">Identity</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">element</span> <span class="k">is</span> <span class="n">FamilyInstance</span> <span class="n">familyInstance</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="n">instTransform</span> <span class="p">=</span> <span class="n">familyInstance</span><span class="p">.</span><span class="n">GetTransform</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">element</span> <span class="k">is</span> <span class="n">ImportInstance</span> <span class="n">importInstance</span> <span class="p">&amp;&amp;</span> <span class="p">!</span><span class="n">importInstance</span><span class="p">.</span><span class="n">IsLinked</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="n">instTransform</span> <span class="p">=</span> <span class="n">importInstance</span><span class="p">.</span><span class="n">GetTransform</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="n">Transform</span> <span class="n">invTransform</span> <span class="p">=</span> <span class="n">instTransform</span><span class="p">.</span><span class="n">Inverse</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">Face</span> <span class="n">chosenFace</span> <span class="p">=</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="kt">double</span> <span class="n">bestAlignment</span> <span class="p">=</span> <span class="p">-</span><span class="m">999</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="n">Options</span> <span class="n">options</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Options</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">ComputeReferences</span> <span class="p">=</span> <span class="kc">true</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="n">DetailLevel</span> <span class="p">=</span> <span class="n">ViewDetailLevel</span><span class="p">.</span><span class="n">Fine</span>
</span></span><span class="line"><span class="cl">            <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="n">GeometryElement</span> <span class="n">geoElem</span> <span class="p">=</span> <span class="n">element</span><span class="p">.</span><span class="n">get_Geometry</span><span class="p">(</span><span class="n">options</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">geoElem</span> <span class="p">==</span> <span class="kc">null</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="k">void</span> <span class="n">ProcessGeometry</span><span class="p">(</span><span class="n">GeometryObject</span> <span class="n">geo</span><span class="p">,</span> <span class="n">Transform</span> <span class="n">transform</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">geo</span> <span class="k">is</span> <span class="n">Solid</span> <span class="n">solid</span> <span class="p">&amp;&amp;</span> <span class="n">solid</span><span class="p">.</span><span class="n">Volume</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="k">foreach</span> <span class="p">(</span><span class="n">Face</span> <span class="n">face</span> <span class="k">in</span> <span class="n">solid</span><span class="p">.</span><span class="n">Faces</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="p">{</span>
</span></span><span class="line"><span class="cl">                        <span class="n">XYZ</span> <span class="n">faceNormalWorld</span> <span class="p">=</span> <span class="n">face</span><span class="p">.</span><span class="n">ComputeNormal</span><span class="p">(</span><span class="k">new</span> <span class="n">UV</span><span class="p">(</span><span class="m">0.5</span><span class="p">,</span> <span class="m">0.5</span><span class="p">)).</span><span class="n">Normalize</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">                        <span class="n">XYZ</span> <span class="n">faceNormalLocal</span> <span class="p">=</span> <span class="n">invTransform</span><span class="p">.</span><span class="n">OfVector</span><span class="p">(</span><span class="n">faceNormalWorld</span><span class="p">).</span><span class="n">Normalize</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">                        <span class="kt">double</span> <span class="n">alignment</span> <span class="p">=</span> <span class="n">faceNormalLocal</span><span class="p">.</span><span class="n">DotProduct</span><span class="p">(</span><span class="n">localDir</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                        <span class="k">if</span> <span class="p">(</span><span class="n">alignment</span> <span class="p">&gt;</span> <span class="n">bestAlignment</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                        <span class="p">{</span>
</span></span><span class="line"><span class="cl">                            <span class="n">bestAlignment</span> <span class="p">=</span> <span class="n">alignment</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                            <span class="n">chosenFace</span> <span class="p">=</span> <span class="n">face</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                        <span class="p">}</span>
</span></span><span class="line"><span class="cl">                    <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">geo</span> <span class="k">is</span> <span class="n">GeometryInstance</span> <span class="n">instance</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">Transform</span> <span class="n">instanceTransform</span> <span class="p">=</span> <span class="n">instance</span><span class="p">.</span><span class="n">Transform</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                    <span class="n">GeometryElement</span> <span class="n">instGeo</span> <span class="p">=</span> <span class="n">instance</span><span class="p">.</span><span class="n">GetInstanceGeometry</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">                    <span class="k">if</span> <span class="p">(</span><span class="n">instGeo</span> <span class="p">!=</span> <span class="kc">null</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="p">{</span>
</span></span><span class="line"><span class="cl">                        <span class="k">foreach</span> <span class="p">(</span><span class="n">GeometryObject</span> <span class="n">obj</span> <span class="k">in</span> <span class="n">instGeo</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                        <span class="p">{</span>
</span></span><span class="line"><span class="cl">                            <span class="n">ProcessGeometry</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">instanceTransform</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                        <span class="p">}</span>
</span></span><span class="line"><span class="cl">                    <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="k">foreach</span> <span class="p">(</span><span class="n">GeometryObject</span> <span class="n">geo</span> <span class="k">in</span> <span class="n">geoElem</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">ProcessGeometry</span><span class="p">(</span><span class="n">geo</span><span class="p">,</span> <span class="n">Transform</span><span class="p">.</span><span class="n">Identity</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">chosenFace</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// Creates and returns a section view based on the given face and offset.</span>
</span></span><span class="line"><span class="cl">        <span class="kd">private</span> <span class="n">ViewSection</span> <span class="n">CreateSectionView</span><span class="p">(</span><span class="n">Document</span> <span class="n">doc</span><span class="p">,</span> <span class="n">ElementId</span> <span class="n">sectionTypeId</span><span class="p">,</span> <span class="n">Face</span> <span class="n">face</span><span class="p">,</span> <span class="kt">double</span> <span class="n">offsetMm</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">try</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 1. Compute face center in world coords</span>
</span></span><span class="line"><span class="cl">                <span class="n">BoundingBoxUV</span> <span class="n">uvBbox</span> <span class="p">=</span> <span class="n">face</span><span class="p">.</span><span class="n">GetBoundingBox</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">                <span class="kt">double</span> <span class="n">midU</span> <span class="p">=</span> <span class="p">(</span><span class="n">uvBbox</span><span class="p">.</span><span class="n">Min</span><span class="p">.</span><span class="n">U</span> <span class="p">+</span> <span class="n">uvBbox</span><span class="p">.</span><span class="n">Max</span><span class="p">.</span><span class="n">U</span><span class="p">)</span> <span class="p">/</span> <span class="m">2.0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="kt">double</span> <span class="n">midV</span> <span class="p">=</span> <span class="p">(</span><span class="n">uvBbox</span><span class="p">.</span><span class="n">Min</span><span class="p">.</span><span class="n">V</span> <span class="p">+</span> <span class="n">uvBbox</span><span class="p">.</span><span class="n">Max</span><span class="p">.</span><span class="n">V</span><span class="p">)</span> <span class="p">/</span> <span class="m">2.0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">XYZ</span> <span class="n">faceCenter</span> <span class="p">=</span> <span class="n">face</span><span class="p">.</span><span class="n">Evaluate</span><span class="p">(</span><span class="k">new</span> <span class="n">UV</span><span class="p">(</span><span class="n">midU</span><span class="p">,</span> <span class="n">midV</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="c1">// 2. Get the outward normal, then invert it for “inward” view direction</span>
</span></span><span class="line"><span class="cl">                <span class="n">XYZ</span> <span class="n">faceNormalOut</span> <span class="p">=</span> <span class="n">face</span><span class="p">.</span><span class="n">ComputeNormal</span><span class="p">(</span><span class="k">new</span> <span class="n">UV</span><span class="p">(</span><span class="n">midU</span><span class="p">,</span> <span class="n">midV</span><span class="p">)).</span><span class="n">Normalize</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">                <span class="n">XYZ</span> <span class="n">inwardNormal</span> <span class="p">=</span> <span class="n">faceNormalOut</span><span class="p">.</span><span class="n">Multiply</span><span class="p">(-</span><span class="m">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="c1">// 3. Build the section’s coordinate system</span>
</span></span><span class="line"><span class="cl">                <span class="n">Transform</span> <span class="n">transFace</span> <span class="p">=</span> <span class="n">Transform</span><span class="p">.</span><span class="n">Identity</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">transFace</span><span class="p">.</span><span class="n">Origin</span> <span class="p">=</span> <span class="n">faceCenter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">transFace</span><span class="p">.</span><span class="n">BasisZ</span> <span class="p">=</span> <span class="n">inwardNormal</span><span class="p">;</span> <span class="c1">// ← view direction toward element</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="c1">// 4. Choose a reasonable X axis for the section</span>
</span></span><span class="line"><span class="cl">                <span class="n">XYZ</span> <span class="n">basisX</span> <span class="p">=</span> <span class="n">inwardNormal</span><span class="p">.</span><span class="n">CrossProduct</span><span class="p">(</span><span class="n">XYZ</span><span class="p">.</span><span class="n">BasisZ</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">basisX</span><span class="p">.</span><span class="n">IsAlmostEqualTo</span><span class="p">(</span><span class="n">XYZ</span><span class="p">.</span><span class="n">Zero</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                    <span class="n">basisX</span> <span class="p">=</span> <span class="n">inwardNormal</span><span class="p">.</span><span class="n">CrossProduct</span><span class="p">(</span><span class="n">XYZ</span><span class="p">.</span><span class="n">BasisX</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="n">transFace</span><span class="p">.</span><span class="n">BasisX</span> <span class="p">=</span> <span class="n">basisX</span><span class="p">.</span><span class="n">Normalize</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">                <span class="n">transFace</span><span class="p">.</span><span class="n">BasisY</span> <span class="p">=</span> <span class="n">transFace</span><span class="p">.</span><span class="n">BasisZ</span><span class="p">.</span><span class="n">CrossProduct</span><span class="p">(</span><span class="n">transFace</span><span class="p">.</span><span class="n">BasisX</span><span class="p">).</span><span class="n">Normalize</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="c1">// 5. Apply offset *along* the inward normal</span>
</span></span><span class="line"><span class="cl">                <span class="c1">//    Convert mm → ft, then move inward</span>
</span></span><span class="line"><span class="cl">                <span class="kt">double</span> <span class="n">offsetFt</span> <span class="p">=</span> <span class="n">offsetMm</span> <span class="p">/</span> <span class="m">304.8</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">transFace</span><span class="p">.</span><span class="n">Origin</span> <span class="p">=</span> <span class="n">faceCenter</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">inwardNormal</span><span class="p">.</span><span class="n">Multiply</span><span class="p">(</span><span class="n">offsetFt</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="c1">// 6. Define the crop box in this new coordinate system</span>
</span></span><span class="line"><span class="cl">                <span class="n">BoundingBoxXYZ</span> <span class="n">sectionBox</span> <span class="p">=</span> <span class="k">new</span> <span class="n">BoundingBoxXYZ</span>
</span></span><span class="line"><span class="cl">                <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">Transform</span> <span class="p">=</span> <span class="n">transFace</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                    <span class="n">Min</span> <span class="p">=</span> <span class="k">new</span> <span class="n">XYZ</span><span class="p">(-</span><span class="m">2.5</span><span class="p">,</span> <span class="p">-</span><span class="m">50</span><span class="p">,</span> <span class="p">-</span><span class="m">0.1</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">                    <span class="n">Max</span> <span class="p">=</span> <span class="k">new</span> <span class="n">XYZ</span><span class="p">(</span><span class="m">2.5</span><span class="p">,</span> <span class="m">50</span><span class="p">,</span> <span class="m">0.25</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="c1">// 7. Create and return the section</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="n">ViewSection</span><span class="p">.</span><span class="n">CreateSection</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="n">sectionTypeId</span><span class="p">,</span> <span class="n">sectionBox</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">catch</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cp">#endregion</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><hr>
<h3 id="dimensionautomationcs"><code>DimensionAutomation.cs</code><a hidden class="anchor" aria-hidden="true" href="#dimensionautomationcs">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="k">using</span> <span class="nn">Autodesk.Revit.Attributes</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="nn">Autodesk.Revit.DB</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="nn">Autodesk.Revit.UI</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="nn">DimensionAutomation.UI</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">namespace</span> <span class="nn">DimensionAutomation</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="na">    [Transaction(TransactionMode.Manual)]</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="k">class</span> <span class="nc">DimensionAutomation</span> <span class="p">:</span> <span class="n">IExternalCommand</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kd">private</span> <span class="kd">const</span> <span class="kt">double</span> <span class="n">MIN_CURVE_LENGTH</span> <span class="p">=</span> <span class="m">0.001</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kd">private</span> <span class="n">XYZ</span> <span class="n">GetVerticalInView</span><span class="p">(</span><span class="n">XYZ</span> <span class="n">viewDir</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">XYZ</span> <span class="n">upDir</span> <span class="p">=</span> <span class="n">XYZ</span><span class="p">.</span><span class="n">BasisZ</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">XYZ</span> <span class="n">verticalInView</span> <span class="p">=</span> <span class="n">upDir</span> <span class="p">-</span> <span class="n">viewDir</span><span class="p">.</span><span class="n">Multiply</span><span class="p">(</span><span class="n">upDir</span><span class="p">.</span><span class="n">DotProduct</span><span class="p">(</span><span class="n">viewDir</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">verticalInView</span><span class="p">.</span><span class="n">GetLength</span><span class="p">()</span> <span class="p">&lt;</span> <span class="n">MIN_CURVE_LENGTH</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">verticalInView</span><span class="p">.</span><span class="n">Normalize</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kd">public</span> <span class="n">Result</span> <span class="n">Execute</span><span class="p">(</span><span class="n">ExternalCommandData</span> <span class="n">commandData</span><span class="p">,</span> <span class="k">ref</span> <span class="kt">string</span> <span class="n">message</span><span class="p">,</span> <span class="n">ElementSet</span> <span class="n">elements</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">UIApplication</span> <span class="n">uiapp</span> <span class="p">=</span> <span class="n">commandData</span><span class="p">.</span><span class="n">Application</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">UIDocument</span> <span class="n">uidoc</span> <span class="p">=</span> <span class="n">uiapp</span><span class="p">.</span><span class="n">ActiveUIDocument</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">Document</span> <span class="n">doc</span> <span class="p">=</span> <span class="n">uidoc</span><span class="p">.</span><span class="n">Document</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="k">try</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// Show the WPF window to get user choices.</span>
</span></span><span class="line"><span class="cl">                <span class="kt">var</span> <span class="n">window</span> <span class="p">=</span> <span class="k">new</span> <span class="n">DimensionAutomationWindow</span><span class="p">(</span><span class="n">doc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">window</span><span class="p">.</span><span class="n">ShowDialog</span><span class="p">()</span> <span class="p">!=</span> <span class="kc">true</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="k">return</span> <span class="n">Result</span><span class="p">.</span><span class="n">Cancelled</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="c1">// Gather user selections.</span>
</span></span><span class="line"><span class="cl">                <span class="kt">var</span> <span class="n">selectedSections</span> <span class="p">=</span> <span class="n">window</span><span class="p">.</span><span class="n">SelectedSectionViews</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="kt">var</span> <span class="n">selectedFamilyTypes</span> <span class="p">=</span> <span class="n">window</span><span class="p">.</span><span class="n">SelectedFamilyTypes</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="kt">var</span> <span class="n">selectedDimType</span> <span class="p">=</span> <span class="n">window</span><span class="p">.</span><span class="n">SelectedDimensionType</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="kt">double</span> <span class="n">offsetFeet</span> <span class="p">=</span> <span class="n">window</span><span class="p">.</span><span class="n">OffsetValue</span> <span class="p">*</span> <span class="m">3.28084</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="c1">// Basic checks.</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">selectedSections</span> <span class="p">==</span> <span class="kc">null</span> <span class="p">||</span> <span class="p">!</span><span class="n">selectedSections</span><span class="p">.</span><span class="n">Any</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">                <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">TaskDialog</span><span class="p">.</span><span class="n">Show</span><span class="p">(</span><span class="s">&#34;Информация&#34;</span><span class="p">,</span> <span class="s">&#34;Не выбраны виды разрезов. Операция прервана.&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                    <span class="k">return</span> <span class="n">Result</span><span class="p">.</span><span class="n">Cancelled</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">selectedFamilyTypes</span> <span class="p">==</span> <span class="kc">null</span> <span class="p">||</span> <span class="n">selectedFamilyTypes</span><span class="p">.</span><span class="n">Count</span> <span class="p">&lt;</span> <span class="m">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">TaskDialog</span><span class="p">.</span><span class="n">Show</span><span class="p">(</span><span class="s">&#34;Информация&#34;</span><span class="p">,</span> <span class="s">&#34;Пожалуйста, выберите хотя бы один тип семейства.&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                    <span class="k">return</span> <span class="n">Result</span><span class="p">.</span><span class="n">Cancelled</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">selectedDimType</span> <span class="p">==</span> <span class="kc">null</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">TaskDialog</span><span class="p">.</span><span class="n">Show</span><span class="p">(</span><span class="s">&#34;Ошибка&#34;</span><span class="p">,</span> <span class="s">&#34;Тип размерения не выбран.&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                    <span class="k">return</span> <span class="n">Result</span><span class="p">.</span><span class="n">Failed</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="c1">// Process each section view.</span>
</span></span><span class="line"><span class="cl">                <span class="k">foreach</span> <span class="p">(</span><span class="n">ViewSection</span> <span class="n">section</span> <span class="k">in</span> <span class="n">selectedSections</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="kt">var</span> <span class="n">instancesInSection</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="n">section</span><span class="p">.</span><span class="n">Id</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                        <span class="c1">// only elements actually visible in this view</span>
</span></span><span class="line"><span class="cl">                        <span class="p">.</span><span class="n">WherePasses</span><span class="p">(</span><span class="k">new</span> <span class="n">VisibleInViewFilter</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="n">section</span><span class="p">.</span><span class="n">Id</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                        <span class="p">.</span><span class="n">OfClass</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">FamilyInstance</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                        <span class="p">.</span><span class="n">Cast</span><span class="p">&lt;</span><span class="n">FamilyInstance</span><span class="p">&gt;()</span>
</span></span><span class="line"><span class="cl">                        <span class="p">.</span><span class="n">Where</span><span class="p">(</span><span class="n">fi</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl">                            <span class="n">fi</span><span class="p">.</span><span class="n">Symbol</span> <span class="p">!=</span> <span class="kc">null</span> <span class="p">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">                            <span class="n">selectedFamilyTypes</span><span class="p">.</span><span class="n">Any</span><span class="p">(</span><span class="n">fs</span> <span class="p">=&gt;</span> <span class="n">fs</span><span class="p">.</span><span class="n">Id</span> <span class="p">==</span> <span class="n">fi</span><span class="p">.</span><span class="n">Symbol</span><span class="p">.</span><span class="n">Id</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                        <span class="p">)</span>
</span></span><span class="line"><span class="cl">                        <span class="p">.</span><span class="n">ToList</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                    <span class="k">if</span> <span class="p">(</span><span class="n">instancesInSection</span><span class="p">.</span><span class="n">Count</span> <span class="p">&lt;</span> <span class="m">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                        <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                    <span class="n">ProcessSectionView</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="n">section</span><span class="p">,</span> <span class="n">selectedDimType</span><span class="p">,</span> <span class="n">offsetFeet</span><span class="p">,</span> <span class="n">instancesInSection</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="n">Result</span><span class="p">.</span><span class="n">Succeeded</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">ex</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">TaskDialog</span><span class="p">.</span><span class="n">Show</span><span class="p">(</span><span class="s">&#34;Ошибка&#34;</span><span class="p">,</span> <span class="n">ex</span><span class="p">.</span><span class="n">ToString</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="n">Result</span><span class="p">.</span><span class="n">Failed</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kd">private</span> <span class="k">void</span> <span class="n">ProcessSectionView</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">Document</span> <span class="n">doc</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">ViewSection</span> <span class="n">sectionView</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">DimensionType</span> <span class="n">dimType</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="kt">double</span> <span class="n">offsetDist</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">List</span><span class="p">&lt;</span><span class="n">FamilyInstance</span><span class="p">&gt;</span> <span class="n">instances</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">XYZ</span> <span class="n">viewDir</span> <span class="p">=</span> <span class="n">sectionView</span><span class="p">.</span><span class="n">ViewDirection</span><span class="p">.</span><span class="n">Normalize</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="n">XYZ</span> <span class="n">verticalInView</span> <span class="p">=</span> <span class="n">GetVerticalInView</span><span class="p">(</span><span class="n">viewDir</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">verticalInView</span> <span class="p">==</span> <span class="kc">null</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">TaskDialog</span><span class="p">.</span><span class="n">Show</span><span class="p">(</span><span class="s">&#34;Предупреждение&#34;</span><span class="p">,</span> <span class="s">&#34;Не удалось определить вертикальное направление в виде. Пропускаем...&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// Collect bounding-box centers.</span>
</span></span><span class="line"><span class="cl">            <span class="kt">var</span> <span class="n">centerPoints</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">XYZ</span><span class="p">&gt;();</span>
</span></span><span class="line"><span class="cl">            <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">fi</span> <span class="k">in</span> <span class="n">instances</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="kt">var</span> <span class="n">bb</span> <span class="p">=</span> <span class="n">fi</span><span class="p">.</span><span class="n">get_BoundingBox</span><span class="p">(</span><span class="n">sectionView</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">bb</span> <span class="p">!=</span> <span class="kc">null</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="n">centerPoints</span><span class="p">.</span><span class="n">Add</span><span class="p">((</span><span class="n">bb</span><span class="p">.</span><span class="n">Min</span> <span class="p">+</span> <span class="n">bb</span><span class="p">.</span><span class="n">Max</span><span class="p">)</span> <span class="p">*</span> <span class="m">0.5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">centerPoints</span><span class="p">.</span><span class="n">Count</span> <span class="p">&lt;</span> <span class="m">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// Sort by vertical location.</span>
</span></span><span class="line"><span class="cl">            <span class="n">centerPoints</span> <span class="p">=</span> <span class="n">centerPoints</span><span class="p">.</span><span class="n">OrderBy</span><span class="p">(</span><span class="n">p</span> <span class="p">=&gt;</span> <span class="n">p</span><span class="p">.</span><span class="n">DotProduct</span><span class="p">(</span><span class="n">verticalInView</span><span class="p">)).</span><span class="n">ToList</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="kt">var</span> <span class="n">dim3d</span> <span class="p">=</span> <span class="n">centerPoints</span><span class="p">.</span><span class="n">Last</span><span class="p">()</span> <span class="p">-</span> <span class="n">centerPoints</span><span class="p">.</span><span class="n">First</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">dim3d</span><span class="p">.</span><span class="n">GetLength</span><span class="p">()</span> <span class="p">&lt;</span> <span class="n">MIN_CURVE_LENGTH</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// Project onto view plane.</span>
</span></span><span class="line"><span class="cl">            <span class="kt">double</span> <span class="n">dot</span> <span class="p">=</span> <span class="n">dim3d</span><span class="p">.</span><span class="n">DotProduct</span><span class="p">(</span><span class="n">viewDir</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="kt">var</span> <span class="n">dimPlane</span> <span class="p">=</span> <span class="p">(</span><span class="n">dim3d</span> <span class="p">-</span> <span class="n">viewDir</span><span class="p">.</span><span class="n">Multiply</span><span class="p">(</span><span class="n">dot</span><span class="p">)).</span><span class="n">Normalize</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">dimPlane</span><span class="p">.</span><span class="n">GetLength</span><span class="p">()</span> <span class="p">&lt;</span> <span class="n">MIN_CURVE_LENGTH</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// Marker direction perpendicular to dimension direction.</span>
</span></span><span class="line"><span class="cl">            <span class="kt">var</span> <span class="n">refsDir</span> <span class="p">=</span> <span class="n">viewDir</span><span class="p">.</span><span class="n">CrossProduct</span><span class="p">(</span><span class="n">dimPlane</span><span class="p">).</span><span class="n">Normalize</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="k">using</span> <span class="p">(</span><span class="kt">var</span> <span class="n">tx</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Transaction</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="s">&#34;Создание маркеров и размерений&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">tx</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">                <span class="kt">var</span> <span class="n">detailLines</span> <span class="p">=</span> <span class="n">CreateDetailLines</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="n">sectionView</span><span class="p">,</span> <span class="n">centerPoints</span><span class="p">,</span> <span class="n">refsDir</span><span class="p">,</span> <span class="n">viewDir</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="n">doc</span><span class="p">.</span><span class="n">Regenerate</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">                <span class="n">CreateDimensionsBetweenLines</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="n">sectionView</span><span class="p">,</span> <span class="n">detailLines</span><span class="p">,</span> <span class="n">refsDir</span><span class="p">,</span> <span class="n">offsetDist</span><span class="p">,</span> <span class="n">dimType</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="n">tx</span><span class="p">.</span><span class="n">Commit</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kd">private</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">DetailCurve</span><span class="p">&gt;</span> <span class="n">CreateDetailLines</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">Document</span> <span class="n">doc</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">ViewSection</span> <span class="n">view</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">List</span><span class="p">&lt;</span><span class="n">XYZ</span><span class="p">&gt;</span> <span class="n">centers</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">XYZ</span> <span class="n">dir</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">XYZ</span> <span class="n">viewDir</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="kd">const</span> <span class="kt">double</span> <span class="n">markerLen</span> <span class="p">=</span> <span class="m">0.01</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="kt">double</span> <span class="n">half</span> <span class="p">=</span> <span class="n">markerLen</span> <span class="p">*</span> <span class="m">0.5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="kt">var</span> <span class="n">lines</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">DetailCurve</span><span class="p">&gt;();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">cp</span> <span class="k">in</span> <span class="n">centers</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="kt">var</span> <span class="n">p1</span> <span class="p">=</span> <span class="n">cp</span> <span class="p">-</span> <span class="n">dir</span><span class="p">.</span><span class="n">Multiply</span><span class="p">(</span><span class="n">half</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="kt">var</span> <span class="n">p2</span> <span class="p">=</span> <span class="n">cp</span> <span class="p">+</span> <span class="n">dir</span><span class="p">.</span><span class="n">Multiply</span><span class="p">(</span><span class="n">half</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="kt">var</span> <span class="n">plane</span> <span class="p">=</span> <span class="n">Plane</span><span class="p">.</span><span class="n">CreateByNormalAndOrigin</span><span class="p">(</span><span class="n">viewDir</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="n">SketchPlane</span><span class="p">.</span><span class="n">Create</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="n">plane</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="kt">var</span> <span class="n">line</span> <span class="p">=</span> <span class="n">Line</span><span class="p">.</span><span class="n">CreateBound</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="n">lines</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">doc</span><span class="p">.</span><span class="n">Create</span><span class="p">.</span><span class="n">NewDetailCurve</span><span class="p">(</span><span class="n">view</span><span class="p">,</span> <span class="n">line</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">lines</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kd">private</span> <span class="k">void</span> <span class="n">CreateDimensionsBetweenLines</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">Document</span> <span class="n">doc</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">ViewSection</span> <span class="n">view</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">List</span><span class="p">&lt;</span><span class="n">DetailCurve</span><span class="p">&gt;</span> <span class="n">lines</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">XYZ</span> <span class="n">dir</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="kt">double</span> <span class="n">offset</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">DimensionType</span> <span class="n">dimType</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">lines</span><span class="p">.</span><span class="n">Count</span> <span class="p">-</span> <span class="m">1</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="kt">var</span> <span class="n">a</span> <span class="p">=</span> <span class="n">lines</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">GeometryCurve</span><span class="p">.</span><span class="n">Reference</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="kt">var</span> <span class="n">b</span> <span class="p">=</span> <span class="n">lines</span><span class="p">[</span><span class="n">i</span> <span class="p">+</span> <span class="m">1</span><span class="p">].</span><span class="n">GeometryCurve</span><span class="p">.</span><span class="n">Reference</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="kt">var</span> <span class="n">refs</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ReferenceArray</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">                <span class="n">refs</span><span class="p">.</span><span class="n">Append</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="n">refs</span><span class="p">.</span><span class="n">Append</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="kt">var</span> <span class="n">midA</span> <span class="p">=</span> <span class="n">lines</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">GeometryCurve</span><span class="p">.</span><span class="n">Evaluate</span><span class="p">(</span><span class="m">0.5</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="kt">var</span> <span class="n">midB</span> <span class="p">=</span> <span class="n">lines</span><span class="p">[</span><span class="n">i</span> <span class="p">+</span> <span class="m">1</span><span class="p">].</span><span class="n">GeometryCurve</span><span class="p">.</span><span class="n">Evaluate</span><span class="p">(</span><span class="m">0.5</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="kt">var</span> <span class="n">offA</span> <span class="p">=</span> <span class="n">midA</span> <span class="p">+</span> <span class="n">dir</span><span class="p">.</span><span class="n">Multiply</span><span class="p">(</span><span class="n">offset</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="kt">var</span> <span class="n">offB</span> <span class="p">=</span> <span class="n">midB</span> <span class="p">+</span> <span class="n">dir</span><span class="p">.</span><span class="n">Multiply</span><span class="p">(</span><span class="n">offset</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="kt">var</span> <span class="n">dimLine</span> <span class="p">=</span> <span class="n">Line</span><span class="p">.</span><span class="n">CreateBound</span><span class="p">(</span><span class="n">offA</span><span class="p">,</span> <span class="n">offB</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="k">try</span>
</span></span><span class="line"><span class="cl">                <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="kt">var</span> <span class="n">dim</span> <span class="p">=</span> <span class="n">doc</span><span class="p">.</span><span class="n">Create</span><span class="p">.</span><span class="n">NewDimension</span><span class="p">(</span><span class="n">view</span><span class="p">,</span> <span class="n">dimLine</span><span class="p">,</span> <span class="n">refs</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                    <span class="n">dim</span><span class="p">.</span><span class="n">ChangeTypeId</span><span class="p">(</span><span class="n">dimType</span><span class="p">.</span><span class="n">Id</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">ex</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">TaskDialog</span><span class="p">.</span><span class="n">Show</span><span class="p">(</span><span class="s">&#34;Ошибка размерения&#34;</span><span class="p">,</span> <span class="n">ex</span><span class="p">.</span><span class="n">Message</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><hr>
<h3 id="spotdimensionautomationcs"><code>SpotDimensionAutomation.cs</code><a hidden class="anchor" aria-hidden="true" href="#spotdimensionautomationcs">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span><span class="lnt">204
</span><span class="lnt">205
</span><span class="lnt">206
</span><span class="lnt">207
</span><span class="lnt">208
</span><span class="lnt">209
</span><span class="lnt">210
</span><span class="lnt">211
</span><span class="lnt">212
</span><span class="lnt">213
</span><span class="lnt">214
</span><span class="lnt">215
</span><span class="lnt">216
</span><span class="lnt">217
</span><span class="lnt">218
</span><span class="lnt">219
</span><span class="lnt">220
</span><span class="lnt">221
</span><span class="lnt">222
</span><span class="lnt">223
</span><span class="lnt">224
</span><span class="lnt">225
</span><span class="lnt">226
</span><span class="lnt">227
</span><span class="lnt">228
</span><span class="lnt">229
</span><span class="lnt">230
</span><span class="lnt">231
</span><span class="lnt">232
</span><span class="lnt">233
</span><span class="lnt">234
</span><span class="lnt">235
</span><span class="lnt">236
</span><span class="lnt">237
</span><span class="lnt">238
</span><span class="lnt">239
</span><span class="lnt">240
</span><span class="lnt">241
</span><span class="lnt">242
</span><span class="lnt">243
</span><span class="lnt">244
</span><span class="lnt">245
</span><span class="lnt">246
</span><span class="lnt">247
</span><span class="lnt">248
</span><span class="lnt">249
</span><span class="lnt">250
</span><span class="lnt">251
</span><span class="lnt">252
</span><span class="lnt">253
</span><span class="lnt">254
</span><span class="lnt">255
</span><span class="lnt">256
</span><span class="lnt">257
</span><span class="lnt">258
</span><span class="lnt">259
</span><span class="lnt">260
</span><span class="lnt">261
</span><span class="lnt">262
</span><span class="lnt">263
</span><span class="lnt">264
</span><span class="lnt">265
</span><span class="lnt">266
</span><span class="lnt">267
</span><span class="lnt">268
</span><span class="lnt">269
</span><span class="lnt">270
</span><span class="lnt">271
</span><span class="lnt">272
</span><span class="lnt">273
</span><span class="lnt">274
</span><span class="lnt">275
</span><span class="lnt">276
</span><span class="lnt">277
</span><span class="lnt">278
</span><span class="lnt">279
</span><span class="lnt">280
</span><span class="lnt">281
</span><span class="lnt">282
</span><span class="lnt">283
</span><span class="lnt">284
</span><span class="lnt">285
</span><span class="lnt">286
</span><span class="lnt">287
</span><span class="lnt">288
</span><span class="lnt">289
</span><span class="lnt">290
</span><span class="lnt">291
</span><span class="lnt">292
</span><span class="lnt">293
</span><span class="lnt">294
</span><span class="lnt">295
</span><span class="lnt">296
</span><span class="lnt">297
</span><span class="lnt">298
</span><span class="lnt">299
</span><span class="lnt">300
</span><span class="lnt">301
</span><span class="lnt">302
</span><span class="lnt">303
</span><span class="lnt">304
</span><span class="lnt">305
</span><span class="lnt">306
</span><span class="lnt">307
</span><span class="lnt">308
</span><span class="lnt">309
</span><span class="lnt">310
</span><span class="lnt">311
</span><span class="lnt">312
</span><span class="lnt">313
</span><span class="lnt">314
</span><span class="lnt">315
</span><span class="lnt">316
</span><span class="lnt">317
</span><span class="lnt">318
</span><span class="lnt">319
</span><span class="lnt">320
</span><span class="lnt">321
</span><span class="lnt">322
</span><span class="lnt">323
</span><span class="lnt">324
</span><span class="lnt">325
</span><span class="lnt">326
</span><span class="lnt">327
</span><span class="lnt">328
</span><span class="lnt">329
</span><span class="lnt">330
</span><span class="lnt">331
</span><span class="lnt">332
</span><span class="lnt">333
</span><span class="lnt">334
</span><span class="lnt">335
</span><span class="lnt">336
</span><span class="lnt">337
</span><span class="lnt">338
</span><span class="lnt">339
</span><span class="lnt">340
</span><span class="lnt">341
</span><span class="lnt">342
</span><span class="lnt">343
</span><span class="lnt">344
</span><span class="lnt">345
</span><span class="lnt">346
</span><span class="lnt">347
</span><span class="lnt">348
</span><span class="lnt">349
</span><span class="lnt">350
</span><span class="lnt">351
</span><span class="lnt">352
</span><span class="lnt">353
</span><span class="lnt">354
</span><span class="lnt">355
</span><span class="lnt">356
</span><span class="lnt">357
</span><span class="lnt">358
</span><span class="lnt">359
</span><span class="lnt">360
</span><span class="lnt">361
</span><span class="lnt">362
</span><span class="lnt">363
</span><span class="lnt">364
</span><span class="lnt">365
</span><span class="lnt">366
</span><span class="lnt">367
</span><span class="lnt">368
</span><span class="lnt">369
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="k">using</span> <span class="nn">Autodesk.Revit.Attributes</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="nn">Autodesk.Revit.DB</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="nn">Autodesk.Revit.UI</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="nn">Autodesk.Revit.UI.Selection</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">namespace</span> <span class="nn">SpotDimensionTest.Commands</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="na">    [Transaction(TransactionMode.Manual)]</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="k">class</span> <span class="nc">StartupCommand</span> <span class="p">:</span> <span class="n">IExternalCommand</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kd">public</span> <span class="n">Result</span> <span class="n">Execute</span><span class="p">(</span><span class="n">ExternalCommandData</span> <span class="n">commandData</span><span class="p">,</span> <span class="k">ref</span> <span class="kt">string</span> <span class="n">message</span><span class="p">,</span> <span class="n">ElementSet</span> <span class="n">elements</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">UIDocument</span> <span class="n">uiDoc</span> <span class="p">=</span> <span class="n">commandData</span><span class="p">.</span><span class="n">Application</span><span class="p">.</span><span class="n">ActiveUIDocument</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">Document</span> <span class="n">doc</span> <span class="p">=</span> <span class="n">uiDoc</span><span class="p">.</span><span class="n">Document</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// STEP 1: Get preselected section views</span>
</span></span><span class="line"><span class="cl">            <span class="n">ICollection</span><span class="p">&lt;</span><span class="n">ElementId</span><span class="p">&gt;</span> <span class="n">viewSelectionIds</span> <span class="p">=</span> <span class="n">uiDoc</span><span class="p">.</span><span class="n">Selection</span><span class="p">.</span><span class="n">GetElementIds</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="n">List</span><span class="p">&lt;</span><span class="n">View</span><span class="p">&gt;</span> <span class="n">sectionViews</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">View</span><span class="p">&gt;();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="k">foreach</span> <span class="p">(</span><span class="n">ElementId</span> <span class="n">id</span> <span class="k">in</span> <span class="n">viewSelectionIds</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">Element</span> <span class="n">elem</span> <span class="p">=</span> <span class="n">doc</span><span class="p">.</span><span class="n">GetElement</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">elem</span> <span class="k">is</span> <span class="n">View</span> <span class="n">view</span> <span class="p">&amp;&amp;</span> <span class="n">view</span><span class="p">.</span><span class="n">ViewType</span> <span class="p">==</span> <span class="n">ViewType</span><span class="p">.</span><span class="n">Section</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">sectionViews</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">view</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">sectionViews</span><span class="p">.</span><span class="n">Count</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">TaskDialog</span><span class="p">.</span><span class="n">Show</span><span class="p">(</span><span class="s">&#34;Info&#34;</span><span class="p">,</span> <span class="s">&#34;Please preselect section views first.&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="n">Result</span><span class="p">.</span><span class="n">Succeeded</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// STEP 2: User selects family instances</span>
</span></span><span class="line"><span class="cl">            <span class="n">TaskDialog</span><span class="p">.</span><span class="n">Show</span><span class="p">(</span><span class="s">&#34;Selection&#34;</span><span class="p">,</span> <span class="s">&#34;Now select family instances for spot elevations.&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">IList</span><span class="p">&lt;</span><span class="n">Reference</span><span class="p">&gt;</span> <span class="n">familyRefs</span> <span class="p">=</span> <span class="n">uiDoc</span><span class="p">.</span><span class="n">Selection</span><span class="p">.</span><span class="n">PickObjects</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">                <span class="n">ObjectType</span><span class="p">.</span><span class="n">Element</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="s">&#34;Select family instances for spot elevations&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="n">List</span><span class="p">&lt;</span><span class="n">FamilyInstance</span><span class="p">&gt;</span> <span class="n">familyInstances</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">FamilyInstance</span><span class="p">&gt;();</span>
</span></span><span class="line"><span class="cl">            <span class="k">foreach</span> <span class="p">(</span><span class="n">Reference</span> <span class="n">famRef</span> <span class="k">in</span> <span class="n">familyRefs</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">Element</span> <span class="n">elem</span> <span class="p">=</span> <span class="n">doc</span><span class="p">.</span><span class="n">GetElement</span><span class="p">(</span><span class="n">famRef</span><span class="p">.</span><span class="n">ElementId</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">elem</span> <span class="k">is</span> <span class="n">FamilyInstance</span> <span class="n">fi</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">familyInstances</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">fi</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">familyInstances</span><span class="p">.</span><span class="n">Count</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">TaskDialog</span><span class="p">.</span><span class="n">Show</span><span class="p">(</span><span class="s">&#34;Info&#34;</span><span class="p">,</span> <span class="s">&#34;No family instances selected.&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="n">Result</span><span class="p">.</span><span class="n">Succeeded</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// STEP 3: User picks a face on one of the family instances</span>
</span></span><span class="line"><span class="cl">            <span class="n">Reference</span> <span class="n">pickedFaceRef</span> <span class="p">=</span> <span class="n">uiDoc</span><span class="p">.</span><span class="n">Selection</span><span class="p">.</span><span class="n">PickObject</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">                <span class="n">ObjectType</span><span class="p">.</span><span class="n">Face</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="s">&#34;Select a face for the spot elevation&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="n">Element</span> <span class="n">templateElem</span> <span class="p">=</span> <span class="n">doc</span><span class="p">.</span><span class="n">GetElement</span><span class="p">(</span><span class="n">pickedFaceRef</span><span class="p">.</span><span class="n">ElementId</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">GeometryObject</span> <span class="n">geoObj</span> <span class="p">=</span> <span class="n">templateElem</span><span class="p">.</span><span class="n">GetGeometryObjectFromReference</span><span class="p">(</span><span class="n">pickedFaceRef</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">Face</span> <span class="n">templateFace</span> <span class="p">=</span> <span class="n">geoObj</span> <span class="k">as</span> <span class="n">Face</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">XYZ</span> <span class="n">pickedPoint</span> <span class="p">=</span> <span class="n">pickedFaceRef</span><span class="p">.</span><span class="n">GlobalPoint</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">XYZ</span> <span class="n">templatePoint</span> <span class="p">=</span> <span class="n">CalculatePointOnFace</span><span class="p">(</span><span class="n">templateElem</span><span class="p">,</span> <span class="n">templateFace</span><span class="p">,</span> <span class="n">pickedPoint</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// STEP 4: Create spot elevations on all family instances in all section views</span>
</span></span><span class="line"><span class="cl">            <span class="k">using</span> <span class="p">(</span><span class="n">TransactionGroup</span> <span class="n">tg</span> <span class="p">=</span> <span class="k">new</span> <span class="n">TransactionGroup</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="s">&#34;Create Multiple Spot Elevations&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">tg</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="kt">int</span> <span class="n">successCount</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="k">foreach</span> <span class="p">(</span><span class="n">View</span> <span class="n">sectionView</span> <span class="k">in</span> <span class="n">sectionViews</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="k">using</span> <span class="p">(</span><span class="n">Transaction</span> <span class="n">trans</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Transaction</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="s">$&#34;Spot Elevations in {sectionView.Name}&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                    <span class="p">{</span>
</span></span><span class="line"><span class="cl">                        <span class="n">trans</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                        <span class="n">XYZ</span> <span class="n">viewDir</span> <span class="p">=</span> <span class="n">sectionView</span><span class="p">.</span><span class="n">ViewDirection</span><span class="p">.</span><span class="n">Normalize</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">                        <span class="n">XYZ</span> <span class="n">viewUp</span> <span class="p">=</span> <span class="n">sectionView</span><span class="p">.</span><span class="n">UpDirection</span><span class="p">.</span><span class="n">Normalize</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">                        <span class="n">XYZ</span> <span class="n">viewRight</span> <span class="p">=</span> <span class="n">viewUp</span><span class="p">.</span><span class="n">CrossProduct</span><span class="p">(</span><span class="n">viewDir</span><span class="p">).</span><span class="n">Normalize</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                        <span class="n">XYZ</span> <span class="n">originalPickedPoint</span> <span class="p">=</span> <span class="n">pickedPoint</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                        <span class="kt">bool</span> <span class="n">viewHasSpotElevation</span> <span class="p">=</span> <span class="kc">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                        <span class="k">foreach</span> <span class="p">(</span><span class="n">FamilyInstance</span> <span class="n">fi</span> <span class="k">in</span> <span class="n">familyInstances</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                        <span class="p">{</span>
</span></span><span class="line"><span class="cl">                            <span class="k">if</span> <span class="p">(</span><span class="n">viewHasSpotElevation</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                                <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                            <span class="k">try</span>
</span></span><span class="line"><span class="cl">                            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                                <span class="n">Options</span> <span class="n">options</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Options</span>
</span></span><span class="line"><span class="cl">                                <span class="p">{</span>
</span></span><span class="line"><span class="cl">                                    <span class="n">View</span> <span class="p">=</span> <span class="n">sectionView</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                    <span class="n">ComputeReferences</span> <span class="p">=</span> <span class="kc">true</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                    <span class="n">IncludeNonVisibleObjects</span> <span class="p">=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">                                <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                                <span class="n">GeometryElement</span> <span class="n">geometry</span> <span class="p">=</span> <span class="n">fi</span><span class="p">.</span><span class="n">get_Geometry</span><span class="p">(</span><span class="n">options</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                                <span class="k">if</span> <span class="p">(</span><span class="n">geometry</span> <span class="p">==</span> <span class="kc">null</span> <span class="p">||</span> <span class="p">!</span><span class="n">geometry</span><span class="p">.</span><span class="n">Any</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">                                    <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                                <span class="n">List</span><span class="p">&lt;</span><span class="n">Face</span><span class="p">&gt;</span> <span class="n">faces</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Face</span><span class="p">&gt;();</span>
</span></span><span class="line"><span class="cl">                                <span class="k">foreach</span> <span class="p">(</span><span class="n">GeometryObject</span> <span class="n">geomObj</span> <span class="k">in</span> <span class="n">geometry</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                                <span class="p">{</span>
</span></span><span class="line"><span class="cl">                                    <span class="n">ExtractFacesFromGeometry</span><span class="p">(</span><span class="n">geomObj</span><span class="p">,</span> <span class="n">faces</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                                <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                                <span class="n">List</span><span class="p">&lt;</span><span class="n">Face</span><span class="p">&gt;</span> <span class="n">sortedFaces</span> <span class="p">=</span> <span class="n">SortFacesByPriority</span><span class="p">(</span><span class="n">faces</span><span class="p">,</span> <span class="n">viewDir</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                                <span class="k">foreach</span> <span class="p">(</span><span class="n">Face</span> <span class="n">face</span> <span class="k">in</span> <span class="n">sortedFaces</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                                <span class="p">{</span>
</span></span><span class="line"><span class="cl">                                    <span class="k">try</span>
</span></span><span class="line"><span class="cl">                                    <span class="p">{</span>
</span></span><span class="line"><span class="cl">                                        <span class="n">IList</span><span class="p">&lt;</span><span class="n">CurveLoop</span><span class="p">&gt;</span> <span class="n">edgeLoops</span> <span class="p">=</span> <span class="n">face</span><span class="p">.</span><span class="n">GetEdgesAsCurveLoops</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">                                        <span class="k">if</span> <span class="p">(</span><span class="n">edgeLoops</span> <span class="p">==</span> <span class="kc">null</span> <span class="p">||</span> <span class="n">edgeLoops</span><span class="p">.</span><span class="n">Count</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                                            <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                                        <span class="n">XYZ</span> <span class="n">elevationPoint</span> <span class="p">=</span> <span class="n">CalculatePointOnFace</span><span class="p">(</span><span class="n">fi</span><span class="p">,</span> <span class="n">face</span><span class="p">,</span> <span class="n">originalPickedPoint</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                                        <span class="k">try</span>
</span></span><span class="line"><span class="cl">                                        <span class="p">{</span>
</span></span><span class="line"><span class="cl">                                            <span class="n">XYZ</span> <span class="n">lineStart</span> <span class="p">=</span> <span class="n">elevationPoint</span> <span class="p">-</span> <span class="n">viewRight</span> <span class="p">*</span> <span class="m">0.1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                                            <span class="n">XYZ</span> <span class="n">lineEnd</span> <span class="p">=</span> <span class="n">elevationPoint</span> <span class="p">+</span> <span class="n">viewRight</span> <span class="p">*</span> <span class="m">0.1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                                            <span class="n">DetailLine</span><span class="p">?</span> <span class="n">detailLine</span> <span class="p">=</span> <span class="n">doc</span><span class="p">.</span><span class="n">Create</span><span class="p">.</span><span class="n">NewDetailCurve</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">                                                <span class="n">sectionView</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                                <span class="n">Line</span><span class="p">.</span><span class="n">CreateBound</span><span class="p">(</span><span class="n">lineStart</span><span class="p">,</span> <span class="n">lineEnd</span><span class="p">))</span> <span class="k">as</span> <span class="n">DetailLine</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                                            <span class="k">if</span> <span class="p">(</span><span class="n">detailLine</span> <span class="p">!=</span> <span class="kc">null</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                                            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                                                <span class="n">XYZ</span> <span class="n">bendPoint</span> <span class="p">=</span> <span class="n">elevationPoint</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                                                <span class="n">XYZ</span> <span class="n">endPoint</span> <span class="p">=</span> <span class="n">elevationPoint</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                                                <span class="n">Reference</span> <span class="n">lineRef</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Reference</span><span class="p">(</span><span class="n">detailLine</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                                                <span class="k">try</span>
</span></span><span class="line"><span class="cl">                                                <span class="p">{</span>
</span></span><span class="line"><span class="cl">                                                    <span class="n">SpotDimension</span> <span class="n">spotDimension</span> <span class="p">=</span> <span class="n">doc</span><span class="p">.</span><span class="n">Create</span><span class="p">.</span><span class="n">NewSpotElevation</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">                                                        <span class="n">sectionView</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                                        <span class="n">lineRef</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                                        <span class="n">elevationPoint</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                                        <span class="n">bendPoint</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                                        <span class="n">endPoint</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                                        <span class="n">elevationPoint</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                                        <span class="kc">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                                                    <span class="k">if</span> <span class="p">(</span><span class="n">spotDimension</span> <span class="p">!=</span> <span class="kc">null</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                                                    <span class="p">{</span>
</span></span><span class="line"><span class="cl">                                                        <span class="n">successCount</span><span class="p">++;</span>
</span></span><span class="line"><span class="cl">                                                        <span class="n">viewHasSpotElevation</span> <span class="p">=</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                                                        <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                                                    <span class="p">}</span>
</span></span><span class="line"><span class="cl">                                                    <span class="k">else</span>
</span></span><span class="line"><span class="cl">                                                    <span class="p">{</span>
</span></span><span class="line"><span class="cl">                                                        <span class="n">doc</span><span class="p">.</span><span class="n">Delete</span><span class="p">(</span><span class="n">detailLine</span><span class="p">.</span><span class="n">Id</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                                                    <span class="p">}</span>
</span></span><span class="line"><span class="cl">                                                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                                                <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                                                <span class="p">{</span>
</span></span><span class="line"><span class="cl">                                                    <span class="n">doc</span><span class="p">.</span><span class="n">Delete</span><span class="p">(</span><span class="n">detailLine</span><span class="p">.</span><span class="n">Id</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                                                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                                            <span class="p">}</span>
</span></span><span class="line"><span class="cl">                                        <span class="p">}</span>
</span></span><span class="line"><span class="cl">                                        <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                                        <span class="p">{</span>
</span></span><span class="line"><span class="cl">                                            <span class="c1">// Continue to next face</span>
</span></span><span class="line"><span class="cl">                                        <span class="p">}</span>
</span></span><span class="line"><span class="cl">                                    <span class="p">}</span>
</span></span><span class="line"><span class="cl">                                    <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                                    <span class="p">{</span>
</span></span><span class="line"><span class="cl">                                        <span class="c1">// Continue to next face</span>
</span></span><span class="line"><span class="cl">                                    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                                    <span class="k">if</span> <span class="p">(</span><span class="n">viewHasSpotElevation</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                                        <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                            <span class="p">}</span>
</span></span><span class="line"><span class="cl">                            <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                                <span class="c1">// Continue to next family instance</span>
</span></span><span class="line"><span class="cl">                            <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                            <span class="k">if</span> <span class="p">(</span><span class="n">viewHasSpotElevation</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                                <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                        <span class="n">trans</span><span class="p">.</span><span class="n">Commit</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">                    <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="n">tg</span><span class="p">.</span><span class="n">Assimilate</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="n">TaskDialog</span> <span class="n">resultsDialog</span> <span class="p">=</span> <span class="k">new</span> <span class="n">TaskDialog</span><span class="p">(</span><span class="s">&#34;Spot Elevation Results&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="n">resultsDialog</span><span class="p">.</span><span class="n">MainInstruction</span> <span class="p">=</span> <span class="s">$&#34;Created {successCount} spot elevations&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">resultsDialog</span><span class="p">.</span><span class="n">MainContent</span> <span class="p">=</span> <span class="s">$&#34;Successfully created {successCount} spot elevations across {sectionViews.Count} section views.&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">resultsDialog</span><span class="p">.</span><span class="n">Show</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">Result</span><span class="p">.</span><span class="n">Succeeded</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kd">private</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Face</span><span class="p">&gt;</span> <span class="n">SortFacesByPriority</span><span class="p">(</span><span class="n">List</span><span class="p">&lt;</span><span class="n">Face</span><span class="p">&gt;</span> <span class="n">faces</span><span class="p">,</span> <span class="n">XYZ</span> <span class="n">viewDir</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">List</span><span class="p">&lt;</span><span class="n">Tuple</span><span class="p">&lt;</span><span class="n">Face</span><span class="p">,</span> <span class="kt">double</span><span class="p">&gt;&gt;</span> <span class="n">facesWithScores</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Tuple</span><span class="p">&lt;</span><span class="n">Face</span><span class="p">,</span> <span class="kt">double</span><span class="p">&gt;&gt;();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="k">foreach</span> <span class="p">(</span><span class="n">Face</span> <span class="n">face</span> <span class="k">in</span> <span class="n">faces</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">try</span>
</span></span><span class="line"><span class="cl">                <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">BoundingBoxUV</span> <span class="n">bb</span> <span class="p">=</span> <span class="n">face</span><span class="p">.</span><span class="n">GetBoundingBox</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">                    <span class="n">UV</span> <span class="n">centerUV</span> <span class="p">=</span> <span class="k">new</span> <span class="n">UV</span><span class="p">((</span><span class="n">bb</span><span class="p">.</span><span class="n">Min</span><span class="p">.</span><span class="n">U</span> <span class="p">+</span> <span class="n">bb</span><span class="p">.</span><span class="n">Max</span><span class="p">.</span><span class="n">U</span><span class="p">)</span> <span class="p">*</span> <span class="m">0.5</span><span class="p">,</span> <span class="p">(</span><span class="n">bb</span><span class="p">.</span><span class="n">Min</span><span class="p">.</span><span class="n">V</span> <span class="p">+</span> <span class="n">bb</span><span class="p">.</span><span class="n">Max</span><span class="p">.</span><span class="n">V</span><span class="p">)</span> <span class="p">*</span> <span class="m">0.5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                    <span class="n">XYZ</span> <span class="n">normal</span> <span class="p">=</span> <span class="n">face</span><span class="p">.</span><span class="n">ComputeNormal</span><span class="p">(</span><span class="n">centerUV</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                    <span class="kt">double</span> <span class="n">dotProduct</span> <span class="p">=</span> <span class="n">Math</span><span class="p">.</span><span class="n">Abs</span><span class="p">(</span><span class="n">normal</span><span class="p">.</span><span class="n">DotProduct</span><span class="p">(</span><span class="n">viewDir</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">                    <span class="kt">double</span> <span class="n">score</span> <span class="p">=</span> <span class="n">dotProduct</span> <span class="p">&lt;</span> <span class="m">0.3</span> <span class="p">?</span> <span class="m">1.0</span> <span class="p">:</span> <span class="p">(</span><span class="n">dotProduct</span> <span class="p">&gt;</span> <span class="m">0.7</span> <span class="p">?</span> <span class="m">2.0</span> <span class="p">:</span> <span class="m">3.0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                    <span class="n">facesWithScores</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">Tuple</span><span class="p">.</span><span class="n">Create</span><span class="p">(</span><span class="n">face</span><span class="p">,</span> <span class="n">score</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="k">catch</span>
</span></span><span class="line"><span class="cl">                <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">facesWithScores</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">Tuple</span><span class="p">.</span><span class="n">Create</span><span class="p">(</span><span class="n">face</span><span class="p">,</span> <span class="m">10.0</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">facesWithScores</span>
</span></span><span class="line"><span class="cl">                <span class="p">.</span><span class="n">OrderBy</span><span class="p">(</span><span class="n">tuple</span> <span class="p">=&gt;</span> <span class="n">tuple</span><span class="p">.</span><span class="n">Item2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">.</span><span class="n">Select</span><span class="p">(</span><span class="n">tuple</span> <span class="p">=&gt;</span> <span class="n">tuple</span><span class="p">.</span><span class="n">Item1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">.</span><span class="n">ToList</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kd">private</span> <span class="k">void</span> <span class="n">ExtractFacesFromGeometry</span><span class="p">(</span><span class="n">GeometryObject</span> <span class="n">geomObj</span><span class="p">,</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Face</span><span class="p">&gt;</span> <span class="n">faces</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">geomObj</span> <span class="k">is</span> <span class="n">GeometryInstance</span> <span class="n">geomInstance</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">GeometryElement</span> <span class="n">symbolGeometry</span> <span class="p">=</span> <span class="n">geomInstance</span><span class="p">.</span><span class="n">GetSymbolGeometry</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">                <span class="n">Transform</span> <span class="n">instanceTransform</span> <span class="p">=</span> <span class="n">geomInstance</span><span class="p">.</span><span class="n">Transform</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">symbolGeometry</span> <span class="p">!=</span> <span class="kc">null</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">ExtractSolidsFromGeometry</span><span class="p">(</span><span class="n">symbolGeometry</span><span class="p">,</span> <span class="n">instanceTransform</span><span class="p">,</span> <span class="n">faces</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(!(</span><span class="n">geomObj</span> <span class="k">is</span> <span class="n">Solid</span> <span class="n">solid</span><span class="p">)</span> <span class="p">||</span> <span class="n">solid</span><span class="p">.</span><span class="n">Faces</span><span class="p">.</span><span class="n">Size</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">solid</span><span class="p">.</span><span class="n">Faces</span><span class="p">.</span><span class="n">Size</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">Face</span> <span class="n">face</span> <span class="p">=</span> <span class="n">solid</span><span class="p">.</span><span class="n">Faces</span><span class="p">.</span><span class="n">get_Item</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">face</span> <span class="p">!=</span> <span class="kc">null</span> <span class="p">&amp;&amp;</span> <span class="n">face</span><span class="p">.</span><span class="n">Reference</span> <span class="p">!=</span> <span class="kc">null</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">faces</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">face</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kd">private</span> <span class="k">void</span> <span class="n">ExtractSolidsFromGeometry</span><span class="p">(</span><span class="n">GeometryElement</span> <span class="n">geometry</span><span class="p">,</span> <span class="n">Transform</span> <span class="n">transform</span><span class="p">,</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Face</span><span class="p">&gt;</span> <span class="n">faces</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">foreach</span> <span class="p">(</span><span class="n">GeometryObject</span> <span class="n">obj</span> <span class="k">in</span> <span class="n">geometry</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">obj</span> <span class="k">is</span> <span class="n">GeometryInstance</span> <span class="n">nestedInstance</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">GeometryElement</span> <span class="n">nestedGeometry</span> <span class="p">=</span> <span class="n">nestedInstance</span><span class="p">.</span><span class="n">GetSymbolGeometry</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">                    <span class="n">Transform</span> <span class="n">combinedTransform</span> <span class="p">=</span> <span class="n">transform</span><span class="p">.</span><span class="n">Multiply</span><span class="p">(</span><span class="n">nestedInstance</span><span class="p">.</span><span class="n">Transform</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                    <span class="k">if</span> <span class="p">(</span><span class="n">nestedGeometry</span> <span class="p">!=</span> <span class="kc">null</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="p">{</span>
</span></span><span class="line"><span class="cl">                        <span class="n">ExtractSolidsFromGeometry</span><span class="p">(</span><span class="n">nestedGeometry</span><span class="p">,</span> <span class="n">combinedTransform</span><span class="p">,</span> <span class="n">faces</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                    <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">obj</span> <span class="k">is</span> <span class="n">Solid</span> <span class="n">solid</span> <span class="p">&amp;&amp;</span> <span class="n">solid</span><span class="p">.</span><span class="n">Faces</span><span class="p">.</span><span class="n">Size</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">solid</span><span class="p">.</span><span class="n">Faces</span><span class="p">.</span><span class="n">Size</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
</span></span><span class="line"><span class="cl">                    <span class="p">{</span>
</span></span><span class="line"><span class="cl">                        <span class="n">Face</span> <span class="n">face</span> <span class="p">=</span> <span class="n">solid</span><span class="p">.</span><span class="n">Faces</span><span class="p">.</span><span class="n">get_Item</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                        <span class="k">if</span> <span class="p">(</span><span class="n">face</span> <span class="p">!=</span> <span class="kc">null</span> <span class="p">&amp;&amp;</span> <span class="n">face</span><span class="p">.</span><span class="n">Reference</span> <span class="p">!=</span> <span class="kc">null</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                        <span class="p">{</span>
</span></span><span class="line"><span class="cl">                            <span class="n">faces</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">face</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                        <span class="p">}</span>
</span></span><span class="line"><span class="cl">                    <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kd">private</span> <span class="n">XYZ</span> <span class="n">CalculatePointOnFace</span><span class="p">(</span><span class="n">Element</span> <span class="n">elem</span><span class="p">,</span> <span class="n">Face</span> <span class="n">face</span><span class="p">,</span> <span class="n">XYZ</span> <span class="n">pickedPoint</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">face</span> <span class="p">==</span> <span class="kc">null</span> <span class="p">||</span> <span class="n">pickedPoint</span> <span class="p">==</span> <span class="kc">null</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="n">pickedPoint</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="n">BoundingBoxUV</span> <span class="n">faceBB</span> <span class="p">=</span> <span class="n">face</span><span class="p">.</span><span class="n">GetBoundingBox</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="n">IntersectionResult</span> <span class="n">projResult</span> <span class="p">=</span> <span class="n">face</span><span class="p">.</span><span class="n">Project</span><span class="p">(</span><span class="n">pickedPoint</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">projResult</span> <span class="p">==</span> <span class="kc">null</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="n">pickedPoint</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="n">UV</span> <span class="n">pickedUV</span> <span class="p">=</span> <span class="n">projResult</span><span class="p">.</span><span class="n">UVPoint</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">FamilyInstance</span> <span class="n">fi</span> <span class="p">=</span> <span class="n">elem</span> <span class="k">as</span> <span class="n">FamilyInstance</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">fi</span> <span class="p">!=</span> <span class="kc">null</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">Transform</span> <span class="n">transform</span> <span class="p">=</span> <span class="n">fi</span><span class="p">.</span><span class="n">GetTransform</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">                <span class="n">Transform</span> <span class="n">inverseTransform</span> <span class="p">=</span> <span class="n">transform</span><span class="p">.</span><span class="n">Inverse</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">XYZ</span> <span class="n">localPoint</span> <span class="p">=</span> <span class="n">inverseTransform</span><span class="p">.</span><span class="n">OfPoint</span><span class="p">(</span><span class="n">pickedPoint</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="n">XYZ</span> <span class="n">faceNormal</span> <span class="p">=</span> <span class="n">face</span><span class="p">.</span><span class="n">ComputeNormal</span><span class="p">(</span><span class="n">pickedUV</span><span class="p">).</span><span class="n">Normalize</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">                <span class="n">XYZ</span> <span class="n">localNormal</span> <span class="p">=</span> <span class="n">inverseTransform</span><span class="p">.</span><span class="n">OfVector</span><span class="p">(</span><span class="n">faceNormal</span><span class="p">).</span><span class="n">Normalize</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">Math</span><span class="p">.</span><span class="n">Abs</span><span class="p">(</span><span class="n">localNormal</span><span class="p">.</span><span class="n">Z</span><span class="p">)</span> <span class="p">&lt;</span> <span class="m">0.3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">BoundingBoxXYZ</span> <span class="n">bbox</span> <span class="p">=</span> <span class="n">fi</span><span class="p">.</span><span class="n">get_BoundingBox</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                    <span class="k">if</span> <span class="p">(</span><span class="n">bbox</span> <span class="p">!=</span> <span class="kc">null</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="p">{</span>
</span></span><span class="line"><span class="cl">                        <span class="kt">double</span> <span class="n">zPos</span> <span class="p">=</span> <span class="p">(</span><span class="n">bbox</span><span class="p">.</span><span class="n">Min</span><span class="p">.</span><span class="n">Z</span> <span class="p">+</span> <span class="n">bbox</span><span class="p">.</span><span class="n">Max</span><span class="p">.</span><span class="n">Z</span><span class="p">)</span> <span class="p">*</span> <span class="m">0.5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                        <span class="n">XYZ</span> <span class="n">localResult</span> <span class="p">=</span> <span class="k">new</span> <span class="n">XYZ</span><span class="p">(</span><span class="n">localPoint</span><span class="p">.</span><span class="n">X</span><span class="p">,</span> <span class="n">localPoint</span><span class="p">.</span><span class="n">Y</span><span class="p">,</span> <span class="n">zPos</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                        <span class="n">XYZ</span> <span class="n">globalResult</span> <span class="p">=</span> <span class="n">transform</span><span class="p">.</span><span class="n">OfPoint</span><span class="p">(</span><span class="n">localResult</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                        <span class="n">projResult</span> <span class="p">=</span> <span class="n">face</span><span class="p">.</span><span class="n">Project</span><span class="p">(</span><span class="n">globalResult</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                        <span class="k">if</span> <span class="p">(</span><span class="n">projResult</span> <span class="p">!=</span> <span class="kc">null</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                        <span class="p">{</span>
</span></span><span class="line"><span class="cl">                            <span class="k">return</span> <span class="n">face</span><span class="p">.</span><span class="n">Evaluate</span><span class="p">(</span><span class="n">projResult</span><span class="p">.</span><span class="n">UVPoint</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                        <span class="p">}</span>
</span></span><span class="line"><span class="cl">                    <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="n">UV</span> <span class="n">adjustedUV</span> <span class="p">=</span> <span class="k">new</span> <span class="n">UV</span><span class="p">(</span><span class="n">pickedUV</span><span class="p">.</span><span class="n">U</span><span class="p">,</span> <span class="p">(</span><span class="n">faceBB</span><span class="p">.</span><span class="n">Min</span><span class="p">.</span><span class="n">V</span> <span class="p">+</span> <span class="n">faceBB</span><span class="p">.</span><span class="n">Max</span><span class="p">.</span><span class="n">V</span><span class="p">)</span> <span class="p">*</span> <span class="m">0.5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">face</span><span class="p">.</span><span class="n">Evaluate</span><span class="p">(</span><span class="n">adjustedUV</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kd">private</span> <span class="n">XYZ</span> <span class="n">CalculateCurveLoopCentroid</span><span class="p">(</span><span class="n">CurveLoop</span> <span class="n">curveLoop</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">curveLoop</span> <span class="p">==</span> <span class="kc">null</span> <span class="p">||</span> <span class="n">curveLoop</span><span class="p">.</span><span class="n">Count</span><span class="p">()</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="n">XYZ</span><span class="p">.</span><span class="n">Zero</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="n">XYZ</span> <span class="n">sum</span> <span class="p">=</span> <span class="n">XYZ</span><span class="p">.</span><span class="n">Zero</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int</span> <span class="n">pointCount</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">HashSet</span><span class="p">&lt;</span><span class="n">XYZ</span><span class="p">&gt;</span> <span class="n">uniquePoints</span> <span class="p">=</span> <span class="k">new</span> <span class="n">HashSet</span><span class="p">&lt;</span><span class="n">XYZ</span><span class="p">&gt;(</span><span class="k">new</span> <span class="n">XYZEqualityComparer</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">            <span class="k">foreach</span> <span class="p">(</span><span class="n">Curve</span> <span class="n">curve</span> <span class="k">in</span> <span class="n">curveLoop</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">uniquePoints</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">curve</span><span class="p">.</span><span class="n">GetEndPoint</span><span class="p">(</span><span class="m">0</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">                <span class="n">uniquePoints</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">curve</span><span class="p">.</span><span class="n">GetEndPoint</span><span class="p">(</span><span class="m">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">foreach</span> <span class="p">(</span><span class="n">XYZ</span> <span class="n">point</span> <span class="k">in</span> <span class="n">uniquePoints</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">sum</span> <span class="p">+=</span> <span class="n">point</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">pointCount</span><span class="p">++;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">pointCount</span> <span class="p">&gt;</span> <span class="m">0</span> <span class="p">?</span> <span class="n">sum</span><span class="p">.</span><span class="n">Divide</span><span class="p">(</span><span class="n">pointCount</span><span class="p">)</span> <span class="p">:</span> <span class="n">XYZ</span><span class="p">.</span><span class="n">Zero</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kd">private</span> <span class="k">class</span> <span class="nc">XYZEqualityComparer</span> <span class="p">:</span> <span class="n">IEqualityComparer</span><span class="p">&lt;</span><span class="n">XYZ</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="kd">private</span> <span class="kd">const</span> <span class="kt">double</span> <span class="n">Tolerance</span> <span class="p">=</span> <span class="m">0.0001</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="kd">public</span> <span class="kt">bool</span> <span class="n">Equals</span><span class="p">(</span><span class="n">XYZ</span> <span class="n">x</span><span class="p">,</span> <span class="n">XYZ</span> <span class="n">y</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="p">==</span> <span class="kc">null</span> <span class="p">&amp;&amp;</span> <span class="n">y</span> <span class="p">==</span> <span class="kc">null</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="p">==</span> <span class="kc">null</span> <span class="p">||</span> <span class="n">y</span> <span class="p">==</span> <span class="kc">null</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="n">Math</span><span class="p">.</span><span class="n">Abs</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">X</span> <span class="p">-</span> <span class="n">y</span><span class="p">.</span><span class="n">X</span><span class="p">)</span> <span class="p">&lt;</span> <span class="n">Tolerance</span> <span class="p">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">                       <span class="n">Math</span><span class="p">.</span><span class="n">Abs</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">Y</span> <span class="p">-</span> <span class="n">y</span><span class="p">.</span><span class="n">Y</span><span class="p">)</span> <span class="p">&lt;</span> <span class="n">Tolerance</span> <span class="p">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">                       <span class="n">Math</span><span class="p">.</span><span class="n">Abs</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">Z</span> <span class="p">-</span> <span class="n">y</span><span class="p">.</span><span class="n">Z</span><span class="p">)</span> <span class="p">&lt;</span> <span class="n">Tolerance</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="kd">public</span> <span class="kt">int</span> <span class="n">GetHashCode</span><span class="p">(</span><span class="n">XYZ</span> <span class="n">obj</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">obj</span> <span class="p">==</span> <span class="kc">null</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="k">return</span> <span class="m">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="kt">double</span> <span class="n">x</span> <span class="p">=</span> <span class="n">Math</span><span class="p">.</span><span class="n">Round</span><span class="p">(</span><span class="n">obj</span><span class="p">.</span><span class="n">X</span> <span class="p">/</span> <span class="n">Tolerance</span><span class="p">)</span> <span class="p">*</span> <span class="n">Tolerance</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="kt">double</span> <span class="n">y</span> <span class="p">=</span> <span class="n">Math</span><span class="p">.</span><span class="n">Round</span><span class="p">(</span><span class="n">obj</span><span class="p">.</span><span class="n">Y</span> <span class="p">/</span> <span class="n">Tolerance</span><span class="p">)</span> <span class="p">*</span> <span class="n">Tolerance</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="kt">double</span> <span class="n">z</span> <span class="p">=</span> <span class="n">Math</span><span class="p">.</span><span class="n">Round</span><span class="p">(</span><span class="n">obj</span><span class="p">.</span><span class="n">Z</span> <span class="p">/</span> <span class="n">Tolerance</span><span class="p">)</span> <span class="p">*</span> <span class="n">Tolerance</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="n">x</span><span class="p">.</span><span class="n">GetHashCode</span><span class="p">()</span> <span class="p">^</span> <span class="n">y</span><span class="p">.</span><span class="n">GetHashCode</span><span class="p">()</span> <span class="p">^</span> <span class="n">z</span><span class="p">.</span><span class="n">GetHashCode</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><hr>
<h3 id="viewsonsheetscs"><code>ViewsOnSheets.cs</code><a hidden class="anchor" aria-hidden="true" href="#viewsonsheetscs">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="k">using</span> <span class="nn">Autodesk.Revit.Attributes</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="nn">Autodesk.Revit.DB</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="nn">Autodesk.Revit.UI</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="nn">ViewOnSheetsR2025.Services</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="nn">ViewOnSheetsR2025.UI</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">namespace</span> <span class="nn">ViewOnSheetsR2025</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="na">    [Transaction(TransactionMode.Manual)]</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="k">class</span> <span class="nc">ViewsOnSheets</span> <span class="p">:</span> <span class="n">IExternalCommand</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kd">public</span> <span class="n">Result</span> <span class="n">Execute</span><span class="p">(</span><span class="n">ExternalCommandData</span> <span class="n">commandData</span><span class="p">,</span> <span class="k">ref</span> <span class="kt">string</span> <span class="n">message</span><span class="p">,</span> <span class="n">ElementSet</span> <span class="n">elements</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">UIDocument</span> <span class="n">uidoc</span> <span class="p">=</span> <span class="n">commandData</span><span class="p">.</span><span class="n">Application</span><span class="p">.</span><span class="n">ActiveUIDocument</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">Document</span> <span class="n">doc</span> <span class="p">=</span> <span class="n">uidoc</span><span class="p">.</span><span class="n">Document</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// 1. Collect unplaced views</span>
</span></span><span class="line"><span class="cl">            <span class="kt">var</span> <span class="n">unplacedViews</span> <span class="p">=</span> <span class="n">ViewsOnSheetsR2025Service</span><span class="p">.</span><span class="n">GetUnplacedViews</span><span class="p">(</span><span class="n">doc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">unplacedViews</span><span class="p">.</span><span class="n">Count</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">TaskDialog</span><span class="p">.</span><span class="n">Show</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">                    <span class="s">&#34;Разместить виды на листах&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                    <span class="s">&#34;Не найдено непомещённых, не-шаблонных видов.&#34;</span>
</span></span><span class="line"><span class="cl">                <span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="n">Result</span><span class="p">.</span><span class="n">Cancelled</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// 2. Collect all sheets</span>
</span></span><span class="line"><span class="cl">            <span class="kt">var</span> <span class="n">allSheets</span> <span class="p">=</span> <span class="n">ViewsOnSheetsR2025Service</span><span class="p">.</span><span class="n">GetAllSheets</span><span class="p">(</span><span class="n">doc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// 3. Collect title blocks</span>
</span></span><span class="line"><span class="cl">            <span class="kt">var</span> <span class="n">titleBlocks</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">.</span><span class="n">OfClass</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">FamilySymbol</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                <span class="p">.</span><span class="n">OfCategory</span><span class="p">(</span><span class="n">BuiltInCategory</span><span class="p">.</span><span class="n">OST_TitleBlocks</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">.</span><span class="n">Cast</span><span class="p">&lt;</span><span class="n">FamilySymbol</span><span class="p">&gt;()</span>
</span></span><span class="line"><span class="cl">                <span class="p">.</span><span class="n">ToList</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">titleBlocks</span><span class="p">.</span><span class="n">Count</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">TaskDialog</span><span class="p">.</span><span class="n">Show</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">                    <span class="s">&#34;Разместить виды на листах&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                    <span class="s">&#34;В проекте не найдено штампов.&#34;</span>
</span></span><span class="line"><span class="cl">                <span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="n">Result</span><span class="p">.</span><span class="n">Cancelled</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// 4. Show selection window</span>
</span></span><span class="line"><span class="cl">            <span class="kt">var</span> <span class="n">window</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ViewsOnSheetsWindow</span><span class="p">(</span><span class="n">unplacedViews</span><span class="p">,</span> <span class="n">allSheets</span><span class="p">,</span> <span class="n">titleBlocks</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="kt">bool?</span> <span class="n">result</span> <span class="p">=</span> <span class="n">window</span><span class="p">.</span><span class="n">ShowDialog</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="p">!=</span> <span class="kc">true</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="n">Result</span><span class="p">.</span><span class="n">Cancelled</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// 5. Get selected views</span>
</span></span><span class="line"><span class="cl">            <span class="kt">var</span> <span class="n">selectedViews</span> <span class="p">=</span> <span class="n">window</span><span class="p">.</span><span class="n">SelectedViews</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">selectedViews</span> <span class="p">==</span> <span class="kc">null</span> <span class="p">||</span> <span class="n">selectedViews</span><span class="p">.</span><span class="n">Count</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">TaskDialog</span><span class="p">.</span><span class="n">Show</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">                    <span class="s">&#34;Разместить виды на листах&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                    <span class="s">&#34;Не выбраны виды.&#34;</span>
</span></span><span class="line"><span class="cl">                <span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="n">Result</span><span class="p">.</span><span class="n">Cancelled</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="kt">bool</span> <span class="n">createNewSheets</span> <span class="p">=</span> <span class="n">window</span><span class="p">.</span><span class="n">CreateNewSheets</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="kt">var</span> <span class="n">selectedSheets</span> <span class="p">=</span> <span class="n">window</span><span class="p">.</span><span class="n">SelectedSheets</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(!</span><span class="n">createNewSheets</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">selectedSheets</span> <span class="p">==</span> <span class="kc">null</span> <span class="p">||</span> <span class="n">selectedSheets</span><span class="p">.</span><span class="n">Count</span> <span class="p">!=</span> <span class="n">selectedViews</span><span class="p">.</span><span class="n">Count</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">TaskDialog</span><span class="p">.</span><span class="n">Show</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">                        <span class="s">&#34;Разместить виды на листах&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                        <span class="s">&#34;Количество выбранных листов должно совпадать с количеством выбранных видов.&#34;</span>
</span></span><span class="line"><span class="cl">                    <span class="p">);</span>
</span></span><span class="line"><span class="cl">                    <span class="k">return</span> <span class="n">Result</span><span class="p">.</span><span class="n">Cancelled</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// 6. Ask for point</span>
</span></span><span class="line"><span class="cl">            <span class="n">XYZ</span> <span class="n">placementPoint</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">try</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">placementPoint</span> <span class="p">=</span> <span class="n">uidoc</span><span class="p">.</span><span class="n">Selection</span><span class="p">.</span><span class="n">PickPoint</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">                    <span class="s">&#34;Укажите точку размещения на текущем листе. &#34;</span> <span class="p">+</span>
</span></span><span class="line"><span class="cl">                    <span class="s">&#34;Эта точка будет использована как центр для всех видов.&#34;</span>
</span></span><span class="line"><span class="cl">                <span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">ex</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">TaskDialog</span><span class="p">.</span><span class="n">Show</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">                    <span class="s">&#34;Разместить виды на листах&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                    <span class="s">&#34;Выбор точки отменён или завершился неудачно:\n&#34;</span> <span class="p">+</span> <span class="n">ex</span><span class="p">.</span><span class="n">Message</span>
</span></span><span class="line"><span class="cl">                <span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="n">Result</span><span class="p">.</span><span class="n">Cancelled</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// 7. Build the dictionary of parameter values from the window</span>
</span></span><span class="line"><span class="cl">            <span class="kt">var</span> <span class="n">paramValues</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="kt">string</span><span class="p">&gt;()</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="p">{</span> <span class="s">&#34;Формат А&#34;</span><span class="p">,</span>           <span class="n">window</span><span class="p">.</span><span class="n">SelectedFormatA</span>     <span class="p">??</span> <span class="s">&#34;&#34;</span> <span class="p">},</span>
</span></span><span class="line"><span class="cl">                <span class="p">{</span> <span class="s">&#34;Кратность&#34;</span><span class="p">,</span>          <span class="n">window</span><span class="p">.</span><span class="n">SelectedMultiplicity</span> <span class="p">??</span> <span class="s">&#34;&#34;</span> <span class="p">},</span>
</span></span><span class="line"><span class="cl">                <span class="p">{</span> <span class="s">&#34;Книжная ориентация&#34;</span><span class="p">,</span> <span class="n">window</span><span class="p">.</span><span class="n">SelectedOrientation</span>  <span class="p">??</span> <span class="s">&#34;&#34;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// 8. Retrieve the user-chosen scale from the window</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int</span> <span class="n">scale</span> <span class="p">=</span> <span class="n">window</span><span class="p">.</span><span class="n">SelectedViewScale</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// 9. Place views on sheets</span>
</span></span><span class="line"><span class="cl">            <span class="k">try</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">ViewsOnSheetsR2025Service</span><span class="p">.</span><span class="n">PlaceViewsOnSheets</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">                    <span class="n">doc</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                    <span class="n">createNewSheets</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                    <span class="n">selectedViews</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                    <span class="n">selectedSheets</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                    <span class="n">placementPoint</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                    <span class="n">window</span><span class="p">.</span><span class="n">SelectedTitleBlockId</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                    <span class="n">paramValues</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                    <span class="n">scale</span>
</span></span><span class="line"><span class="cl">                <span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="n">Result</span><span class="p">.</span><span class="n">Succeeded</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">ex</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">TaskDialog</span><span class="p">.</span><span class="n">Show</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">                    <span class="s">&#34;Разместить виды на листах&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                    <span class="s">&#34;Ошибка при размещении видов:\n&#34;</span> <span class="p">+</span> <span class="n">ex</span><span class="p">.</span><span class="n">Message</span>
</span></span><span class="line"><span class="cl">                <span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="n">Result</span><span class="p">.</span><span class="n">Failed</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><hr>
<h3 id="autolevelmarkercs"><code>AutoLevelMarker.cs</code><a hidden class="anchor" aria-hidden="true" href="#autolevelmarkercs">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C#" data-lang="C#"><span class="line"><span class="cl"><span class="k">using</span> <span class="nn">Autodesk.Revit.Attributes</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="nn">Autodesk.Revit.DB</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="nn">Autodesk.Revit.UI</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">namespace</span> <span class="nn">CreateLevelMarkers</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="na">    [Transaction(TransactionMode.Manual)]</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="k">class</span> <span class="nc">Command</span> <span class="p">:</span> <span class="n">IExternalCommand</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kd">public</span> <span class="n">Result</span> <span class="n">Execute</span><span class="p">(</span><span class="n">ExternalCommandData</span> <span class="n">commandData</span><span class="p">,</span> <span class="k">ref</span> <span class="kt">string</span> <span class="n">message</span><span class="p">,</span> <span class="n">ElementSet</span> <span class="n">elements</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">UIApplication</span> <span class="n">uiapp</span> <span class="p">=</span> <span class="n">commandData</span><span class="p">.</span><span class="n">Application</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">UIDocument</span> <span class="n">uidoc</span> <span class="p">=</span> <span class="n">uiapp</span><span class="p">.</span><span class="n">ActiveUIDocument</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">Document</span> <span class="n">doc</span> <span class="p">=</span> <span class="n">uidoc</span><span class="p">.</span><span class="n">Document</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="k">try</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// Create and show the main form.</span>
</span></span><span class="line"><span class="cl">                <span class="n">AutoLevelMarker</span> <span class="n">form</span> <span class="p">=</span> <span class="k">new</span> <span class="n">AutoLevelMarker</span><span class="p">(</span><span class="n">doc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="kt">bool?</span> <span class="n">dialogResult</span> <span class="p">=</span> <span class="n">form</span><span class="p">.</span><span class="n">ShowDialog</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">dialogResult</span> <span class="p">!=</span> <span class="kc">true</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="k">return</span> <span class="n">Result</span><span class="p">.</span><span class="n">Cancelled</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="c1">// Retrieve user selections.</span>
</span></span><span class="line"><span class="cl">                <span class="kt">var</span> <span class="n">selectedSections</span> <span class="p">=</span> <span class="n">form</span><span class="p">.</span><span class="n">SelectedSections</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="kt">var</span> <span class="n">selectedFamilies</span> <span class="p">=</span> <span class="n">form</span><span class="p">.</span><span class="n">SelectedFamilies</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="kt">var</span> <span class="n">markerType</span> <span class="p">=</span> <span class="n">form</span><span class="p">.</span><span class="n">SelectedMarkerType</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="kt">var</span> <span class="n">offsetMeters</span> <span class="p">=</span> <span class="n">form</span><span class="p">.</span><span class="n">OffsetValue</span> <span class="p">*</span> <span class="m">3.28084</span><span class="p">;</span> <span class="c1">// Convert meters to feet</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="c1">// Retrieve optional parameter names.</span>
</span></span><span class="line"><span class="cl">                <span class="kt">var</span> <span class="n">selectedSourceParam</span> <span class="p">=</span> <span class="n">form</span><span class="p">.</span><span class="n">SelectedSourceParam</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="kt">var</span> <span class="n">selectedTargetParam</span> <span class="p">=</span> <span class="n">form</span><span class="p">.</span><span class="n">SelectedTargetParam</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="c1">// Process each section and create markers.</span>
</span></span><span class="line"><span class="cl">                <span class="k">using</span> <span class="p">(</span><span class="n">Transaction</span> <span class="n">t</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Transaction</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="s">&#34;Create Level Markers&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">t</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                    <span class="k">if</span> <span class="p">(!</span><span class="n">markerType</span><span class="p">.</span><span class="n">IsActive</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                        <span class="n">markerType</span><span class="p">.</span><span class="n">Activate</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                    <span class="k">foreach</span> <span class="p">(</span><span class="n">ViewSection</span> <span class="n">section</span> <span class="k">in</span> <span class="n">selectedSections</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                    <span class="p">{</span>
</span></span><span class="line"><span class="cl">                        <span class="kt">var</span> <span class="n">instances</span> <span class="p">=</span> <span class="k">new</span> <span class="n">FilteredElementCollector</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="n">section</span><span class="p">.</span><span class="n">Id</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                            <span class="p">.</span><span class="n">OfClass</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">FamilyInstance</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                            <span class="p">.</span><span class="n">Cast</span><span class="p">&lt;</span><span class="n">FamilyInstance</span><span class="p">&gt;()</span>
</span></span><span class="line"><span class="cl">                            <span class="p">.</span><span class="n">Where</span><span class="p">(</span><span class="n">i</span> <span class="p">=&gt;</span>
</span></span><span class="line"><span class="cl">                            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                                <span class="k">try</span>
</span></span><span class="line"><span class="cl">                                <span class="p">{</span>
</span></span><span class="line"><span class="cl">                                    <span class="k">return</span> <span class="n">i</span><span class="p">.</span><span class="n">Symbol</span> <span class="p">!=</span> <span class="kc">null</span> <span class="p">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">                                           <span class="n">i</span><span class="p">.</span><span class="n">Symbol</span><span class="p">.</span><span class="n">Family</span> <span class="p">!=</span> <span class="kc">null</span> <span class="p">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">                                           <span class="n">selectedFamilies</span><span class="p">.</span><span class="n">Contains</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">Symbol</span><span class="p">.</span><span class="n">Family</span><span class="p">.</span><span class="n">Name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                                <span class="k">catch</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">                            <span class="p">})</span>
</span></span><span class="line"><span class="cl">                            <span class="p">.</span><span class="n">ToList</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                        <span class="n">TaskDialog</span><span class="p">.</span><span class="n">Show</span><span class="p">(</span><span class="s">&#34;Найдено&#34;</span><span class="p">,</span> <span class="s">&#34;Найдено &#34;</span> <span class="p">+</span> <span class="n">instances</span><span class="p">.</span><span class="n">Count</span> <span class="p">+</span> <span class="s">&#34; экземпляров&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                        <span class="k">foreach</span> <span class="p">(</span><span class="n">FamilyInstance</span> <span class="n">inst</span> <span class="k">in</span> <span class="n">instances</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                        <span class="p">{</span>
</span></span><span class="line"><span class="cl">                            <span class="k">try</span>
</span></span><span class="line"><span class="cl">                            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                                <span class="n">BoundingBoxXYZ</span> <span class="n">bb</span> <span class="p">=</span> <span class="n">inst</span><span class="p">.</span><span class="n">get_BoundingBox</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                                <span class="k">if</span> <span class="p">(</span><span class="n">bb</span> <span class="p">!=</span> <span class="kc">null</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                                <span class="p">{</span>
</span></span><span class="line"><span class="cl">                                    <span class="n">XYZ</span> <span class="n">center</span> <span class="p">=</span> <span class="p">(</span><span class="n">bb</span><span class="p">.</span><span class="n">Min</span> <span class="p">+</span> <span class="n">bb</span><span class="p">.</span><span class="n">Max</span><span class="p">)</span> <span class="p">*</span> <span class="m">0.5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                                    <span class="n">XYZ</span> <span class="n">placementPoint</span> <span class="p">=</span> <span class="k">new</span> <span class="n">XYZ</span><span class="p">(</span><span class="n">center</span><span class="p">.</span><span class="n">X</span> <span class="p">+</span> <span class="n">offsetMeters</span><span class="p">,</span> <span class="n">center</span><span class="p">.</span><span class="n">Y</span><span class="p">,</span> <span class="n">center</span><span class="p">.</span><span class="n">Z</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                                    <span class="n">FamilyInstance</span> <span class="n">marker</span> <span class="p">=</span> <span class="n">doc</span><span class="p">.</span><span class="n">Create</span><span class="p">.</span><span class="n">NewFamilyInstance</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">                                        <span class="n">placementPoint</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                        <span class="n">markerType</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                        <span class="n">section</span>
</span></span><span class="line"><span class="cl">                                    <span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                                    <span class="c1">// Optional: copy parameter value if both parameter names are provided.</span>
</span></span><span class="line"><span class="cl">                                    <span class="k">if</span> <span class="p">(!</span><span class="kt">string</span><span class="p">.</span><span class="n">IsNullOrEmpty</span><span class="p">(</span><span class="n">selectedSourceParam</span><span class="p">)</span> <span class="p">&amp;&amp;</span> <span class="p">!</span><span class="kt">string</span><span class="p">.</span><span class="n">IsNullOrEmpty</span><span class="p">(</span><span class="n">selectedTargetParam</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                                    <span class="p">{</span>
</span></span><span class="line"><span class="cl">                                        <span class="kt">var</span> <span class="n">allParams</span> <span class="p">=</span> <span class="n">ParameterUtilities</span><span class="p">.</span><span class="n">GetAllParameters</span><span class="p">(</span><span class="n">inst</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                                        <span class="n">Parameter</span><span class="p">?</span> <span class="n">sourceParam</span> <span class="p">=</span> <span class="n">allParams</span><span class="p">.</span><span class="n">ContainsKey</span><span class="p">(</span><span class="n">selectedSourceParam</span><span class="p">)</span> <span class="p">?</span>
</span></span><span class="line"><span class="cl">                                            <span class="n">allParams</span><span class="p">[</span><span class="n">selectedSourceParam</span><span class="p">]</span> <span class="p">:</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                                        <span class="k">if</span> <span class="p">(</span><span class="n">sourceParam</span> <span class="p">==</span> <span class="kc">null</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                                        <span class="p">{</span>
</span></span><span class="line"><span class="cl">                                            <span class="n">TaskDialog</span><span class="p">.</span><span class="n">Show</span><span class="p">(</span><span class="s">&#34;Ошибка&#34;</span><span class="p">,</span> <span class="s">&#34;Параметр не найден: &#34;</span> <span class="p">+</span> <span class="n">selectedSourceParam</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                                            <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                                        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                                        <span class="kt">double</span> <span class="n">paramValue</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                                        <span class="k">switch</span> <span class="p">(</span><span class="n">sourceParam</span><span class="p">.</span><span class="n">StorageType</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                                        <span class="p">{</span>
</span></span><span class="line"><span class="cl">                                            <span class="k">case</span> <span class="n">StorageType</span><span class="p">.</span><span class="n">Double</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                                                <span class="n">paramValue</span> <span class="p">=</span> <span class="n">sourceParam</span><span class="p">.</span><span class="n">AsDouble</span><span class="p">()</span> <span class="p">*</span> <span class="m">1000</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                                                <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                                            <span class="k">case</span> <span class="n">StorageType</span><span class="p">.</span><span class="n">Integer</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                                                <span class="n">paramValue</span> <span class="p">=</span> <span class="n">sourceParam</span><span class="p">.</span><span class="n">AsInteger</span><span class="p">()</span> <span class="p">*</span> <span class="m">1000</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                                                <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                                            <span class="k">case</span> <span class="n">StorageType</span><span class="p">.</span><span class="n">String</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                                                <span class="kt">string</span> <span class="n">stringValue</span> <span class="p">=</span> <span class="n">sourceParam</span><span class="p">.</span><span class="n">AsString</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">                                                <span class="kt">double</span> <span class="n">tempValue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                                                <span class="k">if</span> <span class="p">(!</span><span class="kt">string</span><span class="p">.</span><span class="n">IsNullOrEmpty</span><span class="p">(</span><span class="n">stringValue</span><span class="p">)</span> <span class="p">&amp;&amp;</span> <span class="kt">double</span><span class="p">.</span><span class="n">TryParse</span><span class="p">(</span><span class="n">stringValue</span><span class="p">,</span> <span class="k">out</span> <span class="n">tempValue</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                                                    <span class="n">paramValue</span> <span class="p">=</span> <span class="n">tempValue</span> <span class="p">*</span> <span class="m">1000</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                                                <span class="k">else</span>
</span></span><span class="line"><span class="cl">                                                <span class="p">{</span>
</span></span><span class="line"><span class="cl">                                                    <span class="n">TaskDialog</span><span class="p">.</span><span class="n">Show</span><span class="p">(</span><span class="s">&#34;Ошибка&#34;</span><span class="p">,</span> <span class="s">&#34;Параметр имеет нечисловое значение: &#34;</span> <span class="p">+</span> <span class="n">stringValue</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                                                    <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                                                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                                                <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                                            <span class="k">default</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                                                <span class="n">TaskDialog</span><span class="p">.</span><span class="n">Show</span><span class="p">(</span><span class="s">&#34;Ошибка&#34;</span><span class="p">,</span> <span class="s">&#34;Параметр имеет неподдерживаемый тип хранения&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                                                <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                                        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                                        <span class="kt">var</span> <span class="n">markerParams</span> <span class="p">=</span> <span class="n">ParameterUtilities</span><span class="p">.</span><span class="n">GetAllParameters</span><span class="p">(</span><span class="n">marker</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                                        <span class="n">Parameter</span><span class="p">?</span> <span class="n">targetParam</span> <span class="p">=</span> <span class="n">markerParams</span><span class="p">.</span><span class="n">ContainsKey</span><span class="p">(</span><span class="n">selectedTargetParam</span><span class="p">)</span> <span class="p">?</span>
</span></span><span class="line"><span class="cl">                                            <span class="n">markerParams</span><span class="p">[</span><span class="n">selectedTargetParam</span><span class="p">]</span> <span class="p">:</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                                        <span class="k">if</span> <span class="p">(</span><span class="n">targetParam</span> <span class="p">!=</span> <span class="kc">null</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                                        <span class="p">{</span>
</span></span><span class="line"><span class="cl">                                            <span class="k">if</span> <span class="p">(</span><span class="n">targetParam</span><span class="p">.</span><span class="n">IsReadOnly</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                                            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                                                <span class="n">TaskDialog</span><span class="p">.</span><span class="n">Show</span><span class="p">(</span><span class="s">&#34;Ошибка&#34;</span><span class="p">,</span> <span class="s">&#34;Невозможно изменить параметр только для чтения: &#34;</span> <span class="p">+</span> <span class="n">selectedTargetParam</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                                            <span class="p">}</span>
</span></span><span class="line"><span class="cl">                                            <span class="k">else</span>
</span></span><span class="line"><span class="cl">                                            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                                                <span class="k">switch</span> <span class="p">(</span><span class="n">targetParam</span><span class="p">.</span><span class="n">StorageType</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                                                <span class="p">{</span>
</span></span><span class="line"><span class="cl">                                                    <span class="k">case</span> <span class="n">StorageType</span><span class="p">.</span><span class="n">Double</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                                                        <span class="n">targetParam</span><span class="p">.</span><span class="n">Set</span><span class="p">((</span><span class="kt">double</span><span class="p">)</span><span class="n">paramValue</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                                                        <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                                                    <span class="k">case</span> <span class="n">StorageType</span><span class="p">.</span><span class="n">Integer</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                                                        <span class="n">targetParam</span><span class="p">.</span><span class="n">Set</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">paramValue</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                                                        <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                                                    <span class="k">case</span> <span class="n">StorageType</span><span class="p">.</span><span class="n">String</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                                                        <span class="n">targetParam</span><span class="p">.</span><span class="n">Set</span><span class="p">(</span><span class="n">paramValue</span><span class="p">.</span><span class="n">ToString</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">                                                        <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                                                    <span class="k">default</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                                                        <span class="n">TaskDialog</span><span class="p">.</span><span class="n">Show</span><span class="p">(</span><span class="s">&#34;Ошибка&#34;</span><span class="p">,</span> <span class="s">&#34;Целевой параметр имеет неподдерживаемый тип хранения&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                                                        <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                                                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                                            <span class="p">}</span>
</span></span><span class="line"><span class="cl">                                        <span class="p">}</span>
</span></span><span class="line"><span class="cl">                                        <span class="k">else</span>
</span></span><span class="line"><span class="cl">                                        <span class="p">{</span>
</span></span><span class="line"><span class="cl">                                            <span class="n">TaskDialog</span><span class="p">.</span><span class="n">Show</span><span class="p">(</span><span class="s">&#34;Ошибка&#34;</span><span class="p">,</span> <span class="s">&#34;Параметр не найден в маркере: &#34;</span> <span class="p">+</span> <span class="n">selectedTargetParam</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                                        <span class="p">}</span>
</span></span><span class="line"><span class="cl">                                    <span class="p">}</span>
</span></span><span class="line"><span class="cl">                                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                            <span class="p">}</span>
</span></span><span class="line"><span class="cl">                            <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">ex</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                                <span class="n">TaskDialog</span><span class="p">.</span><span class="n">Show</span><span class="p">(</span><span class="s">&#34;Ошибка&#34;</span><span class="p">,</span> <span class="s">&#34;Ошибка при обработке экземпляра: &#34;</span> <span class="p">+</span> <span class="n">ex</span><span class="p">.</span><span class="n">Message</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                            <span class="p">}</span>
</span></span><span class="line"><span class="cl">                        <span class="p">}</span>
</span></span><span class="line"><span class="cl">                    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                    <span class="n">t</span><span class="p">.</span><span class="n">Commit</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="c1">//MessageBox.Show(&#34;Логика создания маркеров будет запущена.&#34;, &#34;Информация&#34;, MessageBoxButton.OK, MessageBoxImage.Information);</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="n">Result</span><span class="p">.</span><span class="n">Succeeded</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">ex</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">message</span> <span class="p">=</span> <span class="n">ex</span><span class="p">.</span><span class="n">Message</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="n">Result</span><span class="p">.</span><span class="n">Failed</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/c%23/">C#</a></li>
      <li><a href="http://localhost:1313/tags/revit/">Revit</a></li>
      <li><a href="http://localhost:1313/tags/tutorial/">Tutorial</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/posts/post-14/">
    <span class="title">« Prev</span>
    <br>
    <span>C# &#43; Revit API: Lesson 14 - Case Study №2 [Dimension Automation]</span>
  </a>
  <a class="next" href="http://localhost:1313/posts/post-12/">
    <span class="title">Next »</span>
    <br>
    <span>C# &#43; Revit API: Lesson 12 - FilteredElementCollector</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>© 2025 AYDrafting. All rights reserved.</span> · 

    <span>
        Powered by
        <a href="https://aydrafting.com/" rel="noopener noreferrer" target="_blank">AYDrafting</a> &
        <a href="https://github.com/aydimir95/" rel="noopener" target="_blank">GitHub</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
