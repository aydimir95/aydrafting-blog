[{"content":" MessageBox Forms - needed to send alerts to the user from our add-in.\nBefore, we were using TaskDialog to convey outcomes to the user when they run our tools. It\u0026rsquo;s ok for the basic processes but lacks the level of interaction we need. We will use a MessageBox form to address this and contain it within a custom method we can easily call on and customize further. MessageBox Anatomy We will use a custom method to make a more flexible form with multiple options, icons etc. Microsoft/DotNet Docs Most things we will use that are related to Windows tend to fall under the System library. We will need to get used to consulting the dotnet Docs as well as Revit API Docs for many things in the future. Example: MessageBox Class 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 private void Form1_FormClosing(object sender, FormClosingEventArgs e) { const string message = \u0026#34;Are you sure that you would like to close the form?\u0026#34;; const string caption = \u0026#34;Form Closing\u0026#34;; var result = MessageBox.Show( message, caption, MessageBoxButtons.YesNo, // MessageBoxButtons Enum MessageBoxIcon.Question); // MessageBoxIcons Enum // If the no button was pressed ... if (result == Dialog.No) // DialogResult Enum { // cancel the closure of the form. e.Cancel = true; } } DialogResult Enum Name Value Description None 0 Nothing is returned from the dialog box. This means that the modal dialog continues running. OK 1 The dialog box return value is OK (usually sent from a button labeled OK). Cancel 2 The dialog box return value is Cancel (usually sent from a button labeled Cancel). Abort 3 The dialog box return value is Abort (usually sent from a button labeled Abort). Retry 4 The dialog box return value is Retry (usually sent from a button labeled Retry). Ignore 5 The dialog box return value is Ignore (usually sent from a button labeled Ignore). Yes 6 The dialog box return value is Yes (usually sent from a button labeled Yes). No 7 The dialog box return value is No (usually sent from a button labeled No). TryAgain 10 The dialog box return value is Try Again (usually sent from a button labeled Try Again). Continue 11 The dialog box return value is Continue (usually sent from a button labeled Continue). MessageBoxButtons Enum Name Value Description OK 0 The message box contains an OK button. OKCancel 1 The message box contains OK and Cancel buttons. AbortRetryIgnore 2 The message box contains Abort, Retry, and Ignore buttons. YesNoCancel 3 The message box contains Yes, No, and Cancel buttons. YesNo 4 The message box contains Yes and No buttons. RetryCancel 5 The message box contains Retry and Cancel buttons. CancelTryContinue 6 Specifies that the message box contains Cancel, Try Again, and Continue buttons. MessageBoxIcons Enum Name Value Description None 0 The message box contains no symbols. Error 16 The message box contains a symbol consisting of white X in a circle with a red background. Hand 16 The message box contains a symbol consisting of a white X in a circle with a red background. Stop 16 The message box contains a symbol consisting of white X in a circle with a red background. Question 32 The message box contains a symbol consisting of a question mark in a circle. The question mark message icon is no longer recommended because it does not clearly represent a specific type of message and because the phrasing of a message as a question could apply to any message type. In addition, users can confuse the question mark symbol with a help information symbol. Therefore, do not use this question mark symbol in your message boxes. The system continues to support its inclusion only for backward compatibility. Exclamation 48 The message box contains a symbol consisting of an exclamation point in a triangle with a yellow background. Warning 48 The message box contains a symbol consisting of an exclamation point in a triangle with a yellow background. Asterisk 64 The message box contains a symbol consisting of a lowercase letter i in a circle. Information 64 The message box contains a symbol consisting of a lowercase letter i in a circle. FormResult Class from Lesson 4 We will always have our forms return a consistent custom object which tells us: If the form was cancelled, valid, affirmative If there are object(s) returned If there is a single object returned Homework Tidy up the FormResult Class Set up a Custom Method Develop fixed variants Solution Project Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 Solution |-\u0026gt; ViewOnSheets2025 |-\u0026gt; Dependencies |-\u0026gt; Properties |-\u0026gt; Commands |-\u0026gt; Cmd_Button.cs # Update |-\u0026gt; Forms |-\u0026gt; Custom.cs # Update |-\u0026gt; Extensions |-\u0026gt; General |-\u0026gt; Models |-\u0026gt; Resources |-\u0026gt; Services |-\u0026gt; Utilities |-\u0026gt; Views |-\u0026gt; Application.cs |-\u0026gt; Host.cs |-\u0026gt; guRoo.addin Custom.cs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Windows.Forms; // Might need to add the Forms in Assemblies namespace guRoo.Forms { public static class Custom { /// \u0026lt;Summary\u0026gt; /// /// \u0026lt;/Summary\u0026gt; /// \u0026lt;param name=\u0026#34;title\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;message\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;yesNo\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;noCancel\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;icon\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;return\u0026gt;\u0026lt;/return\u0026gt; public static FormResult Message( string title = null, string message = null, message = null, bool yesNo = false, bool noCancel = false, MessageBoxIcon icon = MessageBoxIcon.None) // by default = no icons { var formResult = new FromResult(isValid: false); title ??= \u0026#34;Message\u0026#34;; message ??= \u0026#34;No message was provided.\u0026#34;; if (yesNo \u0026amp;\u0026amp; icon == MessageBoxIcon.None) { icon = MessageBoxIcon.Question; } buttons = MessageBoxButtons.OKCancel; if (noCancel) { buttons = MessageBoxButtons.OK; } else if (yesNo) { buttons = MessageBoxButtons.YesNo; } var dialogResult = MessageBox.Show( message, title, buttons, icon); if (dialogResult == DialogResult.Yes || dialogResult == DialogResult.OK) { formResult.Validate(); return formResult; } } /// \u0026lt;Summary\u0026gt; /// /// \u0026lt;/Summary\u0026gt; /// \u0026lt;param name=\u0026#34;message\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;return\u0026gt;\u0026lt;/return\u0026gt; public static Result Completed(string message) { Message( title: \u0026#34;Task Completed\u0026#34;, message: message, yesNo: false, noCancel: true icon: MessageBoxIcon.Information); return Result.Succeded; } /// \u0026lt;Summary\u0026gt; /// /// \u0026lt;/Summary\u0026gt; /// \u0026lt;param name=\u0026#34;message\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;return\u0026gt;\u0026lt;/return\u0026gt; public static Result Cancelled(string message) { Message( title: \u0026#34;Task Cancelled\u0026#34;, message: message, yesNo: false, noCancel: true icon: MessageBoxIcon.Warning); return Result.Cancelled; } /// \u0026lt;Summary\u0026gt; /// /// \u0026lt;/Summary\u0026gt; /// \u0026lt;param name=\u0026#34;message\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;return\u0026gt;\u0026lt;/return\u0026gt; public static Result Error(string message) { Message( title: \u0026#34;Error\u0026#34;, message: message, yesNo: false, noCancel: true icon: MessageBoxIcon.Error); return Result.Cancelled; } } public class FormResult { public object Object{ get; set; } public List\u0026lt;object\u0026gt; Objects { get; set; } public bool Cancelled { get; set; } public bool Valid { get; set; } public bool Affirmative { get; set; } // Constructor (Default) public FormResult() { this.Object = null; this.Objects = new List\u0026lt;object\u0026gt;(); this.Cancelled = true; this.Valid = false; this.Affirmative = false; } // Constructor (Alternative) public FormResult(bool isValid) { this.Object = null; this.Objects = new List\u0026lt;object\u0026gt;(); this.Cancelled = !isValid; this.Valid = isValid; this.Affirmative = isValid; } // Method to validate public void Validate() { this.Cancelled = true; this.Valid = true; this.Affirmative = true; } // Method to validate public void Validate(object obj) { this.Validate(); this.Object = obj; } // Method to validate public void Validate(List\u0026lt;object\u0026gt; objs) { this.Validate(); this.Objects = objs; } } } Cmds_Button.cs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 // Autodesk using Autodesk.Revit.Attributes; using Autodesk.Revit.UI; using Autodesk.Revit.DB; //UKON using UKON.Extensions; using gFrm = guRoo.Forms; // Associate with PushButton Commands namespace guRoo.Commands.General { /// \u0026lt;summary\u0026gt; ///\tExample Command /// \u0026lt;/summary\u0026gt; [Transaction(TransactionMode.Manual)] public class Cmd_Test : IExternalCommand { public Result Execute(ExternalCommandData CommandData, ref string message, ElementSet elements) { // Collect the Document and Application objects from the CommandData var (uiApp, uiDoc, doc) = CommandData.Ext_GetRevitContext(); // Collect all walls var walls = new FilteredElementCollector(doc) .OfClass(typeof(Wall)) .WhereElementIsNotElementType() .ToElements(); // Show the message dialog with the document title gFrm.Custom.Message( doc.Title, $\u0026#34;We have {walls.Count} walls in the model\u0026#34; ); // Collect all walls lower than 12 feet // First: Construct a filter for .WherePasses() Method var parameterId = new ElementId(BuiltInParameter.WALL_USER_HEIGHT_PARAM); var provider = new ParameterValueProvider(parameterId); var rule = new FilterNumericLess(); var passesRule = new FilterDoubleRule(provider, rule, 12, 0.1); var paramFilter = new ElementParameterFilter(passesRule); // Then: Apply the filter to the FilteredElementCollector var wallsFiltered = new FilteredElementCollector(doc) .OfCategory(BuiltInCategory.OST_Walls) .WhereElementIsNotElementType() .WherePasses(paramFilter) .ToElements(); // Show the message dialog with different warning MessageBoxes var yesNoResult = uFrm.Custom.Message(doc.Title, $\u0026#34;We have {wallsFiltered.Count} walls less than 12 feet in the model\u0026#34;, yesNo: true); if (yesNoResult.Cancelled) { return Result.Cancelled; } if (yesNoResult.Cancelled) { return gFrm.Custom.Cancelled(\u0026#34;\\\u0026#39;No\\\u0026#39; was chosen.\u0026#34;); } gFrm.Custom.Error(\u0026#34;An error did not occur, just showing this form.\u0026#34;); return gFrm.Custom.Completed(\u0026#34;Script completed\u0026#34;); } } } ","permalink":"https://blog.aydrafting.com/posts/lesson-13/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003ccode\u003eMessageBox Forms\u003c/code\u003e - needed to send alerts to the user from our add-in.\u003c/p\u003e\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003eBefore, we were using \u003ccode\u003eTaskDialog\u003c/code\u003e to convey outcomes to the user when they run our tools. It\u0026rsquo;s ok for the basic processes but lacks the level of interaction we need.\u003c/li\u003e\n\u003cli\u003eWe will use a \u003ccode\u003eMessageBox\u003c/code\u003e form to address this and contain it within a custom method we can easily call on and customize further.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"messagebox-anatomy\"\u003e\u003ccode\u003eMessageBox\u003c/code\u003e Anatomy\u003c/h1\u003e\n\u003cp\u003e\u003cimg alt=\"Pasted image 20250901160911.png\" loading=\"lazy\" src=\"/images/Pasted%20image%2020250901160911.png\"\u003e\u003c/p\u003e","title":"C# + Revit API: Lesson 13 - MessageBox Forms"},{"content":"This post explains one concrete command—line by line—so a beginner can follow without extra abstractions.\nWhat this command does when you click your add-in button:\nTries to create a sheet (using an invalid title block on purpose → shows how error handling works).\nCollects up to 10 existing sheets and formats their numbers/names.\nDisplays the result in a WPF dialog via a ViewModel.\n✅ This article focuses only on the command. It assumes you’ve already wired a ribbon button (and .addin) that triggers StartupCommand.\nIf you have no knowledge of how to set this up, I would suggest just skimming through - just for reference and going to the next post, where I will start from scratch.\nThe Command (Full Code) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 using Autodesk.Revit.Attributes; using Nice3point.Revit.Toolkit.External; using guRoo.Views; using guRoo.ViewModels; namespace guRoo.Commands { /// \u0026lt;summary\u0026gt; /// External command entry point /// \u0026lt;/summary\u0026gt; [UsedImplicitly] [Transaction(TransactionMode.Manual)] public class StartupCommand : ExternalCommand { public override void Execute() { var viewModel = Host.GetService\u0026lt;guRooViewModel\u0026gt;(); var titleBlockId = ElementId.InvalidElementId; string resultMessage = \u0026#34;\u0026#34;; using (var transaction = new Transaction(Document, \u0026#34;Create Sheet\u0026#34;)) { transaction.Start(); try { var sheet = ViewSheet.Create(Document, titleBlockId); transaction.Commit(); resultMessage = \u0026#34;Sheet created successfully!\u0026#34;; } catch (Autodesk.Revit.Exceptions.ArgumentException ex) { transaction.RollBack(); resultMessage = $\u0026#34;Sheet could not be made: {ex.Message}\u0026#34;; } catch (Exception ex) { transaction.RollBack(); resultMessage = $\u0026#34;Error: {ex.Message}\u0026#34;; } } // Get sheet information to display var allSheets = new FilteredElementCollector(Document). OfClass(typeof(ViewSheet)). ToElements(). ToList(); if (allSheets.Count \u0026gt; 0) { var sheetNames = new List\u0026lt;string\u0026gt;(); for (int i = 0; i \u0026lt; Math.Min(10, allSheets.Count); i++) { var sheet = allSheets[i] as ViewSheet; sheetNames.Add($\u0026#34;{sheet.SheetNumber} - {sheet.Name}\u0026#34;); } resultMessage += $\u0026#34;\\n\\nFound {allSheets.Count} sheets: \\n\u0026#34; + string.Join(\u0026#34;\\n\u0026#34;, sheetNames); } else { resultMessage += \u0026#34;\\n\\nNo sheets found in document.\u0026#34;; } viewModel.ResultMessage = resultMessage; var view = new guRooView(viewModel); view.ShowDialog(); } } } What Each Part Does (Beginner-Friendly) 1) Imports 1 2 3 4 using Autodesk.Revit.Attributes; // [Transaction(...)] attribute using Nice3point.Revit.Toolkit.External; // ExternalCommand base + Host DI using guRoo.Views; // WPF Window (guRooView) using guRoo.ViewModels; // ViewModel (guRooViewModel) Revit attributes let you declare transaction behaviour.\nNice3point Toolkit provides a simplified ExternalCommand base (gives you Document) and DI access via Host.GetService\u0026lt;T\u0026gt;().\nViews/ViewModels are your WPF MVVM types.\n2) Class \u0026amp; Attributes 1 2 3 [UsedImplicitly] [Transaction(TransactionMode.Manual)] public class StartupCommand : ExternalCommand StartupCommand runs when the user clicks your button.\n[Transaction(TransactionMode.Manual)] = you start/commit/rollback changes.\nExternalCommand (Nice3point) simplifies the Revit command pattern.\nUsedImplicitly is an analyzer hint (e.g., JetBrains) so tooling doesn’t flag it as “unused.”\n3) Getting the ViewModel 1 var viewModel = Host.GetService\u0026lt;UguRooViewModel\u0026gt;(); Pulls a ViewModel instance from DI so the dialog can display results via data binding. 4) Intentionally Invalid Title Block 1 2 3 4 var titleBlockId = ElementId.InvalidElementId; // invalid on purpose string resultMessage = \u0026#34;\u0026#34;; We force a failure to demonstrate safe error handling. resultMessage will collect feedback for the user. 5) Transaction + Error Handling Around ViewSheet.Create 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 using (var transaction = new Transaction(Document, \u0026#34;Create Sheet\u0026#34;)) { transaction.Start(); try { var sheet = ViewSheet.Create(Document, titleBlockId); transaction.Commit(); resultMessage = \u0026#34;Sheet created successfully!\u0026#34;; } catch (Autodesk.Revit.Exceptions.ArgumentException ex) { transaction.RollBack(); resultMessage = $\u0026#34;Sheet could not be made: {ex.Message}\u0026#34;; } catch (Exception ex) { transaction.RollBack(); resultMessage = $\u0026#34;Error: {ex.Message}\u0026#34;; } } Revit is read-only unless you’re inside a Transaction. Creating a sheet with an invalid title block throws ArgumentException → we rollback safely and show the message. Any unexpected error also triggers a rollback. This is the core pattern you’ll reuse for any change in Revit: Start → Do work → Commit or RollBack on error.\n6) Collecting Existing Sheets 1 2 3 4 var allSheets = new FilteredElementCollector(Document) .OfClass(typeof(ViewSheet)) .ToElements() .ToList(); Use FilteredElementCollector to find elements in the document. Here we collect all sheets. Then we format a short list for display:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 if (allSheets.Count \u0026gt; 0) { var sheetNames = new List\u0026lt;string\u0026gt;(); for (int i = 0; i \u0026lt; Math.Min(10, allSheets.Count); i++) { var sheet = allSheets[i] as ViewSheet; sheetNames.Add($\u0026#34;{sheet.SheetNumber} - {sheet.Name}\u0026#34;); } resultMessage += $\u0026#34;\\n\\nFound {allSheets.Count} sheets:\\n\u0026#34; + string.Join(\u0026#34;\\n\u0026#34;, sheetNames); } else { resultMessage += \u0026#34;\\n\\nNo sheets found in document.\u0026#34;; } We show up to 10 sheets as \u0026ldquo;A101 - Floor Plan\u0026rdquo;. If there are none, we display that clearly. 7) Show the Result in WPF 1 2 3 4 viewModel.ResultMessage = resultMessage; var view = new guRooView(viewModel); view.ShowDialog(); Set the ViewModel property (MVVM). Open your WPF dialog to show the message. Why the Sheet Creation “Fails” (and How to Make It Succeed) It fails because we passed ElementId.InvalidElementId. To actually create a sheet, find a real title block type first:\n1 2 3 4 var titleBlockId = new FilteredElementCollector(Document) .OfCategory(BuiltInCategory.OST_TitleBlocks) .WhereElementIsElementType() .FirstElementId(); // throws if none exist Replace the invalid id with this titleBlockId before ViewSheet.Create(...) and the command will create a sheet (assuming at least one title block type is loaded).\nOptional Cleanups (Beginner-Safe) Safer casting with LINQ: 1 2 3 4 var sheets = new FilteredElementCollector(Document) .OfClass(typeof(ViewSheet)) .Cast\u0026lt;ViewSheet\u0026gt;() .ToList(); StringBuilder for long messages (not required, just tidy for larger outputs). Key Takeaways Always use a Transaction to modify the model. Handle exceptions and rollback on failure—never leave a transaction open. Collectors are how you find elements efficiently. MVVM + WPF: set data on the ViewModel; the dialog updates automatically. For creating sheets, you need a valid title block type (OST_TitleBlocks). These tutorials were inspired by the work of Aussie BIM Guru. If you’re looking for a deeper dive into the topics, check out his channel for detailed explanations.\n","permalink":"https://blog.aydrafting.com/posts/lesson-1/","summary":"\u003cp\u003eThis post explains \u003cstrong\u003eone concrete command\u003c/strong\u003e—line by line—so a beginner can follow without extra abstractions.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eWhat this command does when you click your add-in button:\u003c/strong\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003eTries to create a \u003cstrong\u003esheet\u003c/strong\u003e (using an \u003cstrong\u003einvalid\u003c/strong\u003e title block on purpose → shows how error handling works).\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eCollects up to \u003cstrong\u003e10 existing sheets\u003c/strong\u003e and formats their numbers/names.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eDisplays the result in a \u003cstrong\u003eWPF dialog\u003c/strong\u003e via a ViewModel.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cblockquote\u003e\n\u003cp\u003e✅ This article focuses only on the command. It assumes you’ve already wired a ribbon button (and .addin) that triggers \u003ccode\u003eStartupCommand\u003c/code\u003e.\u003c/p\u003e","title":"C# + Revit API: Lesson 1 - A Simple Walkthrough of the Command"},{"content":"Why C#? Scalability\nStart with Install Visual Studio 2022 Community Install .NET SDKs (.NET4.8 \u0026amp; .NET8) Install Nice3Point Templates Project Solution Start a solution / project Create a new project Choose the Revit Addin (Nice3Point) Template Configure your new project Name of the project Location Solution Name - same as project name (it\u0026rsquo;s a folder name that holds many projects) Additional Information Add-in type -\u0026gt; Application User Interface -\u0026gt; None IoC -\u0026gt; Disabled Serilog support -\u0026gt; unchecked Explore Visual Studio Properties \u0026amp; Solution Explorer (Project Browser in Revit) Error \u0026amp; Output CSProj -\u0026gt; Preconfigured up to Revit v.2025 .addin -\u0026gt; Change GUID (The rest we will change later) Application Class: Tells your .addin how to begin and how to finish when Revit opens and closes. Class: External Application Method: OnStartup() Will run Create Ribbon() Creates a Panel Adds a PushButton to that Panel With 2 Icons Our Application OnStartup When it begins, it calls a Function \u0026ldquo;CreateRibbon()\u0026rdquo; And CreateRibbon is a defined function below that: Creates a panel This is possible due to pre-configured Revit API that we are using CreatePanel - is a pre-defined method under Revit API that, you guessed it, Creates a Panel in Revit. Creates a button Same for the Button AddPushButton Method in Revit API - Creates a button Commands Folder Core Code Currently: Task Dialog - Shows the name of the .addin ExternalCommand, but we should use IExternalCommand This is the part that writes the logic for your button Once you click the button, whatever is under Commands Folder connected to the button will be executed. If you change the TaskDialog.Show(Document.Title, \u0026ldquo;Hello World\u0026rdquo;); Once you press the button in Revit it would show \u0026ldquo;Hello World\u0026rdquo; Resources: Icons Everything is saved in windows explorer Configurations: Debug and Release Per Revit Version from R20 to R25 References: Under: This PC \u0026gt; Windows (C:) \u0026gt; Program Files \u0026gt; Autodesk \u0026gt; Revit [2025]. DLL Files that you can reference to your project to build something. You could even add an excel package to work with Excel, will do that later. Build and test the first plugin Build the solution by clicking on Run (Play Button) next to Any CPU. Launches Revit (Version that you pre-configured) Always Load your .addin What happened behind the scenes: VS2022 Added the DLL file and the .addin file into the right folder and launched Revit version that you specified with the Plugin loaded into Revit. That became possible due to preconfigured Visual Studio Nice3Point Template that you ran earlier. Everything is already set and pathed for you for the ease of starting and launching plugins. Go to New Project Find your new panel in the panel tabs on the top of Revit UI. Find your Plugin / add-in Click on it And you will get a message with the name of your Tool. Stop Debug Closes Revit \u0026amp; Debug Mode ","permalink":"https://blog.aydrafting.com/posts/lesson-0/","summary":"\u003ch1 id=\"why-c\"\u003eWhy C#?\u003c/h1\u003e\n\u003cp\u003e\u003ccode\u003eScalability\u003c/code\u003e\u003c/p\u003e\n\u003ch1 id=\"start-with\"\u003eStart with\u003c/h1\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"https://visualstudio.microsoft.com/downloads/\"\u003eInstall Visual Studio 2022 Community\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://dotnet.microsoft.com/en-us/download/visual-studio-sdks\"\u003eInstall .NET SDKs (.NET4.8 \u0026amp; .NET8)\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/Nice3point/RevitTemplates\"\u003eInstall Nice3Point Templates\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"project-solution\"\u003eProject Solution\u003c/h1\u003e\n\u003col\u003e\n\u003cli\u003eStart a solution / project\n\u003col\u003e\n\u003cli\u003eCreate a \u003ccode\u003enew project\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eChoose the Revit Addin (\u003ccode\u003eNice3Point\u003c/code\u003e) Template\u003c/li\u003e\n\u003cli\u003eConfigure your new project\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003eName\u003c/code\u003e of the project\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eLocation\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eSolution Name\u003c/code\u003e - same as project name (it\u0026rsquo;s a folder name that holds many projects)\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003eAdditional Information\n\u003col\u003e\n\u003cli\u003eAdd-in type -\u0026gt; \u003ccode\u003eApplication\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eUser Interface -\u0026gt; \u003ccode\u003eNone\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eIoC -\u0026gt; \u003ccode\u003eDisabled\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eSerilog support -\u0026gt; \u003ccode\u003eunchecked\u003c/code\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003eExplore \u003ccode\u003eVisual Studio\u003c/code\u003e\n\u003col\u003e\n\u003cli\u003eProperties \u0026amp; Solution Explorer (Project Browser in Revit)\u003c/li\u003e\n\u003cli\u003eError \u0026amp; Output\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eCSProj\u003c/code\u003e -\u0026gt; Preconfigured up to Revit v.2025\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.addin\u003c/code\u003e -\u0026gt; Change GUID (The rest we will change later)\u003c/li\u003e\n\u003cli\u003eApplication Class:\n\u003col\u003e\n\u003cli\u003eTells your \u003ccode\u003e.addin\u003c/code\u003e how to begin and how to finish when Revit opens and closes.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eClass\u003c/code\u003e: External Application\u003c/li\u003e\n\u003cli\u003eMethod: \u003ccode\u003eOnStartup()\u003c/code\u003e\n\u003col\u003e\n\u003cli\u003eWill run \u003ccode\u003eCreate Ribbon()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eCreates a \u003cstrong\u003e\u003ccode\u003ePanel\u003c/code\u003e\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003eAdds a \u003cstrong\u003e\u003ccode\u003ePushButton\u003c/code\u003e\u003c/strong\u003e to that \u003cstrong\u003ePanel\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003eWith 2 \u003cstrong\u003e\u003ccode\u003eIcons\u003c/code\u003e\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003eOur Application\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003eOnStartup\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eWhen it begins, it calls a Function \u0026ldquo;\u003ccode\u003eCreateRibbon()\u003c/code\u003e\u0026rdquo;\u003c/li\u003e\n\u003cli\u003eAnd CreateRibbon is a defined function below that:\n\u003col\u003e\n\u003cli\u003eCreates a panel\n\u003col\u003e\n\u003cli\u003eThis is possible due to pre-configured Revit API that we are using\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eCreatePanel\u003c/code\u003e - is a pre-defined method under Revit API that, you guessed it, Creates a Panel in Revit.\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003eCreates a button\n\u003col\u003e\n\u003cli\u003eSame for the Button\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eAddPushButton\u003c/code\u003e Method in Revit API - Creates a button\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003eCommands Folder\n\u003col\u003e\n\u003cli\u003eCore Code\u003c/li\u003e\n\u003cli\u003eCurrently: Task Dialog - Shows the name of the \u003ccode\u003e.addin\u003c/code\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003eExternalCommand\u003c/code\u003e, but we should use \u003ccode\u003eIExternalCommand\u003c/code\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003eThis is the part that writes the logic for your button\u003c/li\u003e\n\u003cli\u003eOnce you click the button, whatever is under Commands Folder connected to the button will be executed.\u003c/li\u003e\n\u003cli\u003eIf you change the TaskDialog.Show(Document.Title, \u0026ldquo;Hello World\u0026rdquo;);\n\u003col\u003e\n\u003cli\u003eOnce you press the button in Revit it would show \u0026ldquo;Hello World\u0026rdquo;\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003eResources:\n\u003col\u003e\n\u003cli\u003eIcons\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003eEverything is saved in windows explorer\u003c/li\u003e\n\u003cli\u003eConfigurations:\n\u003col\u003e\n\u003cli\u003eDebug and Release\u003c/li\u003e\n\u003cli\u003ePer Revit Version from R20 to R25\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003eReferences:\n\u003col\u003e\n\u003cli\u003eUnder: This PC \u0026gt; Windows (C:) \u0026gt; Program Files \u0026gt; Autodesk \u0026gt; Revit [2025].\u003c/li\u003e\n\u003cli\u003eDLL Files that you can reference to your project to build something.\u003c/li\u003e\n\u003cli\u003eYou could even add an excel package to work with Excel, will do that later.\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003eBuild and test the first plugin\n\u003col\u003e\n\u003cli\u003eBuild the solution by clicking on \u003ccode\u003eRun\u003c/code\u003e (Play Button) next to \u003ccode\u003eAny CPU\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eLaunches Revit (Version that you pre-configured)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eAlways Load\u003c/code\u003e your \u003ccode\u003e.addin\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eWhat happened behind the scenes:\n\u003col\u003e\n\u003cli\u003eVS2022 Added the DLL file and the \u003ccode\u003e.addin\u003c/code\u003e file into the right folder and launched Revit version that you specified with the Plugin loaded into Revit.\u003c/li\u003e\n\u003cli\u003eThat became possible due to preconfigured Visual Studio \u003ccode\u003eNice3Point\u003c/code\u003e Template that you ran earlier.\u003c/li\u003e\n\u003cli\u003eEverything is already set and pathed for you for the ease of starting and launching plugins.\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003eGo to \u003ccode\u003eNew Project\u003c/code\u003e\n\u003col\u003e\n\u003cli\u003eFind your new panel in the \u003ccode\u003epanel\u003c/code\u003e tabs on the top of Revit UI.\u003c/li\u003e\n\u003cli\u003eFind your Plugin / add-in\u003c/li\u003e\n\u003cli\u003eClick on it\u003c/li\u003e\n\u003cli\u003eAnd you will get a message with the \u003ccode\u003ename\u003c/code\u003e of your Tool.\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003eStop \u003ccode\u003eDebug\u003c/code\u003e\n\u003col\u003e\n\u003cli\u003eCloses Revit \u0026amp; Debug Mode\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ol\u003e","title":"C# + Revit API: Lesson 0"}]